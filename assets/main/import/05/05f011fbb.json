[1,["36fz6aH6BKBafB74IzkvHE","aa3gnuj51BPKnojGhupeFg@73b7f","a7YStUNeNCOKGpSntUY1g5","12Y9dMgWdJKJGmTiZyQR9H@17020","19PM1cBZtHLqMN95K1M5V2","b6mOVasAtJh6i0r4PN3Fn3","aa3gnuj51BPKnojGhupeFg@ef5e1","aa3gnuj51BPKnojGhupeFg@438fe","58d2a2OuBMfJQEPyidLUyv@f9941","farQJE6TpK0bn3pU++pojb@f9941","1brw/JvvpFnIvdrxpFCgMZ","7b+d9AS8lOJYywmlAPlJEC","12Y9dMgWdJKJGmTiZyQR9H@8abdc","a3zQCfCrBCDZJ4uf2rk5u8","03Y0RMBh1C0ZzUP7l4bQjJ@f9941","27GCfJRgRBcJkmMDXVC2i0@f9941","d4TrXWEjRCHZCaZj1HBh61@f9941","20PwsQj0tAC7MEuJWt0md6","cc4BxatY5Oe5y1hRvBj0hB","f8ubEyAg5PwrBuuwx5z15o@f9941","52BxhUAGtHfZCoLzw6ZSyr@f9941","a1Vfk7d2lMpLdfsT5SGThZ","0asxQqaWhAc5WvAmvDsjYj@4a7d8","4fEfjhkEVNFps/OcPtOf6g","f9vSlG2y9HK4DUv5XqZ1nA@ca7df","f9vSlG2y9HK4DUv5XqZ1nA@b3fce","03Y0RMBh1C0ZzUP7l4bQjJ@6c48a","64eFmtmPxFXpWNNpYeCTAo@6c48a","bbxGV3Hd9HGbBpeFCNBURA@6c48a","9aO8bBN3lJ75NzBqy9tW0G@6c48a","27GCfJRgRBcJkmMDXVC2i0@6c48a","45tjLTn3xD8L7zc85tiG1v@6c48a","8bTELNsu9FlaYHsnBpgljb@6c48a","9eGypC2p5JELquWZRBGAjh@6c48a","d7NWdMnvJAG4l7ztn2m/4C@6c48a","5ed4v8u2RMSKoOCwNBG/CT@6c48a","52BxhUAGtHfZCoLzw6ZSyr@6c48a","53vNV8Dt1PmZ+fB6oVqvTm@6c48a","58d2a2OuBMfJQEPyidLUyv@6c48a","58sU6SOEdBHJmdrnaDTjCf@6c48a","f24Izg2iVOqo9G7I0fC+pq@6c48a","ffyyCEsw9Ko7m5QvrFF7Hw@f9941","94n9OjI1RAYYX+YQNnyV+R@f9941","0asxQqaWhAc5WvAmvDsjYj@2df3a","c5CD51rS5OqYsz3udImVsA@6c48a","ccw6dVfT1DBKo7ykeS152f","5eTUjEDjRFr6JoiUhRl+i8","f9vSlG2y9HK4DUv5XqZ1nA@cba39","8fVzICCuxJ6InEcs5BPwwe","14+nDcJ7NFNLsxFcL4KjEN","0aK1Tx4TlHy5hrwzVvv/dk","41NnGv3mdMvJbbTnUKfPFu","43HvKLFn9CRbufwWI7poXf","f3PWoiWEZHzL+A5O8dSQJe","5dE7vIB7pANrKCgg5K/BD7","29HrWwyL5Az69BmgBJKefc","af9eqy9vtH678LvK0B+0sX","2akfaF6MxC/50OHdHwBir3","a3aSc+gDxEgbYpiHgoti9m","8etn7V8/hHhoa+2fTSSJUc","7exP9YFlVC/qMOdjKa60zW","bf9/FFVyxGxaXvk5bv1hJN","29akZy2rlEQLiqrJ9AqgnE","950XG8Pj9BZ5lgXFMlv6zi","20Ixzbuy9HQ4HubM9e1xVS","3fKVerLitAW4g+XIqi0km8","baotT4VF1Gw7/e/C7x23uz","6b0LmY2FtAc7LUJxGS7RTh","5bbNXj10BHnqe3kbdy6Vw7","6bqUs4l/pAQLQCCPGdEd5l","5a8gG1WVFOLKgfrEqtkTLL@b47c0","deWGgHf1lGoI7ZlEApA4zS@6c48a","a0MvSFL9hCGLdLzSgZnTlH@6c48a","94n9OjI1RAYYX+YQNnyV+R@6c48a","001umCEHZMva/B7P0bFWAQ@6c48a","07GNmWOb9KtLtjSWZm/vRn@6c48a","58LKWTXFtKh59ew70Fm9Dq@6c48a","e6yFrkM7tL5ZndTEbosN7F@6c48a","aeGN7qxuBKPb9w7lUz+bqH@6c48a","53vNV8Dt1PmZ+fB6oVqvTm@f9941","58sU6SOEdBHJmdrnaDTjCf@f9941","38I7d2t2hED7zBt/k1RPRn@6c48a","700zdYHB5CTbCr6sdBBVm/","0asxQqaWhAc5WvAmvDsjYj@2b0a8","0asxQqaWhAc5WvAmvDsjYj@0e750","0asxQqaWhAc5WvAmvDsjYj@ef86b","0asxQqaWhAc5WvAmvDsjYj@426f2","0asxQqaWhAc5WvAmvDsjYj@754a2","0asxQqaWhAc5WvAmvDsjYj@71919","0asxQqaWhAc5WvAmvDsjYj@1332c","0asxQqaWhAc5WvAmvDsjYj@4d16f","0asxQqaWhAc5WvAmvDsjYj@efe84","d4TrXWEjRCHZCaZj1HBh61@6c48a","13HJKt+wZKAo5gVwv7OBrg@6c48a","f8ubEyAg5PwrBuuwx5z15o@6c48a","f9vSlG2y9HK4DUv5XqZ1nA@9f3e5","f9vSlG2y9HK4DUv5XqZ1nA@2b619","f9vSlG2y9HK4DUv5XqZ1nA@5eca5","f9vSlG2y9HK4DUv5XqZ1nA@a76ba","f9vSlG2y9HK4DUv5XqZ1nA@98326","f9vSlG2y9HK4DUv5XqZ1nA@81f5f","farQJE6TpK0bn3pU++pojb@6c48a","ffyyCEsw9Ko7m5QvrFF7Hw@6c48a"],["value","targetInfo","node","_mesh","asset","root","_spriteFrame","_effectAsset","_parent","mainTexture","_material","_skeleton","_defaultClip","_textureSource","data","target","_cameraComponent","scene","hitPointController","ganController","eventLayer","currentCard","_envmap"],[["cc.Node",["_name","_layer","_active","_id","_components","_parent","_prefab","_lpos","_children","_lscale","_euler","_lrot"],-1,9,1,4,5,2,5,5,5],"cc.SpriteFrame","cc.ImageAsset",["cc.Widget",["_alignFlags","_originalWidth","_originalHeight","_left","_bottom","_right","node","__prefab"],-3,1,4],["cc.MeshRenderer",["_name","_shadowCastingMode","_shadowReceivingMode","node","_materials","lightmapSettings","_mesh","__prefab"],0,1,3,4,6,4],["cc.Material",["_states","_defines","_techIdx","_name","_props"],-1,12],["cc.UITransform",["node","__prefab","_contentSize","_anchorPoint"],3,1,4,5,5],["cc.PrefabInfo",["fileId","root","asset","instance","targetOverrides"],2,1,6,4,9],["cc.Sprite",["_sizeMode","_fillType","node","__prefab","_spriteFrame"],1,1,4,6],["cc.PrefabInstance",["fileId","propertyOverrides","mountedComponents","prefabRootNode"],2,9,9,1],["cc.PrefabInstance",["fileId","prefabRootNode","propertyOverrides","mountedChildren","mountedComponents"],1,9,9,9],["a6e46xw3QlPS7Q6rRDlrVPP",["onClickListeners","node","__prefab"],3,9,1,4],["cc.Prefab",["_name"],2],["cc.Node",["_name","_layer","_children","_components","_lpos","_parent","_prefab"],1,2,12,5,1,4],["cc.Node",["_name","_parent","_lpos","_children","_prefab","_lrot","_euler","_components"],2,1,5,9,4,5,5,2],["cc.ClickEvent",["_componentId","handler","target"],1,1],["cc.SkeletalAnimation",["playOnLoad","_name","node","__prefab","_clips","_defaultClip"],1,1,4,3,6],["cc.ModelLightmapSettings",["_castShadow","_receiveShadow"],1],["cc.RigidBody",["_type","node"],2,1],["cc.Camera",["_clearFlags","_visibility","_projection","_priority","_orthoHeight","_far","node","_color"],-3,1,5],["cc.CompactValueTypeArray",["_unitCount","_unitElement","_length","_byteOffset"],-1],"cc.TextureCube",["cc.Material",["_name","_props","_states","_defines"],-1],["cc.Mesh",["_native","_dataLength","_hash","_struct"],0,11],["cc.PhysicsMaterial",["_friction","_rollingFriction","_spinningFriction","_restitution"],-1],["cc.EffectAsset",["_name","shaders","techniques"],0],["cc.Node",["_name","_id","_children","_components"],1,2,2],["cc.CompPrefabInfo",["fileId"],2],["9f5aazvwLBC2rk70gjmx3f1",["node","__prefab"],3,1,4],["cc.PrefabInfo",["fileId","root","asset"],2,1,1],["cc.PrefabInfo",["root","fileId","instance","asset"],1,4,6],["cc.RichText",["_string","node","__prefab"],2,1,4],["cc.BlockInputEvents",["node","__prefab"],3,1,4],["dfe80e9FitA7Im9IWiU7Gy3",["node","__prefab","cards"],3,1,4,12],["cc.Layout",["_resizeMode","_layoutType","_spacingX","_spacingY","node","__prefab"],-1,1,4],["cc.MountedComponentsInfo",["targetInfo","components"],3,4,2],["cc.MountedComponentsInfo",["components","targetInfo"],2,4],["cc.MountedComponentsInfo",["targetInfo","components"],3,4,9],["cc.TargetInfo",["localID"],2],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,1],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,1,8],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,4],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,4,8],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,4,1],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,1,1],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,1,4],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,4,4],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,4,6],["cc.SkinnedMeshRenderer",["node","__prefab","_materials","lightmapSettings","_skinningRoot","_mesh","_skeleton"],3,1,4,3,4,1,6,6],["58679b5UTJPRpELfPBmUTOi",["node","__prefab"],3,1,4],["4913eq+2PRFb5zVXfoi8lID",["node","__prefab"],3,1,4],["cc.SceneAsset",["_name"],2],["cc.MountedChildrenInfo",["targetInfo","nodes"],3,4,2],["cc.Canvas",["node","__prefab","_cameraComponent"],3,1,4,1],["cc.MeshRenderer",["_materials","node","__prefab","lightmapSettings","_mesh"],2,1,4,4,6],["cc.SphereCollider",["node","_material"],3,1,6],["57e03QSP2xG0LpXh/OCB5Zh",["node"],3,1],["b644agGMBBB2pAiQXR5K8AW",["node","dropListeners","sleepListeners"],3,1,9,9],["cc.MeshCollider",["_material","_mesh"],3,6,6],["46df1jqX+JN44C7T/ZR7oiO",["node","mainBall","otherBalls"],3,1,1,2],["b94f1KxG3pL+oc2v4/C0XXe",["node"],3,1],["cc.Scene",["_name","_children","_prefab","_globals"],2,2,4,4],["cc.TargetOverrideInfo",["propertyPath","source","target","targetInfo"],2,1,1,4],["cc.SceneGlobals",["ambient","shadows","_skybox","fog"],3,4,4,4,4],["cc.AmbientInfo",[],3],["cc.ShadowsInfo",["_enabled","_pcf","_bias","_selfShadow","_near","_far","_orthoSize","_shadowColor"],-4,5],["cc.SkyboxInfo",["_enabled","_envmap"],2,6],["cc.FogInfo",[],3],["21ecbTtEJlDl4l95vj6zzhO",["autoRotate","node"],2,1],["cc.DirectionalLight",["_illuminance","node","_staticSettings"],2,1,4],["cc.StaticLightSettings",["_castShadow"],2],["cc.Skeleton",["_name","_hash","_joints","_bindposes"],0,12],["cc.AnimationClip",["_name","_native","sample","wrapMode","enableTrsBlending","_duration","_hash","_keys","_curves"],-4,9,12],["cc.animation.HierarchyPath",["path"],2],["9cbe3kuPIFN+ajx8IrzxuX/",["node","__prefab"],3,1,4],["cc.Mask",["node","__prefab"],3,1,4]],[[38,0,2],[43,0,1,2,2],[41,0,1,2,3],[44,0,1,2,2],[27,0,2],[29,0,1,2,2],[42,0,1,2,2],[17,1],[39,0,1,2,3],[15,0,1,2,3],[6,0,1,2,1],[7,0,1,3,2,2],[9,0,3,2,1,2],[40,0,1,2,2],[36,0,1,2],[8,2,3,4,1],[0,0,5,8,6,7,11,9,10,2],[0,0,5,6,7,11,10,2],[14,0,1,3,4,2,5,6,2],[20,3,0,1,2,5],[5,0,1,4,3],[0,5,6,1],[37,0,1,1],[23,0,1,2,3,4],[0,0,5,4,6,11,9,10,2],[0,6,1],[0,0,5,4,9,2],[17,0,1,3],[4,0,1,3,7,4,5,6,3],[55,0,1,1],[18,1,1],[57,0,1,2,1],[11,0,1],[0,0,5,8,6,2],[46,0,1,2,2],[48,0,1,2,3,4,5,6,1],[0,0,5,8,4,6,7,11,9,10,2],[7,0,1,2,2],[16,1,0,2,3,4,5,3],[0,0,1,5,4,6,3],[0,0,2,1,5,4,6,7,4],[45,0,1,2,2],[0,0,5,4,6,7,11,9,10,2],[4,1,3,7,4,5,6,2],[73,0,2],[12,0,2],[3,0,1,2,6,7,4],[11,1,2,0,1],[4,0,3,7,4,5,6,2],[0,0,5,4,7,11,9,10,2],[15,1],[5,3,0,1,4,4],[0,0,1,5,4,6,7,3],[0,0,1,5,4,7,3],[6,0,1,1],[3,0,6,7,2],[8,0,2,3,4,2],[25,0,1,2,4],[0,0,8,6,2],[0,0,2,5,8,3],[0,0,2,1,5,4,7,4],[0,0,1,5,8,4,6,7,3],[28,0,1,1],[31,0,1,2,2],[8,1,0,2,3,4,3],[9,0,1,2],[4,3,7,4,5,6,1],[62,0,1,2,3,2],[5,2,0,1,4,4],[24,0,1,2,3,5],[0,0,2,1,5,4,6,4],[0,0,2,1,8,4,6,4],[0,0,1,5,8,4,6,3],[0,0,1,5,4,6,9,3],[0,0,1,5,4,3],[0,0,5,4,7,11,10,2],[6,0,1,2,3,1],[32,0,1,1],[11,1,0,1],[16,0,2,3,4,5,2],[54,0,1,2,3,4,2],[18,0,2],[58,0,1,1],[22,0,1,2,3,5],[12,1],[0,0,8,4,6,2],[0,0,5,8,4,6,7,9,2],[0,0,2,8,4,6,3],[0,0,2,1,5,4,6,9,4],[0,0,1,3,8,4,7,4],[0,0,5,8,4,2],[0,0,2,1,5,4,4],[0,0,2,4,7,9,10,3],[0,0,2,5,4,7,9,3],[0,0,2,1,8,4,6,7,4],[0,0,5,4,6,7,9,10,2],[13,0,1,5,2,3,6,4,3],[13,0,1,2,3,4,3],[14,0,1,7,2,2],[26,0,1,2,3,3],[7,4,1],[30,0,1,2,3,3],[3,0,3,4,6,4],[3,0,5,6,7,3],[3,6,7,1],[33,0,1,2,1],[34,0,1,2,3,4,5,5],[9,0,2,1,2],[10,0,1,3,2,3],[10,0,1,4,2,3],[10,0,1,2,3],[35,0,1,1],[47,0,1,2,2],[49,0,1,1],[50,0,1,1],[51,0,2],[52,0,1,1],[53,0,1,2,1],[4,2,3,4,5,6,2],[56,0,1],[59,0,1,2,1],[60,0,1],[61,0,1,2,3,2],[63,0,1,2,3,1],[64,1],[65,0,1,2,3,4,5,6,7,8],[66,0,1,2],[67,1],[19,0,1,6,3],[19,2,3,4,5,0,1,6,7,7],[68,0,1,2],[69,0,1,2,2],[70,0,2],[71,0,1,2,3,4],[72,0,1,2,3,4,5,6,7,8,8],[20,0,1,2,4],[74,0,1,1],[75,0,1,1]],[[[{"name":"card","rect":{"x":5,"y":3,"width":85,"height":104},"offset":{"x":0.5,"y":0.5},"originalSize":{"width":94,"height":111},"rotated":false,"capInsets":[0,0,0,0],"texture":"0363444c-061d-42d1-9cd4-3fb9786d08c9@6c48a","packable":true}],[1],0,[0],[13],[26]],[[[20,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{}],[{"USE_POSITION_SCALING":true},{"USE_BASE_COLOR_MAP":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{},{}],[[{},[{"baseStep":0.9,"baseFeather":0.3,"shadeStep":0.6,"shadeFeather":0.2},"tilingOffset",8,[2,2,1,0,0],"mainColor",8,[4,4284769380],"shadeColor1",8,[4,4283453520],"shadeColor2",8,[4,1661602314],"specular",8,[4,1275068415],"emissive",8,[4,0],"mainTexture",6,0],{},{}],0,11,0,0]]],0,0,[0,0],[9,7],[27,2]],[[[23,".bin",25852,1908930080,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":22336,"length":3516,"count":1758,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":22336,"count":349,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1.0263243913650513,-0.3362765312194824,-0.03969179466366768],"maxPosition",8,[1,1.0416858196258545,0.37944579124450684,2.4551167488098145]]]],0,0,[],[],[]],[[[23,".bin",25788,2462528742,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":22272,"length":3516,"count":1758,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":22272,"count":348,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1.0627228021621704,-0.22964781522750854,-0.03969179466366768],"maxPosition",8,[1,1.0608391761779785,0.271166056394577,2.4551167488098145]]]],0,0,[],[],[]],[[[23,".bin",5760,1395715433,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":4752,"length":1008,"count":504,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":4752,"count":99,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-2.0139009952545166,-2.0199241638183594,-0.5083037614822388],"maxPosition",8,[1,2.0139009952545166,2.0199241638183594,0.41632819175720215]]]],0,0,[],[],[]],[[[23,".bin",19640,2930109689,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":17024,"length":2616,"count":1308,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":17024,"count":266,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.8331011533737183,-0.3728335201740265,-0.03329771012067795],"maxPosition",8,[1,0.7926641702651978,0.46718841791152954,2.0596137046813965]]]],0,0,[],[],[]],[[[23,".bin",49300,969163832,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":44032,"length":5268,"count":2634,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":44032,"count":688,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-26.697162628173828,-5.055922985076904,-21.154483795166016],"maxPosition",8,[1,60.5887565612793,11.239510536193848,12.134369850158691]]]],0,0,[],[],[]],[[[23,".bin",19640,2915387618,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":17024,"length":2616,"count":1308,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":17024,"count":266,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.7926226854324341,-0.7388861179351807,-0.05313277989625931],"maxPosition",8,[1,0.3647039830684662,0.5992574691772461,2.038058042526245]]]],0,0,[],[],[]],[[[23,".bin",25660,3602215295,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":22144,"length":3516,"count":1758,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":22144,"count":346,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.9536016583442688,-0.38312095403671265,-0.05688628926873207],"maxPosition",8,[1,0.487619012594223,0.4689179062843323,1.8973422050476074]]]],0,0,[],[],[]],[[[23,".bin",25660,1913840364,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":22144,"length":3516,"count":1758,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":22144,"count":346,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1.091290831565857,-0.41489967703819275,-0.07584762573242188],"maxPosition",8,[1,0.9092828035354614,0.5096479654312134,2.450913906097412]]]],0,0,[],[],[]],[[[23,".bin",19838,276433534,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":17216,"length":2622,"count":1311,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":17216,"count":269,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.7611004710197449,-0.18266357481479645,-0.06545485556125641],"maxPosition",8,[1,0.961718738079071,0.5065948367118835,2.02461838722229]]]],0,0,[],[],[]],[[[23,".bin",19838,2103118564,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":17216,"length":2622,"count":1311,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":17216,"count":269,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.49995025992393494,-0.4541564881801605,-0.09076808393001556],"maxPosition",8,[1,0.9192519783973694,0.6330084204673767,2.026685953140259]]]],0,0,[],[],[]],[[[23,".bin",81448,3337052603,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":69160,"length":12288,"count":6144,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":69160,"count":1235,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-0.5,-0.5,-0.5],"maxPosition",8,[1,0.5,0.5,0.5]]]],0,0,[],[],[]],[[[23,".bin",15328,1134179529,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":14560,"length":768,"count":384,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":14560,"count":260,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-0.5,-1,-0.5],"maxPosition",8,[1,0.5,1,0.5]]]],0,0,[],[],[]],[[[20,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{}],[{"USE_POSITION_SCALING":true},{"USE_BASE_COLOR_MAP":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{},{}],[[{},[{"baseStep":0.9,"baseFeather":0.3,"shadeStep":0.6,"shadeFeather":0.2},"tilingOffset",8,[2,2,1,0,0],"mainColor",8,[4,4284769380],"shadeColor1",8,[4,4283453520],"shadeColor2",8,[4,1661602314],"specular",8,[4,1275068415],"emissive",8,[4,0],"mainTexture",6,0],{},{}],0,11,0,0]]],0,0,[0,0],[9,7],[28,2]],[[[69,0.3,0.028,0.028,0.8]],0,0,[],[],[]],[[[57,"builtin-standard",[{"hash":971152766,"name":"builtin-standard|standard-vs|standard-fs","glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 6) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 7) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 8) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      layout(location = 7) in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 5) uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\n  layout(location = 8) in vec4 a_matWorld0;\n  layout(location = 9) in vec4 a_matWorld1;\n  layout(location = 10) in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    layout(location = 11) in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n  layout(set = 2, binding = 0) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(set = 2, binding = 0) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nlayout(location = 0) out float v_fog_factor;\nlayout(location = 1) out highp vec4 v_shadowPos;\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform sampler2D cc_spotLightingMap;\n#endif\n#if USE_VERTEX_COLOR\n  layout(location = 13) in vec4 a_color;\n  layout(location = 2) out vec4 v_color;\n#endif\nlayout(location = 3) out vec3 v_position;\nlayout(location = 4) out vec3 v_normal;\nlayout(location = 5) out vec2 v_uv;\nlayout(location = 6) out vec2 v_uv1;\n#if USE_NORMAL_MAP\n  layout(location = 7) out vec3 v_tangent;\n  layout(location = 8) out vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  layout(location = 14) in vec2 a_texCoord1;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  layout(location = 9) out vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.zw;\n    v_luv.z = cc_lightingMapUVParam.z;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.zw;\n    v_luv.z = a_lightingMapUVParam.z;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n    #if CC_USE_FOG == 0\n      v_fog_factor = LinearFog(pos);\n    #elif CC_USE_FOG == 1\n      v_fog_factor = ExpFog(pos);\n    #elif CC_USE_FOG == 2\n      v_fog_factor = ExpSquaredFog(pos);\n    #elif CC_USE_FOG == 3\n      v_fog_factor = LayeredFog(pos);\n    #else\n      v_fog_factor = 1.0;\n    #endif\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nlayout(location = 0) in float v_fog_factor;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform sampler2D cc_spotLightingMap;\n  float CCGetLinearDepth (vec3 worldPos) {\n    vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n    float dist = length(viewStartPos.xyz);\n    return cc_shadowNFLSInfo.x + (-dist / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x));\n  }\n  float CCGetShadowFactorX1 (vec4 shadowPos) {\n    vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    } else {\n      closestDepth = texture(cc_shadowMap, clipPos.xy).x;\n    }\n    shadow = step(closestDepth, clipPos.z- cc_shadowWHPBInfo.w);\n    return shadow;\n  }\n  float CCGetShadowFactorX5 (vec4 shadowPos) {\n    vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n    float offsety = 1.0 / cc_shadowWHPBInfo.y;\n    float shadow = 0.0;\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      float closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n      closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n      closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n      closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n      closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n    } else {\n      float closestDepth = texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)).x;\n      shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n      closestDepth = texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)).x;\n      shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n      closestDepth = texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x;\n      shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n      closestDepth = texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)).x;\n      shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n      closestDepth = texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)).x;\n      shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n    }\n    return shadow / 5.0;\n  }\n  float CCGetShadowFactorX9 (vec4 shadowPos) {\n    vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n    float offsety = 1.0 / cc_shadowWHPBInfo.y;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      for (int i = -1; i <= 1; i++) {\n          for (int j = -1; j <= 1; j++) {\n            float closestDepth = dot(texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n            shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          }\n      }\n    } else {\n      for (int i = -1; i <= 1; i++) {\n          for (int j = -1; j <= 1; j++) {\n            float closestDepth = texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\n            shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          }\n      }\n    }\n    return shadow / 9.0;\n  }\n  float CCGetShadowFactorX25 (vec4 shadowPos) {\n    vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n    float offsety = 1.0 / cc_shadowWHPBInfo.y;\n    float shadow = 0.0;\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      for (int i = -2; i <= 2; i++) {\n        for (int j = -2; j <= 2; j++) {\n          float closestDepth = dot(texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n        }\n      }\n    } else {\n      for (int i = -2; i <= 2; i++) {\n        for (int j = -2; j <= 2; j++) {\n          float closestDepth = texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n        }\n      }\n    }\n    return shadow / 25.0;\n  }\n  float CCGetDirLightShadowFactorX1 (vec4 shadowPos, vec3 worldPos) {\n    vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    float depth = 0.0;\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    } else {\n      closestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n    }\n    shadow = step(closestDepth, depth - cc_shadowWHPBInfo.w);\n    return shadow;\n  }\n  float CCGetDirLightShadowFactorX5 (vec4 shadowPos, vec3 worldPos) {\n    vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n    float offsety = 1.0 / cc_shadowWHPBInfo.y;\n    float shadow = 0.0;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      float closestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n      closestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n      closestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n      closestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n      closestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n    } else {\n      float closestDepth = texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)).x;\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n      closestDepth = texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)).x;\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n      closestDepth = texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x;\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n      closestDepth = texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)).x;\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n      closestDepth = texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)).x;\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n    }\n    return shadow / 5.0;\n  }\n  float CCGetDirLightShadowFactorX9 (vec4 shadowPos, vec3 worldPos) {\n    vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n    float offsety = 1.0 / cc_shadowWHPBInfo.y;\n    float shadow = 0.0;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      for (int i = -1; i <= 1; i++) {\n        for (int j = -1; j <= 1; j++) {\n          float closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n        }\n      }\n    } else {\n      for (int i = -1; i <= 1; i++) {\n        for (int j = -1; j <= 1; j++) {\n          float closestDepth = texture(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\n          shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n        }\n      }\n    }\n    return shadow / 9.0;\n  }\n  float CCGetDirLightShadowFactorX25 (vec4 shadowPos, vec3 worldPos) {\n    vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n    float offsety = 1.0 / cc_shadowWHPBInfo.y;\n    float depth = 0.0;\n    float shadow = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      for (int i = -2; i <= 2; i++) {\n        for (int j = -2; j <= 2; j++) {\n          float closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n        }\n      }\n    } else {\n      for (int i = -2; i <= 2; i++) {\n        for (int j = -2; j <= 2; j++) {\n          float closestDepth = texture(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n        }\n      }\n    }\n    return shadow / 25.0;\n  }\n#endif\n#if CC_USE_IBL\n  layout(set = 0, binding = 4) uniform samplerCube cc_environment;\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n  }\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\nstruct StandardSurface {\n  vec4 albedo;\n  vec3 position;\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - s.position);\n  float NV = max(abs(dot(N, V)), 0.001);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L + V);\n  float NH = max(dot(N, H), 0.0);\n  float NL = max(dot(N, L), 0.001);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n  vec3 diffuseContrib = diffuse;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    if (s.lightmap_test > 0.0001) {\n      finalColor = s.lightmap.rgb;\n    }\n  #else\n    diffuseContrib /= 3.14159265359;\n  #endif\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  finalColor *= (diffuseContrib + specularContrib);\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n  finalColor += (ambDiff.rgb * diffuse);\n  #if CC_USE_IBL\n    vec3 R = normalize(reflect(-V, N));\n    vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n    #if CC_USE_IBL == 2\n      vec3 env = unpackRGBE(envmap);\n    #else\n      vec3 env = SRGBToLinear(envmap.rgb);\n    #endif\n    finalColor += env * cc_ambientSky.w * specular;\n  #endif\n  finalColor = finalColor * s.occlusion;\n  #if CC_USE_HDR\n    s.emissive *= cc_exposure.w;\n  #endif\n  finalColor += s.emissive;\n  #if CC_RECEIVE_SHADOW\n    {\n      float pcf = cc_shadowWHPBInfo.z + 0.001;\n      float shadowAttenuation = 0.0;\n      float cosAngle = clamp(1.0 - dot(N, L.xyz), 0.0, 1.0);\n      vec3 projWorldPos = shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\n      vec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\n      if (pcf > 3.0) shadowAttenuation = CCGetShadowFactorX25(pos);\n      else if (pcf > 2.0) shadowAttenuation = CCGetShadowFactorX9(pos);\n      else if (pcf > 1.0) shadowAttenuation = CCGetShadowFactorX5(pos);\n      else shadowAttenuation = CCGetShadowFactorX1(pos);\n      vec3 shadowColor = cc_shadowColor.rgb * cc_shadowColor.a + finalColor.rgb * (1.0 - cc_shadowColor.a);\n      if (cc_shadowNFLSInfo.w > 0.000001) {\n        finalColor.rgb = shadowColor.rgb * shadowAttenuation + finalColor.rgb * (1.0 - shadowAttenuation);\n      } else {\n        finalColor.rgb = shadowColor.rgb * shadowAttenuation * NL + finalColor.rgb * (1.0 - shadowAttenuation * NL);\n      }\n    }\n  #endif\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = sqrt(ACESToneMap(color.rgb));\n  #endif\n  return color;\n}\nlayout(location = 1) in highp vec4 v_shadowPos;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  layout(location = 9) in vec3 v_luv;\n  layout(set = 2, binding = 9) uniform sampler2D cc_lightingMap;\n  vec3 UnpackLightingmap(vec4 color) {\n    vec3 c;\n    float e = 1.0 + color.a * (8.0 - 1.0);\n    c.r = color.r * e;\n    c.g = color.g * e;\n    c.b = color.b * e;\n    return c;\n  }\n#endif\nlayout(location = 3) in vec3 v_position;\nlayout(location = 5) in vec2 v_uv;\nlayout(location = 6) in vec2 v_uv1;\nlayout(location = 4) in vec3 v_normal;\n#if USE_VERTEX_COLOR\n  layout(location = 2) in vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  layout(set = 1, binding = 1) uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  layout(location = 7) in vec3 v_tangent;\n  layout(location = 8) in vec3 v_bitangent;\n  layout(set = 1, binding = 2) uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  layout(set = 1, binding = 3) uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  layout(set = 1, binding = 4) uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  layout(set = 1, binding = 5) uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  layout(set = 1, binding = 6) uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor *= v_color;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec4 lightColor = texture(cc_lightingMap, v_luv.xy);\n    s.lightmap = UnpackLightingmap(lightColor);\n    s.lightmap_test = v_luv.z;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * pbrParams.w) * normalize(v_tangent) +\n      (nmmp.y * pbrParams.w) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  s.position = v_position;\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture(pbrMap, PBR_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture(occlusionMap, PBR_UV).r;\n  #endif\n  s.occlusion = clamp(pbr.x, 0.0, 0.96);\n  s.roughness = clamp(pbr.y, 0.04, 1.0);\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n  # define LIGHTS_PER_PASS 1\n  #else\n  # define LIGHTS_PER_PASS 10\n  #endif\n  layout(set = 2, binding = 1) uniform CCForwardLight {\n    highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n    vec4 cc_lightColor[LIGHTS_PER_PASS];\n    vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n    vec4 cc_lightDir[LIGHTS_PER_PASS];\n  };\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - s.position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      #if CC_RECEIVE_SHADOW\n        if (cc_lightPos[i].w > 0.0) {\n          {\n            float pcf = cc_shadowWHPBInfo.z + 0.001;\n            float shadowAttenuation = 0.0;\n            float cosAngle = clamp(1.0 - dot(N, normalize(cc_lightPos[i].xyz - s.position.xyz)), 0.0, 1.0);\n            vec3 projWorldPos = shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\n            vec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\n            if (pcf > 3.0) shadowAttenuation = CCGetDirLightShadowFactorX25(pos, s.position);\n            else if (pcf > 2.0) shadowAttenuation = CCGetDirLightShadowFactorX9(pos, s.position);\n            else if (pcf > 1.0) shadowAttenuation = CCGetDirLightShadowFactorX5(pos, s.position);\n            else shadowAttenuation = CCGetDirLightShadowFactorX1(pos, s.position);\n            lightColor *= 1.0 - shadowAttenuation;\n          }\n        }\n      #endif\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    finalColor = finalColor * s.occlusion;\n    return vec4(finalColor, 0.0);\n  }\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    color = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\n    fragColorX = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 0\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    color = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\n    fragColorX = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  layout(location = 0) out vec4 fragColor0;\n  layout(location = 1) out vec4 fragColor1;\n  layout(location = 2) out vec4 fragColor2;\n  layout(location = 3) out vec4 fragColor3;\n  void main () {\n    StandardSurface s; surf(s);\n    fragColor0 = s.albedo;\n    fragColor1 = vec4(s.position, s.roughness);\n    fragColor2 = vec4(s.normal, s.metallic);\n    fragColor3 = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"glsl3":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n  layout(std140) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nout float v_fog_factor;\nout highp vec4 v_shadowPos;\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\n#if CC_RECEIVE_SHADOW\n  uniform sampler2D cc_shadowMap;\n  uniform sampler2D cc_spotLightingMap;\n#endif\n#if USE_VERTEX_COLOR\n  in vec4 a_color;\n  out vec4 v_color;\n#endif\nout vec3 v_position;\nout vec3 v_normal;\nout vec2 v_uv;\nout vec2 v_uv1;\n#if USE_NORMAL_MAP\n  out vec3 v_tangent;\n  out vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  out vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.zw;\n    v_luv.z = cc_lightingMapUVParam.z;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.zw;\n    v_luv.z = a_lightingMapUVParam.z;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n    #if CC_USE_FOG == 0\n      v_fog_factor = LinearFog(pos);\n    #elif CC_USE_FOG == 1\n      v_fog_factor = ExpFog(pos);\n    #elif CC_USE_FOG == 2\n      v_fog_factor = ExpSquaredFog(pos);\n    #elif CC_USE_FOG == 3\n      v_fog_factor = LayeredFog(pos);\n    #else\n      v_fog_factor = 1.0;\n    #endif\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nin float v_fog_factor;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\n#if CC_RECEIVE_SHADOW\n  uniform sampler2D cc_shadowMap;\n  uniform sampler2D cc_spotLightingMap;\n  float CCGetLinearDepth (vec3 worldPos) {\n    vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n    float dist = length(viewStartPos.xyz);\n    return cc_shadowNFLSInfo.x + (-dist / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x));\n  }\n  float CCGetShadowFactorX1 (vec4 shadowPos) {\n    vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    } else {\n      closestDepth = texture(cc_shadowMap, clipPos.xy).x;\n    }\n    shadow = step(closestDepth, clipPos.z- cc_shadowWHPBInfo.w);\n    return shadow;\n  }\n  float CCGetShadowFactorX5 (vec4 shadowPos) {\n    vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n    float offsety = 1.0 / cc_shadowWHPBInfo.y;\n    float shadow = 0.0;\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      float closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n      closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n      closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n      closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n      closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n    } else {\n      float closestDepth = texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)).x;\n      shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n      closestDepth = texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)).x;\n      shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n      closestDepth = texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x;\n      shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n      closestDepth = texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)).x;\n      shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n      closestDepth = texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)).x;\n      shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n    }\n    return shadow / 5.0;\n  }\n  float CCGetShadowFactorX9 (vec4 shadowPos) {\n    vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n    float offsety = 1.0 / cc_shadowWHPBInfo.y;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      for (int i = -1; i <= 1; i++) {\n          for (int j = -1; j <= 1; j++) {\n            float closestDepth = dot(texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n            shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          }\n      }\n    } else {\n      for (int i = -1; i <= 1; i++) {\n          for (int j = -1; j <= 1; j++) {\n            float closestDepth = texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\n            shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          }\n      }\n    }\n    return shadow / 9.0;\n  }\n  float CCGetShadowFactorX25 (vec4 shadowPos) {\n    vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n    float offsety = 1.0 / cc_shadowWHPBInfo.y;\n    float shadow = 0.0;\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      for (int i = -2; i <= 2; i++) {\n        for (int j = -2; j <= 2; j++) {\n          float closestDepth = dot(texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n        }\n      }\n    } else {\n      for (int i = -2; i <= 2; i++) {\n        for (int j = -2; j <= 2; j++) {\n          float closestDepth = texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n        }\n      }\n    }\n    return shadow / 25.0;\n  }\n  float CCGetDirLightShadowFactorX1 (vec4 shadowPos, vec3 worldPos) {\n    vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    float depth = 0.0;\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    } else {\n      closestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n    }\n    shadow = step(closestDepth, depth - cc_shadowWHPBInfo.w);\n    return shadow;\n  }\n  float CCGetDirLightShadowFactorX5 (vec4 shadowPos, vec3 worldPos) {\n    vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n    float offsety = 1.0 / cc_shadowWHPBInfo.y;\n    float shadow = 0.0;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      float closestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n      closestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n      closestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n      closestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n      closestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n    } else {\n      float closestDepth = texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)).x;\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n      closestDepth = texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)).x;\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n      closestDepth = texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x;\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n      closestDepth = texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)).x;\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n      closestDepth = texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)).x;\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n    }\n    return shadow / 5.0;\n  }\n  float CCGetDirLightShadowFactorX9 (vec4 shadowPos, vec3 worldPos) {\n    vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n    float offsety = 1.0 / cc_shadowWHPBInfo.y;\n    float shadow = 0.0;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      for (int i = -1; i <= 1; i++) {\n        for (int j = -1; j <= 1; j++) {\n          float closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n        }\n      }\n    } else {\n      for (int i = -1; i <= 1; i++) {\n        for (int j = -1; j <= 1; j++) {\n          float closestDepth = texture(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\n          shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n        }\n      }\n    }\n    return shadow / 9.0;\n  }\n  float CCGetDirLightShadowFactorX25 (vec4 shadowPos, vec3 worldPos) {\n    vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n    float offsety = 1.0 / cc_shadowWHPBInfo.y;\n    float depth = 0.0;\n    float shadow = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      for (int i = -2; i <= 2; i++) {\n        for (int j = -2; j <= 2; j++) {\n          float closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n        }\n      }\n    } else {\n      for (int i = -2; i <= 2; i++) {\n        for (int j = -2; j <= 2; j++) {\n          float closestDepth = texture(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n        }\n      }\n    }\n    return shadow / 25.0;\n  }\n#endif\n#if CC_USE_IBL\n  uniform samplerCube cc_environment;\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n  }\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\nstruct StandardSurface {\n  vec4 albedo;\n  vec3 position;\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - s.position);\n  float NV = max(abs(dot(N, V)), 0.001);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L + V);\n  float NH = max(dot(N, H), 0.0);\n  float NL = max(dot(N, L), 0.001);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n  vec3 diffuseContrib = diffuse;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    if (s.lightmap_test > 0.0001) {\n      finalColor = s.lightmap.rgb;\n    }\n  #else\n    diffuseContrib /= 3.14159265359;\n  #endif\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  finalColor *= (diffuseContrib + specularContrib);\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n  finalColor += (ambDiff.rgb * diffuse);\n  #if CC_USE_IBL\n    vec3 R = normalize(reflect(-V, N));\n    vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n    #if CC_USE_IBL == 2\n      vec3 env = unpackRGBE(envmap);\n    #else\n      vec3 env = SRGBToLinear(envmap.rgb);\n    #endif\n    finalColor += env * cc_ambientSky.w * specular;\n  #endif\n  finalColor = finalColor * s.occlusion;\n  #if CC_USE_HDR\n    s.emissive *= cc_exposure.w;\n  #endif\n  finalColor += s.emissive;\n  #if CC_RECEIVE_SHADOW\n    {\n      float pcf = cc_shadowWHPBInfo.z + 0.001;\n      float shadowAttenuation = 0.0;\n      float cosAngle = clamp(1.0 - dot(N, L.xyz), 0.0, 1.0);\n      vec3 projWorldPos = shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\n      vec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\n      if (pcf > 3.0) shadowAttenuation = CCGetShadowFactorX25(pos);\n      else if (pcf > 2.0) shadowAttenuation = CCGetShadowFactorX9(pos);\n      else if (pcf > 1.0) shadowAttenuation = CCGetShadowFactorX5(pos);\n      else shadowAttenuation = CCGetShadowFactorX1(pos);\n      vec3 shadowColor = cc_shadowColor.rgb * cc_shadowColor.a + finalColor.rgb * (1.0 - cc_shadowColor.a);\n      if (cc_shadowNFLSInfo.w > 0.000001) {\n        finalColor.rgb = shadowColor.rgb * shadowAttenuation + finalColor.rgb * (1.0 - shadowAttenuation);\n      } else {\n        finalColor.rgb = shadowColor.rgb * shadowAttenuation * NL + finalColor.rgb * (1.0 - shadowAttenuation * NL);\n      }\n    }\n  #endif\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = sqrt(ACESToneMap(color.rgb));\n  #endif\n  return color;\n}\nin highp vec4 v_shadowPos;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  in vec3 v_luv;\n  uniform sampler2D cc_lightingMap;\n  vec3 UnpackLightingmap(vec4 color) {\n    vec3 c;\n    float e = 1.0 + color.a * (8.0 - 1.0);\n    c.r = color.r * e;\n    c.g = color.g * e;\n    c.b = color.b * e;\n    return c;\n  }\n#endif\nin vec3 v_position;\nin vec2 v_uv;\nin vec2 v_uv1;\nin vec3 v_normal;\n#if USE_VERTEX_COLOR\n  in vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  in vec3 v_tangent;\n  in vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor *= v_color;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec4 lightColor = texture(cc_lightingMap, v_luv.xy);\n    s.lightmap = UnpackLightingmap(lightColor);\n    s.lightmap_test = v_luv.z;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * pbrParams.w) * normalize(v_tangent) +\n      (nmmp.y * pbrParams.w) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  s.position = v_position;\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture(pbrMap, PBR_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture(occlusionMap, PBR_UV).r;\n  #endif\n  s.occlusion = clamp(pbr.x, 0.0, 0.96);\n  s.roughness = clamp(pbr.y, 0.04, 1.0);\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n  # define LIGHTS_PER_PASS 1\n  #else\n  # define LIGHTS_PER_PASS 10\n  #endif\n  layout(std140) uniform CCForwardLight {\n    highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n    vec4 cc_lightColor[LIGHTS_PER_PASS];\n    vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n    vec4 cc_lightDir[LIGHTS_PER_PASS];\n  };\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - s.position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      #if CC_RECEIVE_SHADOW\n        if (cc_lightPos[i].w > 0.0) {\n          {\n            float pcf = cc_shadowWHPBInfo.z + 0.001;\n            float shadowAttenuation = 0.0;\n            float cosAngle = clamp(1.0 - dot(N, normalize(cc_lightPos[i].xyz - s.position.xyz)), 0.0, 1.0);\n            vec3 projWorldPos = shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\n            vec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\n            if (pcf > 3.0) shadowAttenuation = CCGetDirLightShadowFactorX25(pos, s.position);\n            else if (pcf > 2.0) shadowAttenuation = CCGetDirLightShadowFactorX9(pos, s.position);\n            else if (pcf > 1.0) shadowAttenuation = CCGetDirLightShadowFactorX5(pos, s.position);\n            else shadowAttenuation = CCGetDirLightShadowFactorX1(pos, s.position);\n            lightColor *= 1.0 - shadowAttenuation;\n          }\n        }\n      #endif\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    finalColor = finalColor * s.occlusion;\n    return vec4(finalColor, 0.0);\n  }\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    color = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\n    fragColorX = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 0\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    color = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\n    fragColorX = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  layout(location = 0) out vec4 fragColor0;\n  layout(location = 1) out vec4 fragColor1;\n  layout(location = 2) out vec4 fragColor2;\n  layout(location = 3) out vec4 fragColor3;\n  void main () {\n    StandardSurface s; surf(s);\n    fragColor0 = s.albedo;\n    fragColor1 = vec4(s.position, s.roughness);\n    fragColor2 = vec4(s.normal, s.metallic);\n    fragColor3 = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"glsl1":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      attribute highp vec4 a_jointAnimInfo;\n    #endif\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n#if USE_INSTANCING\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n  uniform highp mat4 cc_matWorlds[10];\n#else\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  uniform highp vec4 cc_lightingMapUVParam;\n#endif\n      uniform vec4 tilingOffset;\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvarying float v_fog_factor;\nvarying highp vec4 v_shadowPos;\nuniform highp mat4 cc_matLightViewProj;\n#if CC_RECEIVE_SHADOW\n  uniform sampler2D cc_shadowMap;\n  uniform sampler2D cc_spotLightingMap;\n#endif\n#if USE_VERTEX_COLOR\n  attribute vec4 a_color;\n  varying vec4 v_color;\n#endif\nvarying vec3 v_position;\nvarying vec3 v_normal;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  varying vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.zw;\n    v_luv.z = cc_lightingMapUVParam.z;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.zw;\n    v_luv.z = a_lightingMapUVParam.z;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n    #if CC_USE_FOG == 0\n      v_fog_factor = LinearFog(pos);\n    #elif CC_USE_FOG == 1\n      v_fog_factor = ExpFog(pos);\n    #elif CC_USE_FOG == 2\n      v_fog_factor = ExpSquaredFog(pos);\n    #elif CC_USE_FOG == 3\n      v_fog_factor = LayeredFog(pos);\n    #else\n      v_fog_factor = 1.0;\n    #endif\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\nuniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_exposure;\n  uniform mediump vec4 cc_mainLitDir;\n  uniform mediump vec4 cc_mainLitColor;\n  uniform mediump vec4 cc_ambientSky;\n  uniform mediump vec4 cc_ambientGround;\n  uniform mediump vec4 cc_fogColor;\n     uniform vec4 albedo;\n     uniform vec4 albedoScaleAndCutoff;\n     uniform vec4 pbrParams;\n     uniform vec4 emissive;\n     uniform vec4 emissiveScaleParam;\nvarying float v_fog_factor;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nuniform highp mat4 cc_matLightView;\n  uniform lowp vec4 cc_shadowNFLSInfo;\n  uniform lowp vec4 cc_shadowWHPBInfo;\n  uniform lowp vec4 cc_shadowLPNNInfo;\n  uniform lowp vec4 cc_shadowColor;\n#if CC_RECEIVE_SHADOW\n  uniform sampler2D cc_shadowMap;\n  uniform sampler2D cc_spotLightingMap;\n  float CCGetLinearDepth (vec3 worldPos) {\n    vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n    float dist = length(viewStartPos.xyz);\n    return cc_shadowNFLSInfo.x + (-dist / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x));\n  }\n  float CCGetShadowFactorX1 (vec4 shadowPos) {\n    vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    } else {\n      closestDepth = texture2D(cc_shadowMap, clipPos.xy).x;\n    }\n    shadow = step(closestDepth, clipPos.z- cc_shadowWHPBInfo.w);\n    return shadow;\n  }\n  float CCGetShadowFactorX5 (vec4 shadowPos) {\n    vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n    float offsety = 1.0 / cc_shadowWHPBInfo.y;\n    float shadow = 0.0;\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      float closestDepth = dot(texture2D(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n      closestDepth = dot(texture2D(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n      closestDepth = dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n      closestDepth = dot(texture2D(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n      closestDepth = dot(texture2D(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n    } else {\n      float closestDepth = texture2D(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)).x;\n      shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n      closestDepth = texture2D(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)).x;\n      shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n      closestDepth = texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x;\n      shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n      closestDepth = texture2D(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)).x;\n      shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n      closestDepth = texture2D(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)).x;\n      shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n    }\n    return shadow / 5.0;\n  }\n  float CCGetShadowFactorX9 (vec4 shadowPos) {\n    vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n    float offsety = 1.0 / cc_shadowWHPBInfo.y;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      for (int i = -1; i <= 1; i++) {\n          for (int j = -1; j <= 1; j++) {\n            float closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n            shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          }\n      }\n    } else {\n      for (int i = -1; i <= 1; i++) {\n          for (int j = -1; j <= 1; j++) {\n            float closestDepth = texture2D(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\n            shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          }\n      }\n    }\n    return shadow / 9.0;\n  }\n  float CCGetShadowFactorX25 (vec4 shadowPos) {\n    vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n    float offsety = 1.0 / cc_shadowWHPBInfo.y;\n    float shadow = 0.0;\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      for (int i = -2; i <= 2; i++) {\n        for (int j = -2; j <= 2; j++) {\n          float closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n        }\n      }\n    } else {\n      for (int i = -2; i <= 2; i++) {\n        for (int j = -2; j <= 2; j++) {\n          float closestDepth = texture2D(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n        }\n      }\n    }\n    return shadow / 25.0;\n  }\n  float CCGetDirLightShadowFactorX1 (vec4 shadowPos, vec3 worldPos) {\n    vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    float depth = 0.0;\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      closestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    } else {\n      closestDepth = texture2D(cc_spotLightingMap, clipPos.xy).x;\n    }\n    shadow = step(closestDepth, depth - cc_shadowWHPBInfo.w);\n    return shadow;\n  }\n  float CCGetDirLightShadowFactorX5 (vec4 shadowPos, vec3 worldPos) {\n    vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n    float offsety = 1.0 / cc_shadowWHPBInfo.y;\n    float shadow = 0.0;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      float closestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n      closestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n      closestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n      closestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n      closestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n    } else {\n      float closestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)).x;\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n      closestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)).x;\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n      closestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x;\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n      closestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)).x;\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n      closestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)).x;\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n    }\n    return shadow / 5.0;\n  }\n  float CCGetDirLightShadowFactorX9 (vec4 shadowPos, vec3 worldPos) {\n    vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n    float offsety = 1.0 / cc_shadowWHPBInfo.y;\n    float shadow = 0.0;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      for (int i = -1; i <= 1; i++) {\n        for (int j = -1; j <= 1; j++) {\n          float closestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n        }\n      }\n    } else {\n      for (int i = -1; i <= 1; i++) {\n        for (int j = -1; j <= 1; j++) {\n          float closestDepth = texture2D(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\n          shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n        }\n      }\n    }\n    return shadow / 9.0;\n  }\n  float CCGetDirLightShadowFactorX25 (vec4 shadowPos, vec3 worldPos) {\n    vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n    float offsety = 1.0 / cc_shadowWHPBInfo.y;\n    float depth = 0.0;\n    float shadow = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      for (int i = -2; i <= 2; i++) {\n        for (int j = -2; j <= 2; j++) {\n          float closestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n        }\n      }\n    } else {\n      for (int i = -2; i <= 2; i++) {\n        for (int j = -2; j <= 2; j++) {\n          float closestDepth = texture2D(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n        }\n      }\n    }\n    return shadow / 25.0;\n  }\n#endif\n#if CC_USE_IBL\n  uniform samplerCube cc_environment;\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n  }\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      #ifdef GL_EXT_shader_texture_lod\n        return texture2DLodEXT(tex, coord, lod);\n      #else\n        return texture2D(tex, coord, lod);\n      #endif\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      #ifdef GL_EXT_shader_texture_lod\n        return textureCubeLodEXT(tex, coord, lod);\n      #else\n        return textureCube(tex, coord, lod);\n      #endif\n  }\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\nstruct StandardSurface {\n  vec4 albedo;\n  vec3 position;\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - s.position);\n  float NV = max(abs(dot(N, V)), 0.001);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L + V);\n  float NH = max(dot(N, H), 0.0);\n  float NL = max(dot(N, L), 0.001);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n  vec3 diffuseContrib = diffuse;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    if (s.lightmap_test > 0.0001) {\n      finalColor = s.lightmap.rgb;\n    }\n  #else\n    diffuseContrib /= 3.14159265359;\n  #endif\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  finalColor *= (diffuseContrib + specularContrib);\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n  finalColor += (ambDiff.rgb * diffuse);\n  #if CC_USE_IBL\n    vec3 R = normalize(reflect(-V, N));\n    vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n    #if CC_USE_IBL == 2\n      vec3 env = unpackRGBE(envmap);\n    #else\n      vec3 env = SRGBToLinear(envmap.rgb);\n    #endif\n    finalColor += env * cc_ambientSky.w * specular;\n  #endif\n  finalColor = finalColor * s.occlusion;\n  #if CC_USE_HDR\n    s.emissive *= cc_exposure.w;\n  #endif\n  finalColor += s.emissive;\n  #if CC_RECEIVE_SHADOW\n    {\n      float pcf = cc_shadowWHPBInfo.z + 0.001;\n      float shadowAttenuation = 0.0;\n      float cosAngle = clamp(1.0 - dot(N, L.xyz), 0.0, 1.0);\n      vec3 projWorldPos = shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\n      vec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\n      if (pcf > 3.0) shadowAttenuation = CCGetShadowFactorX25(pos);\n      else if (pcf > 2.0) shadowAttenuation = CCGetShadowFactorX9(pos);\n      else if (pcf > 1.0) shadowAttenuation = CCGetShadowFactorX5(pos);\n      else shadowAttenuation = CCGetShadowFactorX1(pos);\n      vec3 shadowColor = cc_shadowColor.rgb * cc_shadowColor.a + finalColor.rgb * (1.0 - cc_shadowColor.a);\n      if (cc_shadowNFLSInfo.w > 0.000001) {\n        finalColor.rgb = shadowColor.rgb * shadowAttenuation + finalColor.rgb * (1.0 - shadowAttenuation);\n      } else {\n        finalColor.rgb = shadowColor.rgb * shadowAttenuation * NL + finalColor.rgb * (1.0 - shadowAttenuation * NL);\n      }\n    }\n  #endif\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = sqrt(ACESToneMap(color.rgb));\n  #endif\n  return color;\n}\nvarying highp vec4 v_shadowPos;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  varying vec3 v_luv;\n  uniform sampler2D cc_lightingMap;\n  vec3 UnpackLightingmap(vec4 color) {\n    vec3 c;\n    float e = 1.0 + color.a * (8.0 - 1.0);\n    c.r = color.r * e;\n    c.g = color.g * e;\n    c.b = color.b * e;\n    return c;\n  }\n#endif\nvarying vec3 v_position;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec3 v_normal;\n#if USE_VERTEX_COLOR\n  varying vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor *= v_color;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture2D(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec4 lightColor = texture2D(cc_lightingMap, v_luv.xy);\n    s.lightmap = UnpackLightingmap(lightColor);\n    s.lightmap_test = v_luv.z;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * pbrParams.w) * normalize(v_tangent) +\n      (nmmp.y * pbrParams.w) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  s.position = v_position;\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture2D(pbrMap, PBR_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture2D(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture2D(occlusionMap, PBR_UV).r;\n  #endif\n  s.occlusion = clamp(pbr.x, 0.0, 0.96);\n  s.roughness = clamp(pbr.y, 0.04, 1.0);\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture2D(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n  # define LIGHTS_PER_PASS 1\n  #else\n  # define LIGHTS_PER_PASS 10\n  #endif\n  uniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightColor[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - s.position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      #if CC_RECEIVE_SHADOW\n        if (cc_lightPos[i].w > 0.0) {\n          {\n            float pcf = cc_shadowWHPBInfo.z + 0.001;\n            float shadowAttenuation = 0.0;\n            float cosAngle = clamp(1.0 - dot(N, normalize(cc_lightPos[i].xyz - s.position.xyz)), 0.0, 1.0);\n            vec3 projWorldPos = shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\n            vec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\n            if (pcf > 3.0) shadowAttenuation = CCGetDirLightShadowFactorX25(pos, s.position);\n            else if (pcf > 2.0) shadowAttenuation = CCGetDirLightShadowFactorX9(pos, s.position);\n            else if (pcf > 1.0) shadowAttenuation = CCGetDirLightShadowFactorX5(pos, s.position);\n            else shadowAttenuation = CCGetDirLightShadowFactorX1(pos, s.position);\n            lightColor *= 1.0 - shadowAttenuation;\n          }\n        }\n      #endif\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    finalColor = finalColor * s.occlusion;\n    return vec4(finalColor, 0.0);\n  }\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    color = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\n    gl_FragData[0] = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 0\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    color = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\n    gl_FragData[0] = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  void main () {\n    StandardSurface s; surf(s);\n    gl_FragData[0] = s.albedo;\n    gl_FragData[1] = vec4(s.position, s.roughness);\n    gl_FragData[2] = vec4(s.normal, s.metallic);\n    gl_FragData[3] = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotLightingMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_environment","defines":["CC_USE_IBL"]}]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_lightingMap","defines":["USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD"]}]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":216,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":59}},"defines":[{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["CC_USE_SKINNING"]},{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"USE_LIGHTMAP","type":"boolean","defines":[]},{"name":"CC_USE_FOG","type":"number","defines":[],"range":[0,4]},{"name":"CC_FORWARD_ADD","type":"boolean","defines":[]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":[]},{"name":"USE_VERTEX_COLOR","type":"boolean","defines":[]},{"name":"USE_NORMAL_MAP","type":"boolean","defines":[]},{"name":"HAS_SECOND_UV","type":"boolean","defines":[]},{"name":"SAMPLE_FROM_RT","type":"boolean","defines":[]},{"name":"CC_USE_IBL","type":"number","defines":[],"range":[0,2]},{"name":"CC_USE_HDR","type":"boolean","defines":[]},{"name":"USE_ALBEDO_MAP","type":"boolean","defines":[]},{"name":"ALBEDO_UV","type":"string","defines":["USE_ALBEDO_MAP"],"options":["v_uv","v_uv1"]},{"name":"NORMAL_UV","type":"string","defines":["USE_NORMAL_MAP"],"options":["v_uv","v_uv1"]},{"name":"PBR_UV","type":"string","defines":[],"options":["v_uv","v_uv1"]},{"name":"USE_PBR_MAP","type":"boolean","defines":[]},{"name":"USE_METALLIC_ROUGHNESS_MAP","type":"boolean","defines":[]},{"name":"USE_OCCLUSION_MAP","type":"boolean","defines":[]},{"name":"USE_EMISSIVE_MAP","type":"boolean","defines":[]},{"name":"EMISSIVE_UV","type":"string","defines":["USE_EMISSIVE_MAP"],"options":["v_uv","v_uv1"]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"ALPHA_TEST_CHANNEL","type":"string","defines":["USE_ALPHA_TEST"],"options":["a","r"]},{"name":"CC_PIPELINE_TYPE","type":"number","defines":["CC_FORWARD_ADD"],"range":[0,1]}],"blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"pbrParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleParam","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_NORMAL_MAP"]},{"name":"pbrMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_PBR_MAP"]},{"name":"metallicRoughnessMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_METALLIC_ROUGHNESS_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_OCCLUSION_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_EMISSIVE_MAP"]}],"attributes":[{"name":"a_position","type":15,"count":1,"stageFlags":1,"format":32,"location":0,"defines":[]},{"name":"a_normal","type":15,"count":1,"stageFlags":1,"format":32,"location":1,"defines":[]},{"name":"a_texCoord","type":14,"count":1,"stageFlags":1,"format":21,"location":2,"defines":[]},{"name":"a_tangent","type":16,"count":1,"stageFlags":1,"format":44,"location":3,"defines":[]},{"name":"a_vertexId","type":13,"count":1,"stageFlags":1,"format":11,"location":6,"defines":["CC_USE_MORPH"]},{"name":"a_joints","type":"u32vec4","count":1,"stageFlags":1,"location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","type":16,"count":1,"stageFlags":1,"format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":7,"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION","USE_INSTANCING"]},{"name":"a_matWorld0","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","USE_LIGHTMAP"]},{"name":"a_dyn_batch_id","type":13,"count":1,"stageFlags":1,"format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_color","type":16,"count":1,"stageFlags":1,"format":44,"location":13,"defines":["USE_VERTEX_COLOR"]},{"name":"a_texCoord1","type":14,"count":1,"stageFlags":1,"format":21,"location":14,"defines":[]}],"varyings":[{"name":"v_fog_factor","type":13,"count":1,"stageFlags":1,"location":0,"defines":[]},{"name":"v_shadowPos","type":16,"count":1,"stageFlags":1,"location":1,"defines":[]},{"name":"v_color","type":16,"count":1,"stageFlags":1,"location":2,"defines":["USE_VERTEX_COLOR"]},{"name":"v_position","type":15,"count":1,"stageFlags":1,"location":3,"defines":[]},{"name":"v_normal","type":15,"count":1,"stageFlags":1,"location":4,"defines":[]},{"name":"v_uv","type":14,"count":1,"stageFlags":1,"location":5,"defines":[]},{"name":"v_uv1","type":14,"count":1,"stageFlags":1,"location":6,"defines":[]},{"name":"v_tangent","type":15,"count":1,"stageFlags":1,"location":7,"defines":["USE_NORMAL_MAP"]},{"name":"v_bitangent","type":15,"count":1,"stageFlags":1,"location":8,"defines":["USE_NORMAL_MAP"]},{"name":"v_luv","type":15,"count":1,"stageFlags":1,"location":9,"defines":["USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD"]}]},{"hash":826679743,"name":"builtin-standard|shadow-caster-vs:vert|shadow-caster-fs:frag","glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 6) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 7) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 8) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      layout(location = 7) in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 5) uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if USE_INSTANCING\n  layout(location = 8) in vec4 a_matWorld0;\n  layout(location = 9) in vec4 a_matWorld1;\n  layout(location = 10) in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    layout(location = 11) in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n  layout(set = 2, binding = 0) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(set = 2, binding = 0) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  layout(location = 13) in vec2 a_texCoord1;\n#endif\nlayout(location = 0) out vec2 v_uv;\nlayout(location = 1) out vec2 v_uv1;\nlayout(location = 2) out vec4 v_worldPos;\nlayout(location = 3) out float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\n  ret = fract(ret);\n  ret -= ret.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n  return ret;\n}\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\nlayout(location = 0) in vec2 v_uv;\nlayout(location = 1) in vec2 v_uv1;\nlayout(location = 2) in vec4 v_worldPos;\nlayout(location = 3) in float v_clip_depth;\n#if USE_ALBEDO_MAP\n  layout(set = 1, binding = 1) uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      vec4 viewStartPos = cc_matLightView * v_worldPos;\n      float dist = length(viewStartPos.xyz);\n      float linearDepth = cc_shadowNFLSInfo.x + (-dist / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x));\n      return vec4(linearDepth, 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if USE_INSTANCING\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n  layout(std140) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\nout vec2 v_uv;\nout vec2 v_uv1;\nout vec4 v_worldPos;\nout float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\n  ret = fract(ret);\n  ret -= ret.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n  return ret;\n}\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\nin vec2 v_uv;\nin vec2 v_uv1;\nin vec4 v_worldPos;\nin float v_clip_depth;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      vec4 viewStartPos = cc_matLightView * v_worldPos;\n      float dist = length(viewStartPos.xyz);\n      float linearDepth = cc_shadowNFLSInfo.x + (-dist / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x));\n      return vec4(linearDepth, 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      attribute highp vec4 a_jointAnimInfo;\n    #endif\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if USE_INSTANCING\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n  uniform highp mat4 cc_matWorlds[10];\n#else\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n#endif\n      uniform vec4 tilingOffset;\nuniform highp mat4 cc_matLightViewProj;\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\n   uniform vec4 albedo;\n   uniform vec4 albedoScaleAndCutoff;\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\n  ret = fract(ret);\n  ret -= ret.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n  return ret;\n}\nuniform highp mat4 cc_matLightView;\n  uniform lowp vec4 cc_shadowNFLSInfo;\n  uniform lowp vec4 cc_shadowLPNNInfo;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture2D(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      vec4 viewStartPos = cc_matLightView * v_worldPos;\n      float dist = length(viewStartPos.xyz);\n      float linearDepth = cc_shadowNFLSInfo.x + (-dist / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x));\n      return vec4(linearDepth, 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCShadow","defines":[]}],"samplerTextures":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":179,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":22}},"defines":[{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["CC_USE_SKINNING"]},{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"USE_LIGHTMAP","type":"boolean","defines":["USE_INSTANCING"]},{"name":"HAS_SECOND_UV","type":"boolean","defines":[]},{"name":"USE_ALBEDO_MAP","type":"boolean","defines":[]},{"name":"ALBEDO_UV","type":"string","defines":["USE_ALBEDO_MAP"],"options":["v_uv","v_uv1"]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"ALPHA_TEST_CHANNEL","type":"string","defines":["USE_ALPHA_TEST"],"options":["a","r"]}],"blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"pbrParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleParam","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]}],"attributes":[{"name":"a_position","type":15,"count":1,"stageFlags":1,"format":32,"location":0,"defines":[]},{"name":"a_normal","type":15,"count":1,"stageFlags":1,"format":32,"location":1,"defines":[]},{"name":"a_texCoord","type":14,"count":1,"stageFlags":1,"format":21,"location":2,"defines":[]},{"name":"a_tangent","type":16,"count":1,"stageFlags":1,"format":44,"location":3,"defines":[]},{"name":"a_vertexId","type":13,"count":1,"stageFlags":1,"format":11,"location":6,"defines":["CC_USE_MORPH"]},{"name":"a_joints","type":"u32vec4","count":1,"stageFlags":1,"location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","type":16,"count":1,"stageFlags":1,"format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":7,"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION","USE_INSTANCING"]},{"name":"a_matWorld0","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","USE_LIGHTMAP"]},{"name":"a_dyn_batch_id","type":13,"count":1,"stageFlags":1,"format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_texCoord1","type":14,"count":1,"stageFlags":1,"format":21,"location":13,"defines":[]}],"varyings":[{"name":"v_uv","type":14,"count":1,"stageFlags":1,"location":0,"defines":[]},{"name":"v_uv1","type":14,"count":1,"stageFlags":1,"location":1,"defines":[]},{"name":"v_worldPos","type":16,"count":1,"stageFlags":1,"location":2,"defines":[]},{"name":"v_clip_depth","type":13,"count":1,"stageFlags":1,"location":3,"defines":[]}]}],[{"name":"opaque","passes":[{"program":"builtin-standard|standard-vs|standard-fs","properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",2,13]},"normalStrenth":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",3,13]},"emissive":{"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"metallicRoughnessMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"pbrParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.8,0.6,1]},"emissiveScaleParam":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}},"migrations":{"properties":{"pbrParams":{"removeImmediately":true}}}},{"phase":"deferred","propertyIndex":0,"program":"builtin-standard|standard-vs|standard-fs","blendState":{"targets":[{"blend":false},{"blend":false},{"blend":false},{"blend":false}]},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",2,13]},"normalStrenth":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",3,13]},"emissive":{"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"metallicRoughnessMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"pbrParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.8,0.6,1]},"emissiveScaleParam":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}},{"phase":"forward-add","propertyIndex":0,"program":"builtin-standard|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",2,13]},"normalStrenth":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",3,13]},"emissive":{"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"metallicRoughnessMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"pbrParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.8,0.6,1]},"emissiveScaleParam":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}},{"phase":"shadow-caster","propertyIndex":0,"program":"builtin-standard|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"handleInfo":["pbrParams",2,13]},"normalStrenth":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP"},"handleInfo":["pbrParams",3,13]},"emissive":{"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"pbrParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.8,0.6,1]},"emissiveScaleParam":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}}]},{"name":"transparent","passes":[{"program":"builtin-standard|standard-vs|standard-fs","blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",2,13]},"normalStrenth":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",3,13]},"emissive":{"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"metallicRoughnessMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"pbrParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.8,0.6,1]},"emissiveScaleParam":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}},{"phase":"forward-add","propertyIndex":0,"program":"builtin-standard|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",2,13]},"normalStrenth":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",3,13]},"emissive":{"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"metallicRoughnessMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"pbrParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.8,0.6,1]},"emissiveScaleParam":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}},{"phase":"shadow-caster","propertyIndex":0,"program":"builtin-standard|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"handleInfo":["pbrParams",2,13]},"normalStrenth":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP"},"handleInfo":["pbrParams",3,13]},"emissive":{"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"pbrParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.8,0.6,1]},"emissiveScaleParam":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}}]}]]],0,0,[],[],[]],[[[20,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{}],[{"USE_POSITION_SCALING":true},{"USE_BASE_COLOR_MAP":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{},{}],[[{},[{"baseStep":0.9,"baseFeather":0.3,"shadeStep":0.6,"shadeFeather":0.2},"tilingOffset",8,[2,2,1,0,0],"mainColor",8,[4,4284769380],"shadeColor1",8,[4,4283453520],"shadeColor2",8,[4,1661602314],"specular",8,[4,1275068415],"emissive",8,[4,0],"mainTexture",6,0],{},{}],0,11,0,0]]],0,0,[0,0],[9,7],[29,2]],[[[20,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"mainColor",8,[4,4278254848]]],11]]],0,0,[0],[7],[13]],[[{"name":"card_lock","rect":{"x":5,"y":2,"width":85,"height":104},"offset":{"x":0.5,"y":1.5},"originalSize":{"width":94,"height":111},"rotated":false,"capInsets":[0,0,0,0],"texture":"271827c9-4604-4170-9926-3035d50b68b4@6c48a","packable":true}],[1],0,[0],[13],[30]],[[[20,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{}],[{"USE_POSITION_SCALING":true},{"USE_BASE_COLOR_MAP":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{},{}],[[{},[{"baseStep":0.9,"baseFeather":0.3,"shadeStep":0.6,"shadeFeather":0.2},"tilingOffset",8,[2,2,1,0,0],"mainColor",8,[4,4284769380],"shadeColor1",8,[4,4283453520],"shadeColor2",8,[4,1661602314],"specular",8,[4,1275068415],"emissive",8,[4,0],"mainTexture",6,0],{},{}],0,11,0,0]]],0,0,[0,0],[9,7],[31,2]],[[[20,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{}],[{"USE_POSITION_SCALING":true},{"USE_BASE_COLOR_MAP":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{},{}],[[{},[{"baseStep":0.9,"baseFeather":0.3,"shadeStep":0.6,"shadeFeather":0.2},"tilingOffset",8,[2,2,1,0,0],"mainColor",8,[4,4284769380],"shadeColor1",8,[4,4283453520],"shadeColor2",8,[4,1661602314],"specular",8,[4,1275068415],"emissive",8,[4,0],"mainTexture",6,0],{},{}],0,11,0,0]]],0,0,[0,0],[9,7],[32,2]],[[[20,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{}],[{"USE_POSITION_SCALING":true},{"USE_BASE_COLOR_MAP":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{},{}],[[{},[{"baseStep":0.9,"baseFeather":0.3,"shadeStep":0.6,"shadeFeather":0.2},"tilingOffset",8,[2,2,1,0,0],"mainColor",8,[4,4284769380],"shadeColor1",8,[4,4283453520],"shadeColor2",8,[4,1661602314],"specular",8,[4,1275068415],"emissive",8,[4,0],"mainTexture",6,0],{},{}],0,11,0,0]]],0,0,[0,0],[9,7],[33,2]],[[[45,"Card"],[85,"Card",[-4,-5,-6,-7,-8,-9,-10,-11,-12],[[54,-2,[4,"cc1bMkEH9PJbue0PEG4zEA"]],[62,-3,[4,"5dZVcLb/ZPSaizo68i/Qud"]]],[37,"4bx2KLlcRC1L/+yriAjeZU",-1,17]],[52,"levelText",33554432,1,[[10,-13,[4,"4bf4SjaRxP4KcluNxRvaJw"],[5,22.25,50.4]],[63,"<color=#ffffff>4</color>",-14,[4,"b5LFduq8VJWo/DE4BRFmBn"]],[55,16,-15,[4,"89rmsQdPVIV7wnLx9kzr5y"]]],[37,"8fB2KqVsFA34hfa5YNSBFN",1,4],[1,0,16.647,0]],[39,"bgNormal",33554432,1,[[10,-16,[4,"f7NISe7HdAD68SLfhnddy8"],[5,85,104]],[15,-17,[4,"e71ctEmpxFC4KlSYRZNz/a"],0]],[37,"ae1+2QlBdBv5/UP0Kni8SS",1,1]],[70,"bgLocked",false,33554432,1,[[10,-18,[4,"f7NISe7HdAD68SLfhnddy8"],[5,85,104]],[15,-19,[4,"e71ctEmpxFC4KlSYRZNz/a"],2]],[37,"82Pw5FYKZJIr0nT+7wZDoD",1,3]],[52,"star0",33554432,1,[[10,-20,[4,"f7NISe7HdAD68SLfhnddy8"],[5,19,17]],[15,-21,[4,"e71ctEmpxFC4KlSYRZNz/a"],5]],[37,"48gYUavIlEYJ6hsANdKeLz",1,6],[1,-23.621,-27.746,0]],[52,"star1",33554432,1,[[10,-22,[4,"f7NISe7HdAD68SLfhnddy8"],[5,19,17]],[15,-23,[4,"e71ctEmpxFC4KlSYRZNz/a"],7]],[37,"3fhcJtThdOGYNclAn/Mt3A",1,8],[1,1.28,-27.746,0]],[40,"star2",false,33554432,1,[[10,-24,[4,"f7NISe7HdAD68SLfhnddy8"],[5,19,17]],[15,-25,[4,"e71ctEmpxFC4KlSYRZNz/a"],9]],[37,"dedf+aCxZF77OsFDi/56cm",1,10],[1,25.895,-27.746,0]],[40,"star0Gray",false,33554432,1,[[10,-26,[4,"f7NISe7HdAD68SLfhnddy8"],[5,19,17]],[15,-27,[4,"e71ctEmpxFC4KlSYRZNz/a"],11]],[37,"e7gBmpnClIS6TpcmeFDzo0",1,12],[1,-23.621,-27.746,0]],[40,"star1Gray",false,33554432,1,[[10,-28,[4,"f7NISe7HdAD68SLfhnddy8"],[5,19,17]],[15,-29,[4,"e71ctEmpxFC4KlSYRZNz/a"],13]],[37,"ceNHw/FUVMUI9bK/S/Qhc+",1,14],[1,1.28,-27.746,0]],[52,"star2Gray",33554432,1,[[10,-30,[4,"f7NISe7HdAD68SLfhnddy8"],[5,19,17]],[15,-31,[4,"e71ctEmpxFC4KlSYRZNz/a"],15]],[37,"17u/aYQXxBtKWzwD0FZw6x",1,16],[1,25.895,-27.746,0]]],0,[0,5,1,0,2,1,0,2,1,0,-1,3,0,-2,4,0,-3,2,0,-4,5,0,-5,6,0,-6,7,0,-7,8,0,-8,9,0,-9,10,0,2,2,0,2,2,0,2,2,0,2,3,0,2,3,0,2,4,0,2,4,0,2,5,0,2,5,0,2,6,0,2,6,0,2,7,0,2,7,0,2,8,0,2,8,0,2,9,0,2,9,0,2,10,0,2,10,0,14,1,31],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[6,4,6,4,4,6,4,6,4,6,4,6,4,6,4,6,4,4],[14,0,15,0,0,8,0,8,0,8,0,9,0,9,0,9,0,0]],[[[68,"1",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{}],[{},{},{}],[[[{},"mainColor",8,[4,2717908991]],{},{}],11,0,0]]],0,0,[0],[7],[10]],[[[20,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{}],[{"USE_POSITION_SCALING":true},{"USE_BASE_COLOR_MAP":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{},{}],[[{},[{"baseStep":0.9,"baseFeather":0.3,"shadeStep":0.6,"shadeFeather":0.2},"tilingOffset",8,[2,2,1,0,0],"mainColor",8,[4,4284769380],"shadeColor1",8,[4,4283453520],"shadeColor2",8,[4,1661602314],"specular",8,[4,1275068415],"emissive",8,[4,0],"mainTexture",6,0],{},{}],0,11,0,0]]],0,0,[0,0],[9,7],[34,2]],[[[20,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{}],[{"USE_POSITION_SCALING":true},{"USE_BASE_COLOR_MAP":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{},{}],[[{},[{"baseStep":0.9,"baseFeather":0.3,"shadeStep":0.6,"shadeFeather":0.2},"tilingOffset",8,[2,2,1,0,0],"mainColor",8,[4,4284769380],"shadeColor1",8,[4,4283453520],"shadeColor2",8,[4,1661602314],"specular",8,[4,1275068415],"emissive",8,[4,0],"mainTexture",6,0],{},{}],0,11,0,0]]],0,0,[0,0],[9,7],[35,2]],[[[69,0.3,0.028,0.028,0.8]],0,0,[],[],[]],[[{"name":"ball","rect":{"x":0,"y":0,"width":302,"height":302},"offset":{"x":-0.5,"y":0.5},"originalSize":{"width":303,"height":303},"rotated":false,"capInsets":[0,0,0,0],"texture":"52071854-006b-477d-90a8-2f3c3a652cab@6c48a","packable":true}],[1],0,[0],[13],[36]],[[{"name":"li-bg","rect":{"x":12,"y":0,"width":36,"height":266},"offset":{"x":0,"y":0},"originalSize":{"width":60,"height":266},"rotated":false,"capInsets":[0,0,0,0],"texture":"53bcd57c-0edd-4f99-9f9f-07aa15aaf4e6@6c48a","packable":true}],[1],0,[0],[13],[37]],[[{"name":"star","rect":{"x":5,"y":6,"width":19,"height":17},"offset":{"x":0.5,"y":-0.5},"originalSize":{"width":28,"height":28},"rotated":false,"capInsets":[0,0,0,0],"texture":"587766b6-3ae0-4c7c-9404-3f289d2d4caf@6c48a","packable":true}],[1],0,[0],[13],[38]],[[{"name":"li","rect":{"x":0,"y":0,"width":18,"height":251},"offset":{"x":0,"y":0},"originalSize":{"width":18,"height":251},"rotated":false,"capInsets":[0,0,0,0],"texture":"58b14e92-3847-411c-999d-ae76834e309f@6c48a","packable":true}],[1],0,[0],[13],[39]],[[{"base":"2,2,0,0,2,1","mipmaps":[{"front":"5af201b5-5951-4e2c-a81f-ac4aad9132cb@b47c0@e9a6d","back":"5af201b5-5951-4e2c-a81f-ac4aad9132cb@b47c0@40c10","left":"5af201b5-5951-4e2c-a81f-ac4aad9132cb@b47c0@8fd34","right":"5af201b5-5951-4e2c-a81f-ac4aad9132cb@b47c0@74afd","top":"5af201b5-5951-4e2c-a81f-ac4aad9132cb@b47c0@bb97f","bottom":"5af201b5-5951-4e2c-a81f-ac4aad9132cb@b47c0@7d38f"}]}],[21],0,[],[],[]],[[{"fmt":"0","w":0,"h":0}],[2],0,[],[],[]],[[{"fmt":"0","w":0,"h":0}],[2],0,[],[],[]],[[{"fmt":"0","w":0,"h":0}],[2],0,[],[],[]],[[{"fmt":"0","w":0,"h":0}],[2],0,[],[],[]],[[{"fmt":"0","w":0,"h":0}],[2],0,[],[],[]],[[{"fmt":"0","w":0,"h":0}],[2],0,[],[],[]],[[[45,"MenuLayer"],[71,"MenuLayer",false,33554432,[-7,-8],[[10,-2,[4,"38r07ixIBOeqpz/gGp71BO"],[5,960,640]],[46,45,100,100,-3,[4,"eaClsRUv5MT44W6gaks0M0"]],[77,-4,[4,"d4Xn5MXadK6YdTLRq0bZT1"]],[105,-6,[4,"b06T1tCMxM/KtL8Bta7456"],[[null,null,null,null,null,null,null,null,-5,null,null,null,null,null,null,null],0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0]]],[5,"71g0nLrLpMhJ0RxJkOaKCl",-1,0]],[72,"Layout",33554432,1,[-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26],[[10,-9,[4,"71F9vsVsZH7ZFd+PpN0azA"],[5,460,520]],[106,1,3,20,40,-10,[4,"eaGEkmlCpANK+GS6CImtZa"]]],[5,"aecaqqOqhI/IkomkOo9bkU",1,0]],[96,"Card",33554432,2,[-48,-49,-50,-51,-52,-53,-54,-55,-56],[[[54,-45,[4,"cc1bMkEH9PJbue0PEG4zEA"]],-46,-47],4,1,1],[101,null,"4bx2KLlcRC1L/+yriAjeZU",[12,"40WUa1qRRCMKiC1F7Fi23q",1,[[111,[0,["4bx2KLlcRC1L/+yriAjeZU"]],[-44]]],[[8,"Card",["_name"],-27],[13,["_lpos"],-28,[1,-180,-70,0]],[13,["_lrot"],-29,[3,0,0,0,1]],[8,null,["_prefab","root"],-30],[2,null,["_prefab","root"],[0,["8fB2KqVsFA34hfa5YNSBFN"]]],[8,true,["_locked"],-31],[8,9,["_level"],-32],[8,33554432,["_layer"],-33],[8,false,["_active"],-34],[8,null,["_prefab","root"],-35],[8,true,["_active"],-36],[8,null,["_prefab","root"],-37],[8,false,["_active"],-38],[8,null,["_prefab","root"],-39],[8,false,["_active"],-40],[8,null,["_prefab","root"],-41],[2,null,["_prefab","root"],[0,["dedf+aCxZF77OsFDi/56cm"]]],[2,null,["_prefab","root"],[0,["e7gBmpnClIS6TpcmeFDzo0"]]],[2,null,["_prefab","root"],[0,["ceNHw/FUVMUI9bK/S/Qhc+"]]],[8,false,["_active"],-42],[8,null,["_prefab","root"],-43]]],17],[1,-180,-70,0]],[21,2,[11,"4bx2KLlcRC1L/+yriAjeZU",-67,[12,"3c4Emiz61Nm6ODbDxrzmkA",1,[[14,[null],[0,["4bx2KLlcRC1L/+yriAjeZU"]]]],[[2,"Card0",["_name"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[6,["_lpos"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[1,-180,210,0]],[6,["_lrot"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[3,0,0,0,1]],[1,["_prefab","root"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],-57],[1,["_prefab","root"],[0,["8fB2KqVsFA34hfa5YNSBFN"]],-58],[2,33554432,["_layer"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[1,["_prefab","root"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]],-59],[1,["_prefab","root"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]],-60],[1,["_prefab","root"],[0,["48gYUavIlEYJ6hsANdKeLz"]],-61],[2,false,["_active"],[0,["3fhcJtThdOGYNclAn/Mt3A"]]],[1,["_prefab","root"],[0,["3fhcJtThdOGYNclAn/Mt3A"]],-62],[1,["_prefab","root"],[0,["dedf+aCxZF77OsFDi/56cm"]],-63],[1,["_prefab","root"],[0,["e7gBmpnClIS6TpcmeFDzo0"]],-64],[2,true,["_active"],[0,["ceNHw/FUVMUI9bK/S/Qhc+"]]],[1,["_prefab","root"],[0,["ceNHw/FUVMUI9bK/S/Qhc+"]],-65],[1,["_prefab","root"],[0,["17u/aYQXxBtKWzwD0FZw6x"]],-66]]],1]],[21,2,[11,"4bx2KLlcRC1L/+yriAjeZU",-78,[12,"d6xjbtOXxA5alX9x9d9eex",1,[[14,[null],[0,["4bx2KLlcRC1L/+yriAjeZU"]]]],[[2,"Card1",["_name"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[6,["_lpos"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[1,-60,210,0]],[6,["_lrot"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[3,0,0,0,1]],[1,["_prefab","root"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],-68],[1,["_prefab","root"],[0,["8fB2KqVsFA34hfa5YNSBFN"]],-69],[2,false,["_locked"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,2,["_level"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,3,["_star"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,33554432,["_layer"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[1,["_prefab","root"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]],-70],[1,["_prefab","root"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]],-71],[1,["_prefab","root"],[0,["48gYUavIlEYJ6hsANdKeLz"]],-72],[1,["_prefab","root"],[0,["3fhcJtThdOGYNclAn/Mt3A"]],-73],[2,true,["_active"],[0,["dedf+aCxZF77OsFDi/56cm"]]],[1,["_prefab","root"],[0,["dedf+aCxZF77OsFDi/56cm"]],-74],[1,["_prefab","root"],[0,["e7gBmpnClIS6TpcmeFDzo0"]],-75],[1,["_prefab","root"],[0,["ceNHw/FUVMUI9bK/S/Qhc+"]],-76],[2,false,["_active"],[0,["17u/aYQXxBtKWzwD0FZw6x"]]],[1,["_prefab","root"],[0,["17u/aYQXxBtKWzwD0FZw6x"]],-77]]],2]],[21,2,[11,"4bx2KLlcRC1L/+yriAjeZU",-89,[12,"44c9aM4kdGapJ4wnNw0Ivr",1,[[14,[null],[0,["4bx2KLlcRC1L/+yriAjeZU"]]]],[[2,"Card2",["_name"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[6,["_lpos"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[1,60,210,0]],[6,["_lrot"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[3,0,0,0,1]],[1,["_prefab","root"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],-79],[1,["_prefab","root"],[0,["8fB2KqVsFA34hfa5YNSBFN"]],-80],[2,false,["_locked"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,3,["_level"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,2,["_star"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,33554432,["_layer"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[1,["_prefab","root"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]],-81],[1,["_prefab","root"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]],-82],[1,["_prefab","root"],[0,["48gYUavIlEYJ6hsANdKeLz"]],-83],[1,["_prefab","root"],[0,["3fhcJtThdOGYNclAn/Mt3A"]],-84],[1,["_prefab","root"],[0,["dedf+aCxZF77OsFDi/56cm"]],-85],[1,["_prefab","root"],[0,["e7gBmpnClIS6TpcmeFDzo0"]],-86],[1,["_prefab","root"],[0,["ceNHw/FUVMUI9bK/S/Qhc+"]],-87],[1,["_prefab","root"],[0,["17u/aYQXxBtKWzwD0FZw6x"]],-88]]],3]],[21,2,[11,"4bx2KLlcRC1L/+yriAjeZU",-100,[12,"f6FsL6VTNHlYvuRvWEg/JT",1,[[14,[null],[0,["4bx2KLlcRC1L/+yriAjeZU"]]]],[[2,"Card3",["_name"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[6,["_lpos"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[1,180,210,0]],[6,["_lrot"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[3,0,0,0,1]],[1,["_prefab","root"],[0,["8fB2KqVsFA34hfa5YNSBFN"]],-90],[1,["_prefab","root"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],-91],[2,false,["_locked"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,4,["_level"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,2,["_star"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,33554432,["_layer"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[1,["_prefab","root"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]],-92],[1,["_prefab","root"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]],-93],[1,["_prefab","root"],[0,["48gYUavIlEYJ6hsANdKeLz"]],-94],[1,["_prefab","root"],[0,["3fhcJtThdOGYNclAn/Mt3A"]],-95],[1,["_prefab","root"],[0,["dedf+aCxZF77OsFDi/56cm"]],-96],[1,["_prefab","root"],[0,["e7gBmpnClIS6TpcmeFDzo0"]],-97],[1,["_prefab","root"],[0,["ceNHw/FUVMUI9bK/S/Qhc+"]],-98],[1,["_prefab","root"],[0,["17u/aYQXxBtKWzwD0FZw6x"]],-99]]],4]],[21,2,[11,"4bx2KLlcRC1L/+yriAjeZU",-111,[12,"96GtoVFeFJnaBR5asUFypE",1,[[14,[null],[0,["4bx2KLlcRC1L/+yriAjeZU"]]]],[[2,"Card4",["_name"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[6,["_lpos"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[1,-180,70,0]],[6,["_lrot"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[3,0,0,0,1]],[1,["_prefab","root"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],-101],[1,["_prefab","root"],[0,["8fB2KqVsFA34hfa5YNSBFN"]],-102],[2,true,["_locked"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,5,["_level"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,33554432,["_layer"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[2,false,["_active"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]]],[1,["_prefab","root"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]],-103],[2,true,["_active"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]]],[1,["_prefab","root"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]],-104],[2,false,["_active"],[0,["48gYUavIlEYJ6hsANdKeLz"]]],[1,["_prefab","root"],[0,["48gYUavIlEYJ6hsANdKeLz"]],-105],[2,false,["_active"],[0,["3fhcJtThdOGYNclAn/Mt3A"]]],[1,["_prefab","root"],[0,["3fhcJtThdOGYNclAn/Mt3A"]],-106],[1,["_prefab","root"],[0,["dedf+aCxZF77OsFDi/56cm"]],-107],[1,["_prefab","root"],[0,["e7gBmpnClIS6TpcmeFDzo0"]],-108],[1,["_prefab","root"],[0,["ceNHw/FUVMUI9bK/S/Qhc+"]],-109],[2,false,["_active"],[0,["17u/aYQXxBtKWzwD0FZw6x"]]],[1,["_prefab","root"],[0,["17u/aYQXxBtKWzwD0FZw6x"]],-110]]],5]],[21,2,[11,"4bx2KLlcRC1L/+yriAjeZU",-122,[12,"6dwFI5k3dJZ5wystvCT/By",1,[[14,[null],[0,["4bx2KLlcRC1L/+yriAjeZU"]]]],[[2,"Card5",["_name"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[6,["_lpos"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[1,-60,70,0]],[6,["_lrot"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[3,0,0,0,1]],[1,["_prefab","root"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],-112],[1,["_prefab","root"],[0,["8fB2KqVsFA34hfa5YNSBFN"]],-113],[2,true,["_locked"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,6,["_level"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,33554432,["_layer"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[2,false,["_active"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]]],[1,["_prefab","root"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]],-114],[2,true,["_active"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]]],[1,["_prefab","root"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]],-115],[2,false,["_active"],[0,["48gYUavIlEYJ6hsANdKeLz"]]],[1,["_prefab","root"],[0,["48gYUavIlEYJ6hsANdKeLz"]],-116],[2,false,["_active"],[0,["3fhcJtThdOGYNclAn/Mt3A"]]],[1,["_prefab","root"],[0,["3fhcJtThdOGYNclAn/Mt3A"]],-117],[1,["_prefab","root"],[0,["dedf+aCxZF77OsFDi/56cm"]],-118],[1,["_prefab","root"],[0,["e7gBmpnClIS6TpcmeFDzo0"]],-119],[1,["_prefab","root"],[0,["ceNHw/FUVMUI9bK/S/Qhc+"]],-120],[2,false,["_active"],[0,["17u/aYQXxBtKWzwD0FZw6x"]]],[1,["_prefab","root"],[0,["17u/aYQXxBtKWzwD0FZw6x"]],-121]]],6]],[21,2,[11,"4bx2KLlcRC1L/+yriAjeZU",-133,[12,"a1FKfeDZJB9IaxO5IWrqsS",1,[[14,[null],[0,["4bx2KLlcRC1L/+yriAjeZU"]]]],[[2,"Card6",["_name"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[6,["_lpos"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[1,60,70,0]],[6,["_lrot"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[3,0,0,0,1]],[1,["_prefab","root"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],-123],[1,["_prefab","root"],[0,["8fB2KqVsFA34hfa5YNSBFN"]],-124],[2,true,["_locked"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,7,["_level"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,33554432,["_layer"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[2,false,["_active"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]]],[1,["_prefab","root"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]],-125],[2,true,["_active"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]]],[1,["_prefab","root"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]],-126],[2,false,["_active"],[0,["48gYUavIlEYJ6hsANdKeLz"]]],[1,["_prefab","root"],[0,["48gYUavIlEYJ6hsANdKeLz"]],-127],[2,false,["_active"],[0,["3fhcJtThdOGYNclAn/Mt3A"]]],[1,["_prefab","root"],[0,["3fhcJtThdOGYNclAn/Mt3A"]],-128],[1,["_prefab","root"],[0,["dedf+aCxZF77OsFDi/56cm"]],-129],[1,["_prefab","root"],[0,["e7gBmpnClIS6TpcmeFDzo0"]],-130],[1,["_prefab","root"],[0,["ceNHw/FUVMUI9bK/S/Qhc+"]],-131],[2,false,["_active"],[0,["17u/aYQXxBtKWzwD0FZw6x"]]],[1,["_prefab","root"],[0,["17u/aYQXxBtKWzwD0FZw6x"]],-132]]],7]],[21,2,[11,"4bx2KLlcRC1L/+yriAjeZU",-144,[12,"dcfXL6Nr1MQoHSe1cXBV0G",1,[[14,[null],[0,["4bx2KLlcRC1L/+yriAjeZU"]]]],[[2,"Card7",["_name"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[6,["_lpos"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[1,180,70,0]],[6,["_lrot"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[3,0,0,0,1]],[1,["_prefab","root"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],-134],[1,["_prefab","root"],[0,["8fB2KqVsFA34hfa5YNSBFN"]],-135],[2,true,["_locked"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,8,["_level"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,33554432,["_layer"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[2,false,["_active"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]]],[1,["_prefab","root"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]],-136],[2,true,["_active"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]]],[1,["_prefab","root"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]],-137],[2,false,["_active"],[0,["48gYUavIlEYJ6hsANdKeLz"]]],[1,["_prefab","root"],[0,["48gYUavIlEYJ6hsANdKeLz"]],-138],[2,false,["_active"],[0,["3fhcJtThdOGYNclAn/Mt3A"]]],[1,["_prefab","root"],[0,["3fhcJtThdOGYNclAn/Mt3A"]],-139],[1,["_prefab","root"],[0,["dedf+aCxZF77OsFDi/56cm"]],-140],[1,["_prefab","root"],[0,["e7gBmpnClIS6TpcmeFDzo0"]],-141],[1,["_prefab","root"],[0,["ceNHw/FUVMUI9bK/S/Qhc+"]],-142],[2,false,["_active"],[0,["17u/aYQXxBtKWzwD0FZw6x"]]],[1,["_prefab","root"],[0,["17u/aYQXxBtKWzwD0FZw6x"]],-143]]],8]],[21,2,[11,"4bx2KLlcRC1L/+yriAjeZU",-155,[12,"70aaMr1VdGrL6RduYvbHeY",1,[[14,[null],[0,["4bx2KLlcRC1L/+yriAjeZU"]]]],[[2,"Card9",["_name"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[6,["_lpos"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[1,-60,-70,0]],[6,["_lrot"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[3,0,0,0,1]],[1,["_prefab","root"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],-145],[1,["_prefab","root"],[0,["8fB2KqVsFA34hfa5YNSBFN"]],-146],[2,true,["_locked"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,10,["_level"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,33554432,["_layer"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[2,false,["_active"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]]],[1,["_prefab","root"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]],-147],[2,true,["_active"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]]],[1,["_prefab","root"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]],-148],[2,false,["_active"],[0,["48gYUavIlEYJ6hsANdKeLz"]]],[1,["_prefab","root"],[0,["48gYUavIlEYJ6hsANdKeLz"]],-149],[2,false,["_active"],[0,["3fhcJtThdOGYNclAn/Mt3A"]]],[1,["_prefab","root"],[0,["3fhcJtThdOGYNclAn/Mt3A"]],-150],[1,["_prefab","root"],[0,["dedf+aCxZF77OsFDi/56cm"]],-151],[1,["_prefab","root"],[0,["e7gBmpnClIS6TpcmeFDzo0"]],-152],[1,["_prefab","root"],[0,["ceNHw/FUVMUI9bK/S/Qhc+"]],-153],[2,false,["_active"],[0,["17u/aYQXxBtKWzwD0FZw6x"]]],[1,["_prefab","root"],[0,["17u/aYQXxBtKWzwD0FZw6x"]],-154]]],18]],[21,2,[11,"4bx2KLlcRC1L/+yriAjeZU",-166,[12,"d6wKd9mWpBjYJs1ES2ekhT",1,[[14,[null],[0,["4bx2KLlcRC1L/+yriAjeZU"]]]],[[2,"Card10",["_name"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[6,["_lpos"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[1,60,-70,0]],[6,["_lrot"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[3,0,0,0,1]],[1,["_prefab","root"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],-156],[1,["_prefab","root"],[0,["8fB2KqVsFA34hfa5YNSBFN"]],-157],[2,true,["_locked"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,11,["_level"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,33554432,["_layer"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[2,false,["_active"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]]],[1,["_prefab","root"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]],-158],[2,true,["_active"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]]],[1,["_prefab","root"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]],-159],[2,false,["_active"],[0,["48gYUavIlEYJ6hsANdKeLz"]]],[1,["_prefab","root"],[0,["48gYUavIlEYJ6hsANdKeLz"]],-160],[2,false,["_active"],[0,["3fhcJtThdOGYNclAn/Mt3A"]]],[1,["_prefab","root"],[0,["3fhcJtThdOGYNclAn/Mt3A"]],-161],[1,["_prefab","root"],[0,["dedf+aCxZF77OsFDi/56cm"]],-162],[1,["_prefab","root"],[0,["e7gBmpnClIS6TpcmeFDzo0"]],-163],[1,["_prefab","root"],[0,["ceNHw/FUVMUI9bK/S/Qhc+"]],-164],[2,false,["_active"],[0,["17u/aYQXxBtKWzwD0FZw6x"]]],[1,["_prefab","root"],[0,["17u/aYQXxBtKWzwD0FZw6x"]],-165]]],19]],[21,2,[11,"4bx2KLlcRC1L/+yriAjeZU",-177,[12,"c5EpSL/21HHbfTDe1MxE79",1,[[14,[null],[0,["4bx2KLlcRC1L/+yriAjeZU"]]]],[[2,"Card11",["_name"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[6,["_lpos"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[1,180,-70,0]],[6,["_lrot"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[3,0,0,0,1]],[1,["_prefab","root"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],-167],[1,["_prefab","root"],[0,["8fB2KqVsFA34hfa5YNSBFN"]],-168],[2,true,["_locked"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,12,["_level"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,33554432,["_layer"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[2,false,["_active"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]]],[1,["_prefab","root"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]],-169],[2,true,["_active"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]]],[1,["_prefab","root"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]],-170],[2,false,["_active"],[0,["48gYUavIlEYJ6hsANdKeLz"]]],[1,["_prefab","root"],[0,["48gYUavIlEYJ6hsANdKeLz"]],-171],[2,false,["_active"],[0,["3fhcJtThdOGYNclAn/Mt3A"]]],[1,["_prefab","root"],[0,["3fhcJtThdOGYNclAn/Mt3A"]],-172],[1,["_prefab","root"],[0,["dedf+aCxZF77OsFDi/56cm"]],-173],[1,["_prefab","root"],[0,["e7gBmpnClIS6TpcmeFDzo0"]],-174],[1,["_prefab","root"],[0,["ceNHw/FUVMUI9bK/S/Qhc+"]],-175],[2,false,["_active"],[0,["17u/aYQXxBtKWzwD0FZw6x"]]],[1,["_prefab","root"],[0,["17u/aYQXxBtKWzwD0FZw6x"]],-176]]],20]],[21,2,[11,"4bx2KLlcRC1L/+yriAjeZU",-188,[12,"61TrRFN0dCtbFDajsDiHVw",1,[[14,[null],[0,["4bx2KLlcRC1L/+yriAjeZU"]]]],[[2,"Card12",["_name"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[6,["_lpos"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[1,-180,-210,0]],[6,["_lrot"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[3,0,0,0,1]],[1,["_prefab","root"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],-178],[1,["_prefab","root"],[0,["8fB2KqVsFA34hfa5YNSBFN"]],-179],[2,true,["_locked"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,13,["_level"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,33554432,["_layer"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[2,false,["_active"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]]],[1,["_prefab","root"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]],-180],[2,true,["_active"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]]],[1,["_prefab","root"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]],-181],[2,false,["_active"],[0,["48gYUavIlEYJ6hsANdKeLz"]]],[1,["_prefab","root"],[0,["48gYUavIlEYJ6hsANdKeLz"]],-182],[2,false,["_active"],[0,["3fhcJtThdOGYNclAn/Mt3A"]]],[1,["_prefab","root"],[0,["3fhcJtThdOGYNclAn/Mt3A"]],-183],[1,["_prefab","root"],[0,["dedf+aCxZF77OsFDi/56cm"]],-184],[1,["_prefab","root"],[0,["e7gBmpnClIS6TpcmeFDzo0"]],-185],[1,["_prefab","root"],[0,["ceNHw/FUVMUI9bK/S/Qhc+"]],-186],[2,false,["_active"],[0,["17u/aYQXxBtKWzwD0FZw6x"]]],[1,["_prefab","root"],[0,["17u/aYQXxBtKWzwD0FZw6x"]],-187]]],21]],[21,2,[11,"4bx2KLlcRC1L/+yriAjeZU",-199,[12,"07JLlQNkVAEq0tQxSuPv2z",1,[[14,[null],[0,["4bx2KLlcRC1L/+yriAjeZU"]]]],[[2,"Card13",["_name"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[6,["_lpos"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[1,-60,-210,0]],[6,["_lrot"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[3,0,0,0,1]],[1,["_prefab","root"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],-189],[1,["_prefab","root"],[0,["8fB2KqVsFA34hfa5YNSBFN"]],-190],[2,true,["_locked"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,14,["_level"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,33554432,["_layer"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[2,false,["_active"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]]],[1,["_prefab","root"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]],-191],[2,true,["_active"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]]],[1,["_prefab","root"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]],-192],[2,false,["_active"],[0,["48gYUavIlEYJ6hsANdKeLz"]]],[1,["_prefab","root"],[0,["48gYUavIlEYJ6hsANdKeLz"]],-193],[2,false,["_active"],[0,["3fhcJtThdOGYNclAn/Mt3A"]]],[1,["_prefab","root"],[0,["3fhcJtThdOGYNclAn/Mt3A"]],-194],[1,["_prefab","root"],[0,["dedf+aCxZF77OsFDi/56cm"]],-195],[1,["_prefab","root"],[0,["e7gBmpnClIS6TpcmeFDzo0"]],-196],[1,["_prefab","root"],[0,["ceNHw/FUVMUI9bK/S/Qhc+"]],-197],[2,false,["_active"],[0,["17u/aYQXxBtKWzwD0FZw6x"]]],[1,["_prefab","root"],[0,["17u/aYQXxBtKWzwD0FZw6x"]],-198]]],22]],[21,2,[11,"4bx2KLlcRC1L/+yriAjeZU",-210,[12,"20Gsq33o1PHbeOnfMxLKjI",1,[[14,[null],[0,["4bx2KLlcRC1L/+yriAjeZU"]]]],[[2,"Card14",["_name"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[6,["_lpos"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[1,60,-210,0]],[6,["_lrot"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[3,0,0,0,1]],[1,["_prefab","root"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],-200],[1,["_prefab","root"],[0,["8fB2KqVsFA34hfa5YNSBFN"]],-201],[2,true,["_locked"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,15,["_level"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,33554432,["_layer"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[2,false,["_active"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]]],[1,["_prefab","root"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]],-202],[2,true,["_active"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]]],[1,["_prefab","root"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]],-203],[2,false,["_active"],[0,["48gYUavIlEYJ6hsANdKeLz"]]],[1,["_prefab","root"],[0,["48gYUavIlEYJ6hsANdKeLz"]],-204],[2,false,["_active"],[0,["3fhcJtThdOGYNclAn/Mt3A"]]],[1,["_prefab","root"],[0,["3fhcJtThdOGYNclAn/Mt3A"]],-205],[1,["_prefab","root"],[0,["dedf+aCxZF77OsFDi/56cm"]],-206],[1,["_prefab","root"],[0,["e7gBmpnClIS6TpcmeFDzo0"]],-207],[1,["_prefab","root"],[0,["ceNHw/FUVMUI9bK/S/Qhc+"]],-208],[2,false,["_active"],[0,["17u/aYQXxBtKWzwD0FZw6x"]]],[1,["_prefab","root"],[0,["17u/aYQXxBtKWzwD0FZw6x"]],-209]]],23]],[21,2,[11,"4bx2KLlcRC1L/+yriAjeZU",-221,[12,"e8iejSF2tHxLwaw5WTJ7Mk",1,[[14,[null],[0,["4bx2KLlcRC1L/+yriAjeZU"]]]],[[2,"Card15",["_name"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[6,["_lpos"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[1,180,-210,0]],[6,["_lrot"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[3,0,0,0,1]],[1,["_prefab","root"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],-211],[1,["_prefab","root"],[0,["8fB2KqVsFA34hfa5YNSBFN"]],-212],[2,true,["_locked"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,16,["_level"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,33554432,["_layer"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[2,false,["_active"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]]],[1,["_prefab","root"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]],-213],[2,true,["_active"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]]],[1,["_prefab","root"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]],-214],[2,false,["_active"],[0,["48gYUavIlEYJ6hsANdKeLz"]]],[1,["_prefab","root"],[0,["48gYUavIlEYJ6hsANdKeLz"]],-215],[2,false,["_active"],[0,["3fhcJtThdOGYNclAn/Mt3A"]]],[1,["_prefab","root"],[0,["3fhcJtThdOGYNclAn/Mt3A"]],-216],[1,["_prefab","root"],[0,["dedf+aCxZF77OsFDi/56cm"]],-217],[1,["_prefab","root"],[0,["e7gBmpnClIS6TpcmeFDzo0"]],-218],[1,["_prefab","root"],[0,["ceNHw/FUVMUI9bK/S/Qhc+"]],-219],[2,false,["_active"],[0,["17u/aYQXxBtKWzwD0FZw6x"]]],[1,["_prefab","root"],[0,["17u/aYQXxBtKWzwD0FZw6x"]],-220]]],24]],[39,"bg",33554432,1,[[10,-222,[4,"f7NISe7HdAD68SLfhnddy8"],[5,960,640]],[64,2,0,-223,[4,"e71ctEmpxFC4KlSYRZNz/a"],0],[46,45,1,1,-224,[4,"a7RXAXgHRIJrkrCgbCSu9k"]],[47,-225,[4,"79+F1f+ohJiZvAAZIhqzxK"],[[50]]]],[5,"8fHtItnx1GNLUmShkrYIBX",1,0]],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[52,"levelText",33554432,3,[[10,-226,[4,"4bf4SjaRxP4KcluNxRvaJw"],[5,22.25,50.4]],[63,"<color=#ffffff>4</color>",-227,[4,"b5LFduq8VJWo/DE4BRFmBn"]],[55,16,-228,[4,"89rmsQdPVIV7wnLx9kzr5y"]]],[5,"8fB2KqVsFA34hfa5YNSBFN",1,0],[1,0,16.647,0]],[70,"bgNormal",false,33554432,3,[[10,-229,[4,"f7NISe7HdAD68SLfhnddy8"],[5,85,104]],[15,-230,[4,"e71ctEmpxFC4KlSYRZNz/a"],9]],[5,"ae1+2QlBdBv5/UP0Kni8SS",1,0]],[39,"bgLocked",33554432,3,[[10,-231,[4,"f7NISe7HdAD68SLfhnddy8"],[5,85,104]],[15,-232,[4,"e71ctEmpxFC4KlSYRZNz/a"],10]],[5,"82Pw5FYKZJIr0nT+7wZDoD",1,0]],[40,"star0",false,33554432,3,[[10,-233,[4,"f7NISe7HdAD68SLfhnddy8"],[5,19,17]],[15,-234,[4,"e71ctEmpxFC4KlSYRZNz/a"],11]],[5,"48gYUavIlEYJ6hsANdKeLz",1,0],[1,-23.621,-27.746,0]],[40,"star1",false,33554432,3,[[10,-235,[4,"f7NISe7HdAD68SLfhnddy8"],[5,19,17]],[15,-236,[4,"e71ctEmpxFC4KlSYRZNz/a"],12]],[5,"3fhcJtThdOGYNclAn/Mt3A",1,0],[1,1.28,-27.746,0]],[40,"star2",false,33554432,3,[[10,-237,[4,"f7NISe7HdAD68SLfhnddy8"],[5,19,17]],[15,-238,[4,"e71ctEmpxFC4KlSYRZNz/a"],13]],[5,"dedf+aCxZF77OsFDi/56cm",1,0],[1,25.895,-27.746,0]],[40,"star0Gray",false,33554432,3,[[10,-239,[4,"f7NISe7HdAD68SLfhnddy8"],[5,19,17]],[15,-240,[4,"e71ctEmpxFC4KlSYRZNz/a"],14]],[5,"e7gBmpnClIS6TpcmeFDzo0",1,0],[1,-23.621,-27.746,0]],[40,"star1Gray",false,33554432,3,[[10,-241,[4,"f7NISe7HdAD68SLfhnddy8"],[5,19,17]],[15,-242,[4,"e71ctEmpxFC4KlSYRZNz/a"],15]],[5,"ceNHw/FUVMUI9bK/S/Qhc+",1,0],[1,1.28,-27.746,0]],[40,"star2Gray",false,33554432,3,[[10,-243,[4,"f7NISe7HdAD68SLfhnddy8"],[5,19,17]],[15,-244,[4,"e71ctEmpxFC4KlSYRZNz/a"],16]],[5,"17u/aYQXxBtKWzwD0FZw6x",1,0],[1,25.895,-27.746,0]],[62,3,[4,"5dZVcLb/ZPSaizo68i/Qud"]],[47,3,[4,"f4iTjhJ6VMCJGYt0fpPdw7"],[[50]]],[0,["5dZVcLb/ZPSaizo68i/Qud"]],[0,["ae1+2QlBdBv5/UP0Kni8SS"]],[0,["82Pw5FYKZJIr0nT+7wZDoD"]],[0,["48gYUavIlEYJ6hsANdKeLz"]],[0,["3fhcJtThdOGYNclAn/Mt3A"]],[0,["17u/aYQXxBtKWzwD0FZw6x"]]],0,[0,5,1,0,2,1,0,2,1,0,2,1,0,-9,30,0,2,1,0,-1,19,0,-2,2,0,2,2,0,2,2,0,-1,4,0,-2,5,0,-3,6,0,-4,7,0,-5,8,0,-6,9,0,-7,10,0,-8,11,0,-9,3,0,-10,12,0,-11,13,0,-12,14,0,-13,15,0,-14,16,0,-15,17,0,-16,18,0,1,20,0,1,20,0,1,20,0,1,20,0,1,32,0,1,32,0,1,20,0,1,33,0,1,33,0,1,34,0,1,34,0,1,35,0,1,35,0,1,36,0,1,36,0,1,37,0,1,37,0,-1,31,0,2,3,0,-2,30,0,-3,31,0,-1,22,0,-2,23,0,-3,21,0,-4,24,0,-5,25,0,-6,26,0,-7,27,0,-8,28,0,-9,29,0,0,4,0,0,4,0,0,4,0,0,4,0,0,4,0,0,4,0,0,4,0,0,4,0,0,4,0,0,4,0,5,4,0,0,5,0,0,5,0,0,5,0,0,5,0,0,5,0,0,5,0,0,5,0,0,5,0,0,5,0,0,5,0,5,5,0,0,6,0,0,6,0,0,6,0,0,6,0,0,6,0,0,6,0,0,6,0,0,6,0,0,6,0,0,6,0,5,6,0,0,7,0,0,7,0,0,7,0,0,7,0,0,7,0,0,7,0,0,7,0,0,7,0,0,7,0,0,7,0,5,7,0,0,8,0,0,8,0,0,8,0,0,8,0,0,8,0,0,8,0,0,8,0,0,8,0,0,8,0,0,8,0,5,8,0,0,9,0,0,9,0,0,9,0,0,9,0,0,9,0,0,9,0,0,9,0,0,9,0,0,9,0,0,9,0,5,9,0,0,10,0,0,10,0,0,10,0,0,10,0,0,10,0,0,10,0,0,10,0,0,10,0,0,10,0,0,10,0,5,10,0,0,11,0,0,11,0,0,11,0,0,11,0,0,11,0,0,11,0,0,11,0,0,11,0,0,11,0,0,11,0,5,11,0,0,12,0,0,12,0,0,12,0,0,12,0,0,12,0,0,12,0,0,12,0,0,12,0,0,12,0,0,12,0,5,12,0,0,13,0,0,13,0,0,13,0,0,13,0,0,13,0,0,13,0,0,13,0,0,13,0,0,13,0,0,13,0,5,13,0,0,14,0,0,14,0,0,14,0,0,14,0,0,14,0,0,14,0,0,14,0,0,14,0,0,14,0,0,14,0,5,14,0,0,15,0,0,15,0,0,15,0,0,15,0,0,15,0,0,15,0,0,15,0,0,15,0,0,15,0,0,15,0,5,15,0,0,16,0,0,16,0,0,16,0,0,16,0,0,16,0,0,16,0,0,16,0,0,16,0,0,16,0,0,16,0,5,16,0,0,17,0,0,17,0,0,17,0,0,17,0,0,17,0,0,17,0,0,17,0,0,17,0,0,17,0,0,17,0,5,17,0,0,18,0,0,18,0,0,18,0,0,18,0,0,18,0,0,18,0,0,18,0,0,18,0,0,18,0,0,18,0,5,18,0,2,19,0,2,19,0,2,19,0,2,19,0,2,21,0,2,21,0,2,21,0,2,22,0,2,22,0,2,23,0,2,23,0,2,24,0,2,24,0,2,25,0,2,25,0,2,26,0,2,26,0,2,27,0,2,27,0,2,28,0,2,28,0,2,29,0,2,29,0,14,1,244],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[6,4,4,4,4,4,4,4,4,6,6,6,6,6,6,6,6,4,4,4,4,4,4,4,4],[16,0,0,0,0,0,0,0,0,14,15,8,8,8,9,9,9,0,0,0,0,0,0,0,0]],[[[20,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{}],[{"USE_POSITION_SCALING":true},{"USE_BASE_COLOR_MAP":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{},{}],[[{},[{"baseStep":0.9,"baseFeather":0.3,"shadeStep":0.6,"shadeFeather":0.2},"tilingOffset",8,[2,2,1,0,0],"mainColor",8,[4,4284769380],"shadeColor1",8,[4,4283453520],"shadeColor2",8,[4,1661602314],"specular",8,[4,1275068415],"emissive",8,[4,0],"mainTexture",6,0],{},{}],0,11,0,0]]],0,0,[0,0],[9,7],[40,2]],[[[45,"grassGoup"],[58,"grassGoup",[-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13],[5,"e5Peksu5tL9peMeABb8/JC",-1,0]],[86,"grass",1,[-15],[[79,true,-14,[4,"11JgtTUn5OJKE3LJ8pTj/2"],[3],4]],[5,"87M1Av0v5LhZ3LsJOTzwr3",1,0],[1,-0.852,0.892,-1.49],[1,1.8,1.8,1.8]],[33,"RootNode",2,[-16,-17,-18],[5,"54SHCY049LyqH1HRGY3ZVR",1,0]],[36,"grass",1,[-20],[[79,true,-19,[4,"abXR2STONCQrmlGd7QjDWb"],[8],9]],[5,"8avX4W7ZtLOLCZ8n5QtiPm",1,0],[1,1.271,0.836,-2.68],[3,0,-0.09886819763876702,0,0.9951005373808527],[1,1.4,1.4,1.4],[1,0,-11.348,0]],[33,"RootNode",4,[-21,-22,-23],[5,"bdiB2XMldLgpbPP0u9vyiH",1,0]],[36,"grass",1,[-25],[[38,"grass<SkeletalAnimation>",true,-24,[4,"3eRlu7+XFMf4IKjhzVuyYo"],[13],14]],[5,"5fAmHUz0xO9YFym/gsZawP",1,0],[1,0.816,0.874,-2.029],[3,0.009594606467145706,-0.09840154486124139,-0.09656895017241425,0.9904037143297977],[1,1.8,1.8,1.8],[1,0,-11.348,-11.138]],[33,"RootNode",6,[-26,-27,-28],[5,"0cYonIu91LHamoapMUydbc",1,0]],[36,"grass",1,[-30],[[38,"grass<SkeletalAnimation>",true,-29,[4,"22rvun9aNNBbAK//dWXzkX"],[18],19]],[5,"9bIVhdYYpFl7JZmL4oubNS",1,0],[1,1.505,0.835,-2.352],[3,0.009051343059323664,0.011005731118140823,-0.042668681053864996,0.9989876529409666],[1,1.8,1.8,1.8],[1,1.094,1.309,-4.879]],[33,"RootNode",8,[-31,-32,-33],[5,"2at9CGY1VK9qtNpM8kC/KU",1,0]],[36,"grass",1,[-35],[[38,"grass<SkeletalAnimation>",true,-34,[4,"0f8P8jwTVOzaIGGhmhMYJ6"],[23],24]],[5,"2d66RAsipF1brG2RGpHJY1",1,0],[1,2.591,0.697,-3.192],[3,-0.009569056200142995,-0.27238145223532967,-0.02174826425431747,0.961895935454317],[1,1.4,1.4,1.4],[1,-1.735,-31.653,-2.099]],[33,"RootNode",10,[-36,-37,-38],[5,"75DE0pyqBGsIOI2RSOFxap",1,0]],[36,"grass",1,[-40],[[38,"grass<SkeletalAnimation>",true,-39,[4,"b6LjWqcFFEYa267NpDVpBB"],[28],29]],[5,"ffwse8PqZBf4sIEkNdsA+i",1,0],[1,-2.85,0.766,-2.616],[3,-0.007707220961668685,-0.0985673335815995,0.07757256533280044,0.9920723646001587],[1,1.8,1.8,1.8],[1,0,-11.348,8.942]],[33,"RootNode",12,[-41,-42,-43],[5,"12tzV7tYdKJJxbVmqiEpry",1,0]],[36,"grass",1,[-45],[[38,"grass<SkeletalAnimation>",true,-44,[4,"a5eATDuwJGuL6l09vX0n3S"],[33],34]],[5,"adNP+ELEhC4awfcKkY8jYJ",1,0],[1,-3.252,0.663,-3.355],[3,-0.005303598000440666,-0.09872584440048117,0.053380291603709065,0.9936677633716235],[1,1.6,1.6,1.6],[1,9.996766443584073e-17,-11.348,6.150000000000002]],[33,"RootNode",14,[-46,-47,-48],[5,"0eVA3+ezRBf4EQOOoMIo4S",1,0]],[36,"grass",1,[-50],[[38,"grass<SkeletalAnimation>",true,-49,[4,"8fKHzMP19M76liKGOWy5fp"],[38],39]],[5,"33gYFxG8dO2r8iKjzjEx4z",1,0],[1,-4.716,0.534,-2.539],[3,-0.011417842217574529,0.10201162854238845,0.09441482697624534,0.9902267926936081],[1,1.2999999999999998,1.3,1.3],[1,-2.442,11.991,10.641]],[33,"RootNode",16,[-51,-52,-53],[5,"53OGGCuwFNs4KQ0nQRdow5",1,0]],[36,"grass",1,[-55],[[38,"grass<SkeletalAnimation>",true,-54,[4,"63dAWSpBBOqo5RjIXi5sEW"],[43],44]],[5,"27mCip0lFNkL+6Dj/Bpwj4",1,0],[1,-3.151,0.706,-2.905],[3,-0.01606605470413201,0.10576273729137807,0.0511818299419083,0.9929433748057723],[1,1.6,1.6,1.6],[1,-2.461,12.281,5.638]],[33,"RootNode",18,[-56,-57,-58],[5,"560/1xR41BPKG+lcc5935I",1,0]],[36,"grass",1,[-60],[[38,"grass<SkeletalAnimation>",true,-59,[4,"5c8UINxBNN1bAOwYYO6ZIW"],[48],49]],[5,"50aim7sdtB2rmsHB4KRkd5",1,0],[1,2.179,0.714,-3.159],[3,0.0002046174412504865,-0.2725489284000769,-0.05622568582446521,0.9604976376926917],[1,1.4,1.4,1.4],[1,-1.744,-31.778,-6.207]],[33,"RootNode",20,[-61,-62,-63],[5,"25mf8t9bhJIo3E0lcGCo1H",1,0]],[36,"grass",1,[-65],[[38,"grass<SkeletalAnimation>",true,-64,[4,"2dbXeRDsVAWK67o3tGgUEl"],[53],54]],[5,"70DWXrCRRL4pWATtzgi7DN",1,0],[1,5.041,0.406,-3.58],[3,0.026333680128465056,-0.27127042474669716,-0.14805365417229147,0.9506834433368816],[1,1.4,1.4,1.4],[1,-1.815,-32.126,-17.205]],[33,"RootNode",22,[-66,-67,-68],[5,"9dXaYb8ytBBb2yYH4yN6Vh",1,0]],[36,"grass",1,[-70],[[38,"grass<SkeletalAnimation>",true,-69,[4,"42733HPMdIEqobiaBVXbRJ"],[58],59]],[5,"7aOtJ3fThN27Zj4fmkg0ut",1,0],[1,4.153,0.548,-3.566],[3,0.01263456693718553,-0.27225485806840527,-0.09997674733537244,0.9569338064718487],[1,1.4,1.4,1.4],[1,-1.769,-31.94,-11.433]],[33,"RootNode",24,[-71,-72,-73],[5,"fa4L3FVuFMwYhNq67HoU7c",1,0]],[24,"grass",3,[[35,-74,[4,"a6J1jU/r1BPKNIcVMEREit"],[0],[7],2,1,2]],[5,"5fs1r6h0xEiJFeWVPk8SNl",1,0],[3,0.37992816729770207,0.5963678291908521,0.5963678291908521,-0.37992816729770207],[1,0.614784121513367,0.614784121513367,0.614784121513367],[1,-90,-115.0000056286655,0]],[16,"Bone001",3,[-75],[5,"daWdShf/9NHLgm8BB+DJZm",1,0],[1,-0.0461842827498913,0.0000118009265861474,-0.0284814611077309],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[18,"Bone002",27,[[17,"Bone003",-76,[5,"8e/dPEvbdIMo48q55vpZZ3",1,0],[1,0.0397140197455883,-1.19209286886246e-9,7.15255721317476e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[5,"beKna0bXZNtrHWMkpFZoVU",1,0],[1,0.0404664427042007,-3.57627860658738e-9,0],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[16,"Bone004",3,[-77],[5,"94aP4+w7dE/qUrh7Cfcv3Y",1,0],[1,0.0710692703723907,0.0000118009265861474,0.0136896027252078],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[18,"Bone005",29,[[17,"Bone006",-78,[5,"96ATlvvpZKqpZWVYxnyW6U",1,0],[1,0.039714016020298,0,7.74860353658369e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[5,"8fu8biB4BPFKtDBKsYv4K/",1,0],[1,0.0404664427042007,-4.76837147544984e-9,5.9604643443123e-10],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[24,"grass",5,[[35,-79,[4,"28WH2cvhNDFbN3it+8Q+XK"],[5],[7],4,6,7]],[5,"74Q+wg/aVBj5Bkvd+Cqz4L",1,0],[3,0.37992816729770207,0.5963678291908521,0.5963678291908521,-0.37992816729770207],[1,0.614784121513367,0.614784121513367,0.614784121513367],[1,-90,-115.0000056286655,0]],[16,"Bone001",5,[-80],[5,"4fGc2baulLjbJeePpPYcqt",1,0],[1,-0.0461842827498913,0.0000118009265861474,-0.0284814611077309],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[18,"Bone002",32,[[17,"Bone003",-81,[5,"af9wSIs/ZHx5FXOjfa1Jum",1,0],[1,0.0397140197455883,-1.19209286886246e-9,7.15255721317476e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[5,"25LOOT8GBDpr0h1KIC5gCx",1,0],[1,0.0404664427042007,-3.57627860658738e-9,0],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[16,"Bone004",5,[-82],[5,"b8DSzxi5tJyKiMnjvG0NLg",1,0],[1,0.0710692703723907,0.0000118009265861474,0.0136896027252078],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[18,"Bone005",34,[[17,"Bone006",-83,[5,"65QAhjUVBAtLwEci9t05Ey",1,0],[1,0.039714016020298,0,7.74860353658369e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[5,"e75gT5ogJMOoh/2sggS7OQ",1,0],[1,0.0404664427042007,-4.76837147544984e-9,5.9604643443123e-10],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[24,"grass",7,[[35,-84,[4,"87exLhmM1P35jx6GLN7j5f"],[10],[7],6,11,12]],[5,"60njdFxDhJWowG9HZr9kRy",1,0],[3,0.37992816729770207,0.5963678291908521,0.5963678291908521,-0.37992816729770207],[1,0.614784121513367,0.614784121513367,0.614784121513367],[1,-90,-115.0000056286655,0]],[16,"Bone001",7,[-85],[5,"dfSzBMugdCkL5lyChYPcpt",1,0],[1,-0.0461842827498913,0.0000118009265861474,-0.0284814611077309],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[18,"Bone002",37,[[17,"Bone003",-86,[5,"91jR835RZHKbRhzSn1x2pJ",1,0],[1,0.0397140197455883,-1.19209286886246e-9,7.15255721317476e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[5,"3bw6IJ5hBJ0aqjcninjsA3",1,0],[1,0.0404664427042007,-3.57627860658738e-9,0],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[16,"Bone004",7,[-87],[5,"36km6+kJtJZ4iiy8pwU3RO",1,0],[1,0.0710692703723907,0.0000118009265861474,0.0136896027252078],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[18,"Bone005",39,[[17,"Bone006",-88,[5,"977HJ5Wy5HiapZRnYB3I8X",1,0],[1,0.039714016020298,0,7.74860353658369e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[5,"3da6ppQblGu7DGQDIjczFt",1,0],[1,0.0404664427042007,-4.76837147544984e-9,5.9604643443123e-10],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[24,"grass",9,[[35,-89,[4,"dduLonFhNK+q908BUlLM7f"],[15],[7],8,16,17]],[5,"f2zxp5nX1CJq18JC2EndYO",1,0],[3,0.37992816729770207,0.5963678291908521,0.5963678291908521,-0.37992816729770207],[1,0.614784121513367,0.614784121513367,0.614784121513367],[1,-90,-115.0000056286655,0]],[16,"Bone001",9,[-90],[5,"3c+BtM6atJC4XerbYlNlM0",1,0],[1,-0.0461842827498913,0.0000118009265861474,-0.0284814611077309],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[18,"Bone002",42,[[17,"Bone003",-91,[5,"baL59AVvRKlKmpQqSjNAYI",1,0],[1,0.0397140197455883,-1.19209286886246e-9,7.15255721317476e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[5,"89NJAVd1tBZ6C0iX/YbeY2",1,0],[1,0.0404664427042007,-3.57627860658738e-9,0],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[16,"Bone004",9,[-92],[5,"9byDe6eNtGPIztX4VSZKlQ",1,0],[1,0.0710692703723907,0.0000118009265861474,0.0136896027252078],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[18,"Bone005",44,[[17,"Bone006",-93,[5,"6fAgsRfRRHeoZrCvNeGhDK",1,0],[1,0.039714016020298,0,7.74860353658369e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[5,"8exO45eF5F2KzRxFbNE1M/",1,0],[1,0.0404664427042007,-4.76837147544984e-9,5.9604643443123e-10],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[24,"grass",11,[[35,-94,[4,"af0f1GeGlKf5MvKMEuH8MJ"],[20],[7],10,21,22]],[5,"a2WxB7prNBKZLuuRtE7RC2",1,0],[3,0.37992816729770207,0.5963678291908521,0.5963678291908521,-0.37992816729770207],[1,0.614784121513367,0.614784121513367,0.614784121513367],[1,-90,-115.0000056286655,0]],[16,"Bone001",11,[-95],[5,"d9cSWZZzxJ0JJz3NZ3KYKr",1,0],[1,-0.0461842827498913,0.0000118009265861474,-0.0284814611077309],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[18,"Bone002",47,[[17,"Bone003",-96,[5,"65JgfqDUlBhq62ZblXl99a",1,0],[1,0.0397140197455883,-1.19209286886246e-9,7.15255721317476e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[5,"613BOOO+hIlqnTjr1LZ7yD",1,0],[1,0.0404664427042007,-3.57627860658738e-9,0],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[16,"Bone004",11,[-97],[5,"daMGy+QoZIMbYWUh1/PBDR",1,0],[1,0.0710692703723907,0.0000118009265861474,0.0136896027252078],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[18,"Bone005",49,[[17,"Bone006",-98,[5,"4bzVNkn1hF04sTb5BrBwWZ",1,0],[1,0.039714016020298,0,7.74860353658369e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[5,"aea82LsKdAiqVuBFPi2Vfz",1,0],[1,0.0404664427042007,-4.76837147544984e-9,5.9604643443123e-10],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[24,"grass",13,[[35,-99,[4,"e9BPt5G81CloUmA5IJNHIQ"],[25],[7],12,26,27]],[5,"32O+zfC79Ly5/JDvR+zPy3",1,0],[3,0.37992816729770207,0.5963678291908521,0.5963678291908521,-0.37992816729770207],[1,0.614784121513367,0.614784121513367,0.614784121513367],[1,-90,-115.0000056286655,0]],[16,"Bone001",13,[-100],[5,"2csxgVNAlDEIWU7lnXQfKS",1,0],[1,-0.0461842827498913,0.0000118009265861474,-0.0284814611077309],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[18,"Bone002",52,[[17,"Bone003",-101,[5,"f31n3srf1OQ6ztTn+Z0+bi",1,0],[1,0.0397140197455883,-1.19209286886246e-9,7.15255721317476e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[5,"39pnXuaeZGe5VqFTUXoXAo",1,0],[1,0.0404664427042007,-3.57627860658738e-9,0],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[16,"Bone004",13,[-102],[5,"e1Z+TO4odC37Bc8FKLNniF",1,0],[1,0.0710692703723907,0.0000118009265861474,0.0136896027252078],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[18,"Bone005",54,[[17,"Bone006",-103,[5,"c8HIUzEBxJx72ffmHr7Yzh",1,0],[1,0.039714016020298,0,7.74860353658369e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[5,"82tqRzYDNKi6iXruWWHldm",1,0],[1,0.0404664427042007,-4.76837147544984e-9,5.9604643443123e-10],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[24,"grass",15,[[35,-104,[4,"7dt8ZZ5EBNDIxOgpt1XbGu"],[30],[7],14,31,32]],[5,"3c/GljN9JNKpGUQDJiCaAz",1,0],[3,0.37992816729770207,0.5963678291908521,0.5963678291908521,-0.37992816729770207],[1,0.614784121513367,0.614784121513367,0.614784121513367],[1,-90,-115.0000056286655,0]],[16,"Bone001",15,[-105],[5,"17tlC2EGZMWoKAixVNAp0A",1,0],[1,-0.0461842827498913,0.0000118009265861474,-0.0284814611077309],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[18,"Bone002",57,[[17,"Bone003",-106,[5,"9fnTS8hnVIWqrzTdhgEpre",1,0],[1,0.0397140197455883,-1.19209286886246e-9,7.15255721317476e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[5,"77DlSvZMVCFLNlyGWiwIha",1,0],[1,0.0404664427042007,-3.57627860658738e-9,0],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[16,"Bone004",15,[-107],[5,"d1EnMgh6RE7o+kI5cUNlG0",1,0],[1,0.0710692703723907,0.0000118009265861474,0.0136896027252078],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[18,"Bone005",59,[[17,"Bone006",-108,[5,"8cUixi2TpMHINjSklAPeYi",1,0],[1,0.039714016020298,0,7.74860353658369e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[5,"b7XmnH2bBCVpvgTAKnVXA2",1,0],[1,0.0404664427042007,-4.76837147544984e-9,5.9604643443123e-10],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[24,"grass",17,[[35,-109,[4,"c4Nekl9YtKUKupS0ASX7It"],[35],[7],16,36,37]],[5,"43yCcO1I5D6qP+LJIIGKjX",1,0],[3,0.37992816729770207,0.5963678291908521,0.5963678291908521,-0.37992816729770207],[1,0.614784121513367,0.614784121513367,0.614784121513367],[1,-90,-115.0000056286655,0]],[16,"Bone001",17,[-110],[5,"0aJTcuk/5M56nEkb+D7tN9",1,0],[1,-0.0461842827498913,0.0000118009265861474,-0.0284814611077309],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[18,"Bone002",62,[[17,"Bone003",-111,[5,"d5T2sohQVAEa4ljoSzlMKU",1,0],[1,0.0397140197455883,-1.19209286886246e-9,7.15255721317476e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[5,"93hV+qqgFP44pIvuByy6RE",1,0],[1,0.0404664427042007,-3.57627860658738e-9,0],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[16,"Bone004",17,[-112],[5,"6etpava3ZGlovr3HG7SpRo",1,0],[1,0.0710692703723907,0.0000118009265861474,0.0136896027252078],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[18,"Bone005",64,[[17,"Bone006",-113,[5,"6c2sTe+khLGYrsZVSADL4H",1,0],[1,0.039714016020298,0,7.74860353658369e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[5,"ecsSU+lvpNf7DhOOeFG7w2",1,0],[1,0.0404664427042007,-4.76837147544984e-9,5.9604643443123e-10],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[24,"grass",19,[[35,-114,[4,"b9cuhcVRxPvZTPHcAyE7eS"],[40],[7],18,41,42]],[5,"87cW2HzEtNk4+RMW95NbLB",1,0],[3,0.37992816729770207,0.5963678291908521,0.5963678291908521,-0.37992816729770207],[1,0.614784121513367,0.614784121513367,0.614784121513367],[1,-90,-115.0000056286655,0]],[16,"Bone001",19,[-115],[5,"16ssZzbLdO76GQg4Dvdp/y",1,0],[1,-0.0461842827498913,0.0000118009265861474,-0.0284814611077309],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[18,"Bone002",67,[[17,"Bone003",-116,[5,"5bcVkwfGRPza49BU4T6rqn",1,0],[1,0.0397140197455883,-1.19209286886246e-9,7.15255721317476e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[5,"fcqb+cLDVJ3KNvBTyJYBwm",1,0],[1,0.0404664427042007,-3.57627860658738e-9,0],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[16,"Bone004",19,[-117],[5,"0eRKfLOh9OdLsOOjTosv1c",1,0],[1,0.0710692703723907,0.0000118009265861474,0.0136896027252078],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[18,"Bone005",69,[[17,"Bone006",-118,[5,"0b/yPLcR1FiZPqyfaG8HBZ",1,0],[1,0.039714016020298,0,7.74860353658369e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[5,"0fPapM97RGmYmlB69FuuSF",1,0],[1,0.0404664427042007,-4.76837147544984e-9,5.9604643443123e-10],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[24,"grass",21,[[35,-119,[4,"f3T3OFBBJBYrGbPSQ+k7GJ"],[45],[7],20,46,47]],[5,"08LJZ1ezRCiqnszI5cXQTx",1,0],[3,0.37992816729770207,0.5963678291908521,0.5963678291908521,-0.37992816729770207],[1,0.614784121513367,0.614784121513367,0.614784121513367],[1,-90,-115.0000056286655,0]],[16,"Bone001",21,[-120],[5,"c9g0zchT9L8IQmY+99TABR",1,0],[1,-0.0461842827498913,0.0000118009265861474,-0.0284814611077309],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[18,"Bone002",72,[[17,"Bone003",-121,[5,"d8OdalQsZKwLFf2mFuR1VJ",1,0],[1,0.0397140197455883,-1.19209286886246e-9,7.15255721317476e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[5,"ecFy8CTgxCib8Fky/YcoUL",1,0],[1,0.0404664427042007,-3.57627860658738e-9,0],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[16,"Bone004",21,[-122],[5,"91+xPZxDtGRp/x7cNrBUhM",1,0],[1,0.0710692703723907,0.0000118009265861474,0.0136896027252078],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[18,"Bone005",74,[[17,"Bone006",-123,[5,"66R8TA3S1NT4HLywjDiP1Q",1,0],[1,0.039714016020298,0,7.74860353658369e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[5,"963dgjTmdES7q6KBvCTllJ",1,0],[1,0.0404664427042007,-4.76837147544984e-9,5.9604643443123e-10],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[24,"grass",23,[[35,-124,[4,"d0A5LfhGhAfrDnBGJ3JzOe"],[50],[7],22,51,52]],[5,"203+J3Vb1LP7KUgkjLvNtX",1,0],[3,0.37992816729770207,0.5963678291908521,0.5963678291908521,-0.37992816729770207],[1,0.614784121513367,0.614784121513367,0.614784121513367],[1,-90,-115.0000056286655,0]],[16,"Bone001",23,[-125],[5,"9eOEdVVahA+rbDiF4AJNNX",1,0],[1,-0.0461842827498913,0.0000118009265861474,-0.0284814611077309],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[18,"Bone002",77,[[17,"Bone003",-126,[5,"3aJII/zG9KaYapX0uizphW",1,0],[1,0.0397140197455883,-1.19209286886246e-9,7.15255721317476e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[5,"48r+NZR1BD7Y5qEv/ruQsO",1,0],[1,0.0404664427042007,-3.57627860658738e-9,0],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[16,"Bone004",23,[-127],[5,"469eCD0ttKHZacZ3xtfeuD",1,0],[1,0.0710692703723907,0.0000118009265861474,0.0136896027252078],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[18,"Bone005",79,[[17,"Bone006",-128,[5,"1fFpy0ihVOYbzhBLRLkL1Y",1,0],[1,0.039714016020298,0,7.74860353658369e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[5,"d9iCqzyppAILXebiHSqtDk",1,0],[1,0.0404664427042007,-4.76837147544984e-9,5.9604643443123e-10],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[24,"grass",25,[[35,-129,[4,"161SEdWiFO/abXxUI8RkYk"],[55],[7],24,56,57]],[5,"80TsYKkUVBAIbPGc2Ao+X4",1,0],[3,0.37992816729770207,0.5963678291908521,0.5963678291908521,-0.37992816729770207],[1,0.614784121513367,0.614784121513367,0.614784121513367],[1,-90,-115.0000056286655,0]],[16,"Bone001",25,[-130],[5,"54j/6cneBCF4PpXQIO+ZrT",1,0],[1,-0.0461842827498913,0.0000118009265861474,-0.0284814611077309],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[18,"Bone002",82,[[17,"Bone003",-131,[5,"6aDs2ciZhDh6tahiNmO4QO",1,0],[1,0.0397140197455883,-1.19209286886246e-9,7.15255721317476e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[5,"1er+9JvftCj5j548DE5PNk",1,0],[1,0.0404664427042007,-3.57627860658738e-9,0],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[16,"Bone004",25,[-132],[5,"c8ON8aNTZH1YV9KZsolNGO",1,0],[1,0.0710692703723907,0.0000118009265861474,0.0136896027252078],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[18,"Bone005",84,[[17,"Bone006",-133,[5,"1eZ45FwjhMoY5AmDd/ApaW",1,0],[1,0.039714016020298,0,7.74860353658369e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[5,"7fkJUsKFZMHbutZKiHcKAf",1,0],[1,0.0404664427042007,-4.76837147544984e-9,5.9604643443123e-10],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]]],0,[0,5,1,0,-1,2,0,-2,4,0,-3,6,0,-4,8,0,-5,10,0,-6,12,0,-7,14,0,-8,16,0,-9,18,0,-10,20,0,-11,22,0,-12,24,0,2,2,0,-1,3,0,-1,26,0,-2,27,0,-3,29,0,2,4,0,-1,5,0,-1,31,0,-2,32,0,-3,34,0,2,6,0,-1,7,0,-1,36,0,-2,37,0,-3,39,0,2,8,0,-1,9,0,-1,41,0,-2,42,0,-3,44,0,2,10,0,-1,11,0,-1,46,0,-2,47,0,-3,49,0,2,12,0,-1,13,0,-1,51,0,-2,52,0,-3,54,0,2,14,0,-1,15,0,-1,56,0,-2,57,0,-3,59,0,2,16,0,-1,17,0,-1,61,0,-2,62,0,-3,64,0,2,18,0,-1,19,0,-1,66,0,-2,67,0,-3,69,0,2,20,0,-1,21,0,-1,71,0,-2,72,0,-3,74,0,2,22,0,-1,23,0,-1,76,0,-2,77,0,-3,79,0,2,24,0,-1,25,0,-1,81,0,-2,82,0,-3,84,0,2,26,0,-1,28,0,8,28,0,-1,30,0,8,30,0,2,31,0,-1,33,0,8,33,0,-1,35,0,8,35,0,2,36,0,-1,38,0,8,38,0,-1,40,0,8,40,0,2,41,0,-1,43,0,8,43,0,-1,45,0,8,45,0,2,46,0,-1,48,0,8,48,0,-1,50,0,8,50,0,2,51,0,-1,53,0,8,53,0,-1,55,0,8,55,0,2,56,0,-1,58,0,8,58,0,-1,60,0,8,60,0,2,61,0,-1,63,0,8,63,0,-1,65,0,8,65,0,2,66,0,-1,68,0,8,68,0,-1,70,0,8,70,0,2,71,0,-1,73,0,8,73,0,-1,75,0,8,75,0,2,76,0,-1,78,0,8,78,0,-1,80,0,8,80,0,2,81,0,-1,83,0,8,83,0,-1,85,0,8,85,0,14,1,133],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[-1,3,11,-1,12,-1,3,11,-1,12,-1,3,11,-1,12,-1,3,11,-1,12,-1,3,11,-1,12,-1,3,11,-1,12,-1,3,11,-1,12,-1,3,11,-1,12,-1,3,11,-1,12,-1,3,11,-1,12,-1,3,11,-1,12,-1,3,11,-1,12],[5,6,7,1,1,5,6,7,1,1,5,6,7,1,1,5,6,7,1,1,5,6,7,1,1,5,6,7,1,1,5,6,7,1,1,5,6,7,1,1,5,6,7,1,1,5,6,7,1,1,5,6,7,1,1,5,6,7,1,1]],[[[45,"ResultLayer"],[87,"ResultLayer",false,[-7,-8,-9],[[10,-2,[4,"94OzPXNv9BFLern2HhC1rJ"],[5,960,640]],[46,45,100,100,-3,[4,"6cKbc+DBtOfqw+JcfPXt/J"]],[113,-4,[4,"d1KhmWFFRNFozNvFN5G8gq"]],[47,-6,[4,"71/GKkX+ROEqF6ZnyxU74Q"],[[9,"58679b5UTJPRpELfPBmUTOi","onClicked",-5],[50]]]],[5,"fe5yLQ9CJEjoh+6wWgxGiw",-1,0]],[39,"bg",33554432,1,[[10,-10,[4,"f7NISe7HdAD68SLfhnddy8"],[5,960,640]],[64,2,0,-11,[4,"e71ctEmpxFC4KlSYRZNz/a"],0],[46,45,1,1,-12,[4,"09y8Ve3qpFJL3EQzwc/Rqa"]],[47,-13,[4,"dfDH+lUCVN7L5Hc9gb2AA8"],[[50]]]],[5,"41r7MJ5mlHkLrJOLxouw3T",1,0]],[73,"succ",33554432,1,[[10,-14,[4,"f7NISe7HdAD68SLfhnddy8"],[5,1760,1536]],[15,-15,[4,"e71ctEmpxFC4KlSYRZNz/a"],1]],[5,"2ewtVz7B9NrqRNVKeI3mfe",1,0],[1,0.2,0.2,1]],[88,"failed",false,33554432,1,[[10,-16,[4,"f7NISe7HdAD68SLfhnddy8"],[5,1760,1536]],[15,-17,[4,"e71ctEmpxFC4KlSYRZNz/a"],2]],[5,"08id6ryktIbbXBjQkaonv5",1,0],[1,0.2,0.2,1]]],0,[0,5,1,0,2,1,0,2,1,0,2,1,0,15,1,0,2,1,0,-1,2,0,-2,3,0,-3,4,0,2,2,0,2,2,0,2,2,0,2,2,0,2,3,0,2,3,0,2,4,0,2,4,0,14,1,17],[0,0,0],[6,6,6],[16,41,42]],[[[45,"HitPointController"],[71,"HitPointController",false,33554432,[-4,-5],[[10,-2,[4,"62IexYbGVE3YQWyIea1LBM"],[5,960,640]],[46,45,100,100,-3,[4,"80sYLqoTJK5ZHRy3+XWTng"]]],[5,"9buk+ykyBPVIxOFR6QFQu/",-1,0]],[72,"AdjustHitPointBall",33554432,1,[-12],[[10,-6,[4,"f7NISe7HdAD68SLfhnddy8"],[5,400,400]],[56,0,-7,[4,"e71ctEmpxFC4KlSYRZNz/a"],2],[77,-8,[4,"aehgTvaChEdIQGsCz2eBAX"]],[47,-10,[4,"ecfBak/7pCx77b60WhpNeC"],[[9,"4913eq+2PRFb5zVXfoi8lID","onClick",-9]]],[114,-11,[4,"43Nw9gjf1J/6VdWVQ2SKtm"]]],[5,"04CmHVH11JmoC2hNpofNXH",1,0]],[39,"bg",33554432,1,[[10,-13,[4,"f7NISe7HdAD68SLfhnddy8"],[5,960,640]],[64,2,0,-14,[4,"e71ctEmpxFC4KlSYRZNz/a"],0],[46,45,1,1,-15,[4,"86TtAWzuRKd6flLURtyV/m"]],[47,-16,[4,"9evybn6z5Cvrlg3/H+Tl14"],[[50]]]],[5,"02j+EPWM9DfaaqR8kgRUMm",1,0]],[39,"point",33554432,2,[[10,-17,[4,"f7NISe7HdAD68SLfhnddy8"],[5,20,20]],[15,-18,[4,"e71ctEmpxFC4KlSYRZNz/a"],1]],[5,"45TC03FY1CkoBNTASOxMxx",1,0]]],0,[0,5,1,0,2,1,0,2,1,0,-1,3,0,-2,2,0,2,2,0,2,2,0,2,2,0,15,2,0,2,2,0,2,2,0,-1,4,0,2,3,0,2,3,0,2,3,0,2,3,0,2,4,0,2,4,0,14,1,18],[0,0,0],[6,6,6],[16,19,20]],[[[51,"seafloor",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{"metallic":0.400000005960464,"roughness":0.70710676908493,"alphaThreshold":0},"albedoScale",8,[1,1,1,1],"mainTexture",6,0]],11]]],0,0,[0,0],[9,7],[43,10]],[[[20,[{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}},{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}},{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}},{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}}],[{"USE_OUTLINE_PASS":true},{"USE_BASE_COLOR_MAP":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{"USE_BASE_COLOR_MAP":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{"USE_BASE_COLOR_MAP":true}],[[{},[{},"specular",8,[4,16777215],"mainTexture",6,0],{},{}],0,11,0,0]]],0,0,[0,0],[9,7],[44,2]],[[[115,"main"],[99,"Scene3D","65gjHIgexBEpz3YuZ6iJDE",[-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23],[-1]],[25,[11,"71g0nLrLpMhJ0RxJkOaKCl",-406,[107,"276admPO9Hg7VYvC5cM+Fv",[[22,[0,["3c4Emiz61Nm6ODbDxrzmkA","4bx2KLlcRC1L/+yriAjeZU"]],[[32,[[9,"b94f1KxG3pL+oc2v4/C0XXe","onMenuLevelClicked",1]]]]],[22,[0,["d6xjbtOXxA5alX9x9d9eex","4bx2KLlcRC1L/+yriAjeZU"]],[[32,[[9,"b94f1KxG3pL+oc2v4/C0XXe","onMenuLevelClicked",1]]]]],[22,[0,["44c9aM4kdGapJ4wnNw0Ivr","4bx2KLlcRC1L/+yriAjeZU"]],[[32,[[9,"b94f1KxG3pL+oc2v4/C0XXe","onMenuLevelClicked",1]]]]],[22,[0,["f6FsL6VTNHlYvuRvWEg/JT","4bx2KLlcRC1L/+yriAjeZU"]],[[32,[[9,"b94f1KxG3pL+oc2v4/C0XXe","onMenuLevelClicked",1]]]]],[22,[0,["96GtoVFeFJnaBR5asUFypE","4bx2KLlcRC1L/+yriAjeZU"]],[[32,[[9,"b94f1KxG3pL+oc2v4/C0XXe","onMenuLevelClicked",1]]]]],[22,[0,["6dwFI5k3dJZ5wystvCT/By","4bx2KLlcRC1L/+yriAjeZU"]],[[32,[[9,"b94f1KxG3pL+oc2v4/C0XXe","onMenuLevelClicked",1]]]]],[22,[0,["a1FKfeDZJB9IaxO5IWrqsS","4bx2KLlcRC1L/+yriAjeZU"]],[[32,[[9,"b94f1KxG3pL+oc2v4/C0XXe","onMenuLevelClicked",1]]]]],[22,[0,["dcfXL6Nr1MQoHSe1cXBV0G","4bx2KLlcRC1L/+yriAjeZU"]],[[32,[[9,"b94f1KxG3pL+oc2v4/C0XXe","onMenuLevelClicked",1]]]]],[22,[0,["70aaMr1VdGrL6RduYvbHeY","4bx2KLlcRC1L/+yriAjeZU"]],[[32,[[9,"b94f1KxG3pL+oc2v4/C0XXe","onMenuLevelClicked",1]]]]],[22,[0,["d6wKd9mWpBjYJs1ES2ekhT","4bx2KLlcRC1L/+yriAjeZU"]],[[32,[[9,"b94f1KxG3pL+oc2v4/C0XXe","onMenuLevelClicked",1]]]]],[22,[0,["c5EpSL/21HHbfTDe1MxE79","4bx2KLlcRC1L/+yriAjeZU"]],[[32,[[9,"b94f1KxG3pL+oc2v4/C0XXe","onMenuLevelClicked",1]]]]],[22,[0,["61TrRFN0dCtbFDajsDiHVw","4bx2KLlcRC1L/+yriAjeZU"]],[[32,[[9,"b94f1KxG3pL+oc2v4/C0XXe","onMenuLevelClicked",1]]]]],[22,[0,["07JLlQNkVAEq0tQxSuPv2z","4bx2KLlcRC1L/+yriAjeZU"]],[[32,[[9,"b94f1KxG3pL+oc2v4/C0XXe","onMenuLevelClicked",1]]]]],[22,[0,["20Gsq33o1PHbeOnfMxLKjI","4bx2KLlcRC1L/+yriAjeZU"]],[[32,[[9,"b94f1KxG3pL+oc2v4/C0XXe","onMenuLevelClicked",1]]]]],[22,[0,["e8iejSF2tHxLwaw5WTJ7Mk","4bx2KLlcRC1L/+yriAjeZU"]],[[32,[[9,"b94f1KxG3pL+oc2v4/C0XXe","onMenuLevelClicked",1]]]]]],[[8,"MenuLayer",["_name"],-24],[13,["_lpos"],-25,[1,0,0,0]],[13,["_lrot"],-26,[3,0,0,0,1]],[8,true,["_active"],-27],[3,["_prefab","root"],-29,-28],[3,["_prefab","root"],-31,-30],[3,["_prefab","instance","prefabRootNode"],-33,-32],[3,["_prefab","instance","propertyOverrides","3","value"],-35,-34],[3,["_prefab","instance","propertyOverrides","4","value"],-37,-36],[3,["_prefab","instance","propertyOverrides","6","value"],-39,-38],[3,["_prefab","instance","propertyOverrides","7","value"],-41,-40],[3,["_prefab","instance","propertyOverrides","8","value"],-43,-42],[3,["_prefab","instance","propertyOverrides","10","value"],-45,-44],[3,["_prefab","instance","propertyOverrides","11","value"],-47,-46],[3,["_prefab","instance","propertyOverrides","12","value"],-49,-48],[3,["_prefab","instance","propertyOverrides","14","value"],-51,-50],[3,["_prefab","instance","propertyOverrides","15","value"],-53,-52],[3,["_prefab","root"],-55,-54],[3,["_prefab","instance","prefabRootNode"],-57,-56],[3,["_prefab","instance","propertyOverrides","3","value"],-59,-58],[3,["_prefab","instance","propertyOverrides","4","value"],-61,-60],[3,["_prefab","instance","propertyOverrides","9","value"],-63,-62],[3,["_prefab","instance","propertyOverrides","10","value"],-65,-64],[3,["_prefab","instance","propertyOverrides","11","value"],-67,-66],[3,["_prefab","instance","propertyOverrides","12","value"],-69,-68],[3,["_prefab","instance","propertyOverrides","14","value"],-71,-70],[3,["_prefab","instance","propertyOverrides","15","value"],-73,-72],[3,["_prefab","instance","propertyOverrides","16","value"],-75,-74],[3,["_prefab","instance","propertyOverrides","18","value"],-77,-76],[3,["_prefab","root"],-79,-78],[3,["_prefab","instance","prefabRootNode"],-81,-80],[3,["_prefab","instance","propertyOverrides","3","value"],-83,-82],[3,["_prefab","instance","propertyOverrides","4","value"],-85,-84],[3,["_prefab","instance","propertyOverrides","9","value"],-87,-86],[3,["_prefab","instance","propertyOverrides","10","value"],-89,-88],[3,["_prefab","instance","propertyOverrides","11","value"],-91,-90],[3,["_prefab","instance","propertyOverrides","12","value"],-93,-92],[3,["_prefab","instance","propertyOverrides","13","value"],-95,-94],[3,["_prefab","instance","propertyOverrides","14","value"],-97,-96],[3,["_prefab","instance","propertyOverrides","15","value"],-99,-98],[3,["_prefab","instance","propertyOverrides","16","value"],-101,-100],[3,["_prefab","root"],-103,-102],[3,["_prefab","instance","prefabRootNode"],-105,-104],[3,["_prefab","instance","propertyOverrides","3","value"],-107,-106],[3,["_prefab","instance","propertyOverrides","4","value"],-109,-108],[3,["_prefab","instance","propertyOverrides","9","value"],-111,-110],[3,["_prefab","instance","propertyOverrides","10","value"],-113,-112],[3,["_prefab","instance","propertyOverrides","11","value"],-115,-114],[3,["_prefab","instance","propertyOverrides","12","value"],-117,-116],[3,["_prefab","instance","propertyOverrides","13","value"],-119,-118],[3,["_prefab","instance","propertyOverrides","14","value"],-121,-120],[3,["_prefab","instance","propertyOverrides","15","value"],-123,-122],[3,["_prefab","instance","propertyOverrides","16","value"],-125,-124],[3,["_prefab","root"],-127,-126],[3,["_prefab","instance","prefabRootNode"],-129,-128],[3,["_prefab","instance","propertyOverrides","3","value"],-131,-130],[3,["_prefab","instance","propertyOverrides","4","value"],-133,-132],[3,["_prefab","instance","propertyOverrides","9","value"],-135,-134],[3,["_prefab","instance","propertyOverrides","11","value"],-137,-136],[3,["_prefab","instance","propertyOverrides","13","value"],-139,-138],[3,["_prefab","instance","propertyOverrides","15","value"],-141,-140],[3,["_prefab","instance","propertyOverrides","16","value"],-143,-142],[3,["_prefab","instance","propertyOverrides","17","value"],-145,-144],[3,["_prefab","instance","propertyOverrides","18","value"],-147,-146],[3,["_prefab","instance","propertyOverrides","20","value"],-149,-148],[3,["_prefab","root"],-151,-150],[3,["_prefab","instance","prefabRootNode"],-153,-152],[3,["_prefab","instance","propertyOverrides","3","value"],-155,-154],[3,["_prefab","instance","propertyOverrides","4","value"],-157,-156],[3,["_prefab","instance","propertyOverrides","9","value"],-159,-158],[3,["_prefab","instance","propertyOverrides","11","value"],-161,-160],[3,["_prefab","instance","propertyOverrides","13","value"],-163,-162],[3,["_prefab","instance","propertyOverrides","15","value"],-165,-164],[3,["_prefab","instance","propertyOverrides","16","value"],-167,-166],[3,["_prefab","instance","propertyOverrides","17","value"],-169,-168],[3,["_prefab","instance","propertyOverrides","18","value"],-171,-170],[3,["_prefab","instance","propertyOverrides","20","value"],-173,-172],[3,["_prefab","root"],-175,-174],[3,["_prefab","instance","prefabRootNode"],-177,-176],[3,["_prefab","instance","propertyOverrides","3","value"],-179,-178],[3,["_prefab","instance","propertyOverrides","4","value"],-181,-180],[3,["_prefab","instance","propertyOverrides","9","value"],-183,-182],[3,["_prefab","instance","propertyOverrides","11","value"],-185,-184],[3,["_prefab","instance","propertyOverrides","13","value"],-187,-186],[3,["_prefab","instance","propertyOverrides","15","value"],-189,-188],[3,["_prefab","instance","propertyOverrides","16","value"],-191,-190],[3,["_prefab","instance","propertyOverrides","17","value"],-193,-192],[3,["_prefab","instance","propertyOverrides","18","value"],-195,-194],[3,["_prefab","instance","propertyOverrides","20","value"],-197,-196],[3,["_prefab","root"],-199,-198],[3,["_prefab","instance","prefabRootNode"],-201,-200],[3,["_prefab","instance","propertyOverrides","3","value"],-203,-202],[3,["_prefab","instance","propertyOverrides","4","value"],-205,-204],[3,["_prefab","instance","propertyOverrides","9","value"],-207,-206],[3,["_prefab","instance","propertyOverrides","11","value"],-209,-208],[3,["_prefab","instance","propertyOverrides","13","value"],-211,-210],[3,["_prefab","instance","propertyOverrides","15","value"],-213,-212],[3,["_prefab","instance","propertyOverrides","16","value"],-215,-214],[3,["_prefab","instance","propertyOverrides","17","value"],-217,-216],[3,["_prefab","instance","propertyOverrides","18","value"],-219,-218],[3,["_prefab","instance","propertyOverrides","20","value"],-221,-220],[3,["_prefab","root"],-223,-222],[3,["_prefab","instance","prefabRootNode"],-225,-224],[3,["_prefab","instance","propertyOverrides","3","value"],-227,-226],[3,["_prefab","instance","propertyOverrides","4","value"],-229,-228],[3,["_prefab","instance","propertyOverrides","9","value"],-231,-230],[3,["_prefab","instance","propertyOverrides","11","value"],-233,-232],[3,["_prefab","instance","propertyOverrides","13","value"],-235,-234],[3,["_prefab","instance","propertyOverrides","15","value"],-237,-236],[3,["_prefab","instance","propertyOverrides","16","value"],-239,-238],[3,["_prefab","instance","propertyOverrides","17","value"],-241,-240],[3,["_prefab","instance","propertyOverrides","18","value"],-243,-242],[3,["_prefab","instance","propertyOverrides","20","value"],-245,-244],[3,["_prefab","root"],-247,-246],[3,["_prefab","instance","prefabRootNode"],-249,-248],[3,["_prefab","instance","propertyOverrides","3","value"],-251,-250],[3,["_prefab","instance","propertyOverrides","4","value"],-253,-252],[3,["_prefab","instance","propertyOverrides","9","value"],-255,-254],[3,["_prefab","instance","propertyOverrides","11","value"],-257,-256],[3,["_prefab","instance","propertyOverrides","13","value"],-259,-258],[3,["_prefab","instance","propertyOverrides","15","value"],-261,-260],[3,["_prefab","instance","propertyOverrides","16","value"],-263,-262],[3,["_prefab","instance","propertyOverrides","17","value"],-265,-264],[3,["_prefab","instance","propertyOverrides","18","value"],-267,-266],[3,["_prefab","instance","propertyOverrides","20","value"],-269,-268],[3,["_prefab","root"],-271,-270],[3,["_prefab","instance","prefabRootNode"],-273,-272],[3,["_prefab","instance","propertyOverrides","3","value"],-275,-274],[3,["_prefab","instance","propertyOverrides","4","value"],-277,-276],[3,["_prefab","instance","propertyOverrides","9","value"],-279,-278],[3,["_prefab","instance","propertyOverrides","11","value"],-281,-280],[3,["_prefab","instance","propertyOverrides","13","value"],-283,-282],[3,["_prefab","instance","propertyOverrides","15","value"],-285,-284],[3,["_prefab","instance","propertyOverrides","16","value"],-287,-286],[3,["_prefab","instance","propertyOverrides","17","value"],-289,-288],[3,["_prefab","instance","propertyOverrides","18","value"],-291,-290],[3,["_prefab","instance","propertyOverrides","20","value"],-293,-292],[3,["_prefab","root"],-295,-294],[3,["_prefab","instance","prefabRootNode"],-297,-296],[3,["_prefab","instance","propertyOverrides","3","value"],-299,-298],[3,["_prefab","instance","propertyOverrides","4","value"],-301,-300],[3,["_prefab","instance","propertyOverrides","9","value"],-303,-302],[3,["_prefab","instance","propertyOverrides","11","value"],-305,-304],[3,["_prefab","instance","propertyOverrides","13","value"],-307,-306],[3,["_prefab","instance","propertyOverrides","15","value"],-309,-308],[3,["_prefab","instance","propertyOverrides","16","value"],-311,-310],[3,["_prefab","instance","propertyOverrides","17","value"],-313,-312],[3,["_prefab","instance","propertyOverrides","18","value"],-315,-314],[3,["_prefab","instance","propertyOverrides","20","value"],-317,-316],[3,["_prefab","root"],-319,-318],[3,["_prefab","instance","prefabRootNode"],-321,-320],[3,["_prefab","instance","propertyOverrides","3","value"],-323,-322],[3,["_prefab","instance","propertyOverrides","4","value"],-325,-324],[3,["_prefab","instance","propertyOverrides","9","value"],-327,-326],[3,["_prefab","instance","propertyOverrides","11","value"],-329,-328],[3,["_prefab","instance","propertyOverrides","13","value"],-331,-330],[3,["_prefab","instance","propertyOverrides","15","value"],-333,-332],[3,["_prefab","instance","propertyOverrides","16","value"],-335,-334],[3,["_prefab","instance","propertyOverrides","17","value"],-337,-336],[3,["_prefab","instance","propertyOverrides","18","value"],-339,-338],[3,["_prefab","instance","propertyOverrides","20","value"],-341,-340],[3,["_prefab","root"],-343,-342],[3,["_prefab","instance","prefabRootNode"],-345,-344],[3,["_prefab","instance","propertyOverrides","3","value"],-347,-346],[3,["_prefab","instance","propertyOverrides","4","value"],-349,-348],[3,["_prefab","instance","propertyOverrides","9","value"],-351,-350],[3,["_prefab","instance","propertyOverrides","11","value"],-353,-352],[3,["_prefab","instance","propertyOverrides","13","value"],-355,-354],[3,["_prefab","instance","propertyOverrides","15","value"],-357,-356],[3,["_prefab","instance","propertyOverrides","16","value"],-359,-358],[3,["_prefab","instance","propertyOverrides","17","value"],-361,-360],[3,["_prefab","instance","propertyOverrides","18","value"],-363,-362],[3,["_prefab","instance","propertyOverrides","20","value"],-365,-364],[3,["_prefab","root"],-367,-366],[3,["_prefab","instance","prefabRootNode"],-369,-368],[3,["_prefab","instance","propertyOverrides","3","value"],-371,-370],[3,["_prefab","instance","propertyOverrides","4","value"],-373,-372],[3,["_prefab","instance","propertyOverrides","9","value"],-375,-374],[3,["_prefab","instance","propertyOverrides","11","value"],-377,-376],[3,["_prefab","instance","propertyOverrides","13","value"],-379,-378],[3,["_prefab","instance","propertyOverrides","15","value"],-381,-380],[3,["_prefab","instance","propertyOverrides","16","value"],-383,-382],[3,["_prefab","instance","propertyOverrides","17","value"],-385,-384],[3,["_prefab","instance","propertyOverrides","18","value"],-387,-386],[3,["_prefab","instance","propertyOverrides","20","value"],-389,-388],[1,["_prefab","root"],[0,["8fHtItnx1GNLUmShkrYIBX"]],-390],[1,["_prefab","root"],[0,["3c4Emiz61Nm6ODbDxrzmkA","8fB2KqVsFA34hfa5YNSBFN"]],-391],[1,["_prefab","root"],[0,["d6xjbtOXxA5alX9x9d9eex","8fB2KqVsFA34hfa5YNSBFN"]],-392],[1,["_prefab","root"],[0,["44c9aM4kdGapJ4wnNw0Ivr","8fB2KqVsFA34hfa5YNSBFN"]],-393],[1,["_prefab","root"],[0,["f6FsL6VTNHlYvuRvWEg/JT","8fB2KqVsFA34hfa5YNSBFN"]],-394],[1,["_prefab","root"],[0,["96GtoVFeFJnaBR5asUFypE","8fB2KqVsFA34hfa5YNSBFN"]],-395],[1,["_prefab","root"],[0,["6dwFI5k3dJZ5wystvCT/By","8fB2KqVsFA34hfa5YNSBFN"]],-396],[1,["_prefab","root"],[0,["a1FKfeDZJB9IaxO5IWrqsS","8fB2KqVsFA34hfa5YNSBFN"]],-397],[1,["_prefab","root"],[0,["dcfXL6Nr1MQoHSe1cXBV0G","8fB2KqVsFA34hfa5YNSBFN"]],-398],[1,["_prefab","root"],[0,["70aaMr1VdGrL6RduYvbHeY","8fB2KqVsFA34hfa5YNSBFN"]],-399],[1,["_prefab","root"],[0,["d6wKd9mWpBjYJs1ES2ekhT","8fB2KqVsFA34hfa5YNSBFN"]],-400],[1,["_prefab","root"],[0,["c5EpSL/21HHbfTDe1MxE79","8fB2KqVsFA34hfa5YNSBFN"]],-401],[1,["_prefab","root"],[0,["61TrRFN0dCtbFDajsDiHVw","8fB2KqVsFA34hfa5YNSBFN"]],-402],[1,["_prefab","root"],[0,["07JLlQNkVAEq0tQxSuPv2z","8fB2KqVsFA34hfa5YNSBFN"]],-403],[1,["_prefab","root"],[0,["20Gsq33o1PHbeOnfMxLKjI","8fB2KqVsFA34hfa5YNSBFN"]],-404],[1,["_prefab","root"],[0,["e8iejSF2tHxLwaw5WTJ7Mk","8fB2KqVsFA34hfa5YNSBFN"]],-405]]],74]],[25,[11,"4bx2KLlcRC1L/+yriAjeZU",-417,[12,"3c4Emiz61Nm6ODbDxrzmkA",2,[[14,[null],[0,["4bx2KLlcRC1L/+yriAjeZU"]]]],[[2,"Card0",["_name"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[6,["_lpos"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[1,-180,210,0]],[6,["_lrot"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[3,0,0,0,1]],[1,["_prefab","root"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],-407],[1,["_prefab","root"],[0,["8fB2KqVsFA34hfa5YNSBFN"]],-408],[2,33554432,["_layer"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[1,["_prefab","root"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]],-409],[1,["_prefab","root"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]],-410],[1,["_prefab","root"],[0,["48gYUavIlEYJ6hsANdKeLz"]],-411],[2,false,["_active"],[0,["3fhcJtThdOGYNclAn/Mt3A"]]],[1,["_prefab","root"],[0,["3fhcJtThdOGYNclAn/Mt3A"]],-412],[1,["_prefab","root"],[0,["dedf+aCxZF77OsFDi/56cm"]],-413],[1,["_prefab","root"],[0,["e7gBmpnClIS6TpcmeFDzo0"]],-414],[2,true,["_active"],[0,["ceNHw/FUVMUI9bK/S/Qhc+"]]],[1,["_prefab","root"],[0,["ceNHw/FUVMUI9bK/S/Qhc+"]],-415],[1,["_prefab","root"],[0,["17u/aYQXxBtKWzwD0FZw6x"]],-416]]],75]],[25,[11,"4bx2KLlcRC1L/+yriAjeZU",-428,[12,"d6xjbtOXxA5alX9x9d9eex",2,[[14,[null],[0,["4bx2KLlcRC1L/+yriAjeZU"]]]],[[2,"Card1",["_name"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[6,["_lpos"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[1,-60,210,0]],[6,["_lrot"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[3,0,0,0,1]],[1,["_prefab","root"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],-418],[1,["_prefab","root"],[0,["8fB2KqVsFA34hfa5YNSBFN"]],-419],[2,false,["_locked"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,2,["_level"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,3,["_star"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,33554432,["_layer"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[1,["_prefab","root"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]],-420],[1,["_prefab","root"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]],-421],[1,["_prefab","root"],[0,["48gYUavIlEYJ6hsANdKeLz"]],-422],[1,["_prefab","root"],[0,["3fhcJtThdOGYNclAn/Mt3A"]],-423],[2,true,["_active"],[0,["dedf+aCxZF77OsFDi/56cm"]]],[1,["_prefab","root"],[0,["dedf+aCxZF77OsFDi/56cm"]],-424],[1,["_prefab","root"],[0,["e7gBmpnClIS6TpcmeFDzo0"]],-425],[1,["_prefab","root"],[0,["ceNHw/FUVMUI9bK/S/Qhc+"]],-426],[2,false,["_active"],[0,["17u/aYQXxBtKWzwD0FZw6x"]]],[1,["_prefab","root"],[0,["17u/aYQXxBtKWzwD0FZw6x"]],-427]]],76]],[25,[11,"4bx2KLlcRC1L/+yriAjeZU",-439,[12,"44c9aM4kdGapJ4wnNw0Ivr",2,[[14,[null],[0,["4bx2KLlcRC1L/+yriAjeZU"]]]],[[2,"Card2",["_name"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[6,["_lpos"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[1,60,210,0]],[6,["_lrot"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[3,0,0,0,1]],[1,["_prefab","root"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],-429],[1,["_prefab","root"],[0,["8fB2KqVsFA34hfa5YNSBFN"]],-430],[2,false,["_locked"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,3,["_level"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,2,["_star"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,33554432,["_layer"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[1,["_prefab","root"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]],-431],[1,["_prefab","root"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]],-432],[1,["_prefab","root"],[0,["48gYUavIlEYJ6hsANdKeLz"]],-433],[1,["_prefab","root"],[0,["3fhcJtThdOGYNclAn/Mt3A"]],-434],[1,["_prefab","root"],[0,["dedf+aCxZF77OsFDi/56cm"]],-435],[1,["_prefab","root"],[0,["e7gBmpnClIS6TpcmeFDzo0"]],-436],[1,["_prefab","root"],[0,["ceNHw/FUVMUI9bK/S/Qhc+"]],-437],[1,["_prefab","root"],[0,["17u/aYQXxBtKWzwD0FZw6x"]],-438]]],77]],[25,[11,"4bx2KLlcRC1L/+yriAjeZU",-450,[12,"f6FsL6VTNHlYvuRvWEg/JT",2,[[14,[null],[0,["4bx2KLlcRC1L/+yriAjeZU"]]]],[[2,"Card3",["_name"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[6,["_lpos"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[1,180,210,0]],[6,["_lrot"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[3,0,0,0,1]],[1,["_prefab","root"],[0,["8fB2KqVsFA34hfa5YNSBFN"]],-440],[1,["_prefab","root"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],-441],[2,false,["_locked"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,4,["_level"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,2,["_star"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,33554432,["_layer"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[1,["_prefab","root"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]],-442],[1,["_prefab","root"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]],-443],[1,["_prefab","root"],[0,["48gYUavIlEYJ6hsANdKeLz"]],-444],[1,["_prefab","root"],[0,["3fhcJtThdOGYNclAn/Mt3A"]],-445],[1,["_prefab","root"],[0,["dedf+aCxZF77OsFDi/56cm"]],-446],[1,["_prefab","root"],[0,["e7gBmpnClIS6TpcmeFDzo0"]],-447],[1,["_prefab","root"],[0,["ceNHw/FUVMUI9bK/S/Qhc+"]],-448],[1,["_prefab","root"],[0,["17u/aYQXxBtKWzwD0FZw6x"]],-449]]],78]],[25,[11,"4bx2KLlcRC1L/+yriAjeZU",-461,[12,"96GtoVFeFJnaBR5asUFypE",2,[[14,[null],[0,["4bx2KLlcRC1L/+yriAjeZU"]]]],[[2,"Card4",["_name"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[6,["_lpos"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[1,-180,70,0]],[6,["_lrot"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[3,0,0,0,1]],[1,["_prefab","root"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],-451],[1,["_prefab","root"],[0,["8fB2KqVsFA34hfa5YNSBFN"]],-452],[2,true,["_locked"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,5,["_level"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,33554432,["_layer"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[2,false,["_active"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]]],[1,["_prefab","root"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]],-453],[2,true,["_active"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]]],[1,["_prefab","root"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]],-454],[2,false,["_active"],[0,["48gYUavIlEYJ6hsANdKeLz"]]],[1,["_prefab","root"],[0,["48gYUavIlEYJ6hsANdKeLz"]],-455],[2,false,["_active"],[0,["3fhcJtThdOGYNclAn/Mt3A"]]],[1,["_prefab","root"],[0,["3fhcJtThdOGYNclAn/Mt3A"]],-456],[1,["_prefab","root"],[0,["dedf+aCxZF77OsFDi/56cm"]],-457],[1,["_prefab","root"],[0,["e7gBmpnClIS6TpcmeFDzo0"]],-458],[1,["_prefab","root"],[0,["ceNHw/FUVMUI9bK/S/Qhc+"]],-459],[2,false,["_active"],[0,["17u/aYQXxBtKWzwD0FZw6x"]]],[1,["_prefab","root"],[0,["17u/aYQXxBtKWzwD0FZw6x"]],-460]]],79]],[25,[11,"4bx2KLlcRC1L/+yriAjeZU",-472,[12,"6dwFI5k3dJZ5wystvCT/By",2,[[14,[null],[0,["4bx2KLlcRC1L/+yriAjeZU"]]]],[[2,"Card5",["_name"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[6,["_lpos"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[1,-60,70,0]],[6,["_lrot"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[3,0,0,0,1]],[1,["_prefab","root"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],-462],[1,["_prefab","root"],[0,["8fB2KqVsFA34hfa5YNSBFN"]],-463],[2,true,["_locked"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,6,["_level"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,33554432,["_layer"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[2,false,["_active"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]]],[1,["_prefab","root"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]],-464],[2,true,["_active"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]]],[1,["_prefab","root"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]],-465],[2,false,["_active"],[0,["48gYUavIlEYJ6hsANdKeLz"]]],[1,["_prefab","root"],[0,["48gYUavIlEYJ6hsANdKeLz"]],-466],[2,false,["_active"],[0,["3fhcJtThdOGYNclAn/Mt3A"]]],[1,["_prefab","root"],[0,["3fhcJtThdOGYNclAn/Mt3A"]],-467],[1,["_prefab","root"],[0,["dedf+aCxZF77OsFDi/56cm"]],-468],[1,["_prefab","root"],[0,["e7gBmpnClIS6TpcmeFDzo0"]],-469],[1,["_prefab","root"],[0,["ceNHw/FUVMUI9bK/S/Qhc+"]],-470],[2,false,["_active"],[0,["17u/aYQXxBtKWzwD0FZw6x"]]],[1,["_prefab","root"],[0,["17u/aYQXxBtKWzwD0FZw6x"]],-471]]],80]],[25,[11,"4bx2KLlcRC1L/+yriAjeZU",-483,[12,"a1FKfeDZJB9IaxO5IWrqsS",2,[[14,[null],[0,["4bx2KLlcRC1L/+yriAjeZU"]]]],[[2,"Card6",["_name"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[6,["_lpos"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[1,60,70,0]],[6,["_lrot"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[3,0,0,0,1]],[1,["_prefab","root"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],-473],[1,["_prefab","root"],[0,["8fB2KqVsFA34hfa5YNSBFN"]],-474],[2,true,["_locked"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,7,["_level"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,33554432,["_layer"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[2,false,["_active"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]]],[1,["_prefab","root"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]],-475],[2,true,["_active"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]]],[1,["_prefab","root"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]],-476],[2,false,["_active"],[0,["48gYUavIlEYJ6hsANdKeLz"]]],[1,["_prefab","root"],[0,["48gYUavIlEYJ6hsANdKeLz"]],-477],[2,false,["_active"],[0,["3fhcJtThdOGYNclAn/Mt3A"]]],[1,["_prefab","root"],[0,["3fhcJtThdOGYNclAn/Mt3A"]],-478],[1,["_prefab","root"],[0,["dedf+aCxZF77OsFDi/56cm"]],-479],[1,["_prefab","root"],[0,["e7gBmpnClIS6TpcmeFDzo0"]],-480],[1,["_prefab","root"],[0,["ceNHw/FUVMUI9bK/S/Qhc+"]],-481],[2,false,["_active"],[0,["17u/aYQXxBtKWzwD0FZw6x"]]],[1,["_prefab","root"],[0,["17u/aYQXxBtKWzwD0FZw6x"]],-482]]],81]],[25,[11,"4bx2KLlcRC1L/+yriAjeZU",-494,[12,"dcfXL6Nr1MQoHSe1cXBV0G",2,[[14,[null],[0,["4bx2KLlcRC1L/+yriAjeZU"]]]],[[2,"Card7",["_name"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[6,["_lpos"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[1,180,70,0]],[6,["_lrot"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[3,0,0,0,1]],[1,["_prefab","root"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],-484],[1,["_prefab","root"],[0,["8fB2KqVsFA34hfa5YNSBFN"]],-485],[2,true,["_locked"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,8,["_level"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,33554432,["_layer"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[2,false,["_active"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]]],[1,["_prefab","root"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]],-486],[2,true,["_active"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]]],[1,["_prefab","root"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]],-487],[2,false,["_active"],[0,["48gYUavIlEYJ6hsANdKeLz"]]],[1,["_prefab","root"],[0,["48gYUavIlEYJ6hsANdKeLz"]],-488],[2,false,["_active"],[0,["3fhcJtThdOGYNclAn/Mt3A"]]],[1,["_prefab","root"],[0,["3fhcJtThdOGYNclAn/Mt3A"]],-489],[1,["_prefab","root"],[0,["dedf+aCxZF77OsFDi/56cm"]],-490],[1,["_prefab","root"],[0,["e7gBmpnClIS6TpcmeFDzo0"]],-491],[1,["_prefab","root"],[0,["ceNHw/FUVMUI9bK/S/Qhc+"]],-492],[2,false,["_active"],[0,["17u/aYQXxBtKWzwD0FZw6x"]]],[1,["_prefab","root"],[0,["17u/aYQXxBtKWzwD0FZw6x"]],-493]]],82]],[25,[11,"4bx2KLlcRC1L/+yriAjeZU",-505,[12,"70aaMr1VdGrL6RduYvbHeY",2,[[14,[null],[0,["4bx2KLlcRC1L/+yriAjeZU"]]]],[[2,"Card9",["_name"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[6,["_lpos"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[1,-60,-70,0]],[6,["_lrot"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[3,0,0,0,1]],[1,["_prefab","root"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],-495],[1,["_prefab","root"],[0,["8fB2KqVsFA34hfa5YNSBFN"]],-496],[2,true,["_locked"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,10,["_level"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,33554432,["_layer"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[2,false,["_active"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]]],[1,["_prefab","root"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]],-497],[2,true,["_active"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]]],[1,["_prefab","root"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]],-498],[2,false,["_active"],[0,["48gYUavIlEYJ6hsANdKeLz"]]],[1,["_prefab","root"],[0,["48gYUavIlEYJ6hsANdKeLz"]],-499],[2,false,["_active"],[0,["3fhcJtThdOGYNclAn/Mt3A"]]],[1,["_prefab","root"],[0,["3fhcJtThdOGYNclAn/Mt3A"]],-500],[1,["_prefab","root"],[0,["dedf+aCxZF77OsFDi/56cm"]],-501],[1,["_prefab","root"],[0,["e7gBmpnClIS6TpcmeFDzo0"]],-502],[1,["_prefab","root"],[0,["ceNHw/FUVMUI9bK/S/Qhc+"]],-503],[2,false,["_active"],[0,["17u/aYQXxBtKWzwD0FZw6x"]]],[1,["_prefab","root"],[0,["17u/aYQXxBtKWzwD0FZw6x"]],-504]]],83]],[25,[11,"4bx2KLlcRC1L/+yriAjeZU",-516,[12,"d6wKd9mWpBjYJs1ES2ekhT",2,[[14,[null],[0,["4bx2KLlcRC1L/+yriAjeZU"]]]],[[2,"Card10",["_name"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[6,["_lpos"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[1,60,-70,0]],[6,["_lrot"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[3,0,0,0,1]],[1,["_prefab","root"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],-506],[1,["_prefab","root"],[0,["8fB2KqVsFA34hfa5YNSBFN"]],-507],[2,true,["_locked"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,11,["_level"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,33554432,["_layer"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[2,false,["_active"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]]],[1,["_prefab","root"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]],-508],[2,true,["_active"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]]],[1,["_prefab","root"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]],-509],[2,false,["_active"],[0,["48gYUavIlEYJ6hsANdKeLz"]]],[1,["_prefab","root"],[0,["48gYUavIlEYJ6hsANdKeLz"]],-510],[2,false,["_active"],[0,["3fhcJtThdOGYNclAn/Mt3A"]]],[1,["_prefab","root"],[0,["3fhcJtThdOGYNclAn/Mt3A"]],-511],[1,["_prefab","root"],[0,["dedf+aCxZF77OsFDi/56cm"]],-512],[1,["_prefab","root"],[0,["e7gBmpnClIS6TpcmeFDzo0"]],-513],[1,["_prefab","root"],[0,["ceNHw/FUVMUI9bK/S/Qhc+"]],-514],[2,false,["_active"],[0,["17u/aYQXxBtKWzwD0FZw6x"]]],[1,["_prefab","root"],[0,["17u/aYQXxBtKWzwD0FZw6x"]],-515]]],84]],[25,[11,"4bx2KLlcRC1L/+yriAjeZU",-527,[12,"c5EpSL/21HHbfTDe1MxE79",2,[[14,[null],[0,["4bx2KLlcRC1L/+yriAjeZU"]]]],[[2,"Card11",["_name"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[6,["_lpos"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[1,180,-70,0]],[6,["_lrot"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[3,0,0,0,1]],[1,["_prefab","root"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],-517],[1,["_prefab","root"],[0,["8fB2KqVsFA34hfa5YNSBFN"]],-518],[2,true,["_locked"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,12,["_level"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,33554432,["_layer"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[2,false,["_active"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]]],[1,["_prefab","root"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]],-519],[2,true,["_active"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]]],[1,["_prefab","root"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]],-520],[2,false,["_active"],[0,["48gYUavIlEYJ6hsANdKeLz"]]],[1,["_prefab","root"],[0,["48gYUavIlEYJ6hsANdKeLz"]],-521],[2,false,["_active"],[0,["3fhcJtThdOGYNclAn/Mt3A"]]],[1,["_prefab","root"],[0,["3fhcJtThdOGYNclAn/Mt3A"]],-522],[1,["_prefab","root"],[0,["dedf+aCxZF77OsFDi/56cm"]],-523],[1,["_prefab","root"],[0,["e7gBmpnClIS6TpcmeFDzo0"]],-524],[1,["_prefab","root"],[0,["ceNHw/FUVMUI9bK/S/Qhc+"]],-525],[2,false,["_active"],[0,["17u/aYQXxBtKWzwD0FZw6x"]]],[1,["_prefab","root"],[0,["17u/aYQXxBtKWzwD0FZw6x"]],-526]]],85]],[25,[11,"4bx2KLlcRC1L/+yriAjeZU",-538,[12,"61TrRFN0dCtbFDajsDiHVw",2,[[14,[null],[0,["4bx2KLlcRC1L/+yriAjeZU"]]]],[[2,"Card12",["_name"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[6,["_lpos"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[1,-180,-210,0]],[6,["_lrot"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[3,0,0,0,1]],[1,["_prefab","root"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],-528],[1,["_prefab","root"],[0,["8fB2KqVsFA34hfa5YNSBFN"]],-529],[2,true,["_locked"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,13,["_level"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,33554432,["_layer"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[2,false,["_active"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]]],[1,["_prefab","root"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]],-530],[2,true,["_active"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]]],[1,["_prefab","root"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]],-531],[2,false,["_active"],[0,["48gYUavIlEYJ6hsANdKeLz"]]],[1,["_prefab","root"],[0,["48gYUavIlEYJ6hsANdKeLz"]],-532],[2,false,["_active"],[0,["3fhcJtThdOGYNclAn/Mt3A"]]],[1,["_prefab","root"],[0,["3fhcJtThdOGYNclAn/Mt3A"]],-533],[1,["_prefab","root"],[0,["dedf+aCxZF77OsFDi/56cm"]],-534],[1,["_prefab","root"],[0,["e7gBmpnClIS6TpcmeFDzo0"]],-535],[1,["_prefab","root"],[0,["ceNHw/FUVMUI9bK/S/Qhc+"]],-536],[2,false,["_active"],[0,["17u/aYQXxBtKWzwD0FZw6x"]]],[1,["_prefab","root"],[0,["17u/aYQXxBtKWzwD0FZw6x"]],-537]]],86]],[25,[11,"4bx2KLlcRC1L/+yriAjeZU",-549,[12,"07JLlQNkVAEq0tQxSuPv2z",2,[[14,[null],[0,["4bx2KLlcRC1L/+yriAjeZU"]]]],[[2,"Card13",["_name"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[6,["_lpos"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[1,-60,-210,0]],[6,["_lrot"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[3,0,0,0,1]],[1,["_prefab","root"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],-539],[1,["_prefab","root"],[0,["8fB2KqVsFA34hfa5YNSBFN"]],-540],[2,true,["_locked"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,14,["_level"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,33554432,["_layer"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[2,false,["_active"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]]],[1,["_prefab","root"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]],-541],[2,true,["_active"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]]],[1,["_prefab","root"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]],-542],[2,false,["_active"],[0,["48gYUavIlEYJ6hsANdKeLz"]]],[1,["_prefab","root"],[0,["48gYUavIlEYJ6hsANdKeLz"]],-543],[2,false,["_active"],[0,["3fhcJtThdOGYNclAn/Mt3A"]]],[1,["_prefab","root"],[0,["3fhcJtThdOGYNclAn/Mt3A"]],-544],[1,["_prefab","root"],[0,["dedf+aCxZF77OsFDi/56cm"]],-545],[1,["_prefab","root"],[0,["e7gBmpnClIS6TpcmeFDzo0"]],-546],[1,["_prefab","root"],[0,["ceNHw/FUVMUI9bK/S/Qhc+"]],-547],[2,false,["_active"],[0,["17u/aYQXxBtKWzwD0FZw6x"]]],[1,["_prefab","root"],[0,["17u/aYQXxBtKWzwD0FZw6x"]],-548]]],87]],[25,[11,"4bx2KLlcRC1L/+yriAjeZU",-560,[12,"20Gsq33o1PHbeOnfMxLKjI",2,[[14,[null],[0,["4bx2KLlcRC1L/+yriAjeZU"]]]],[[2,"Card14",["_name"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[6,["_lpos"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[1,60,-210,0]],[6,["_lrot"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[3,0,0,0,1]],[1,["_prefab","root"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],-550],[1,["_prefab","root"],[0,["8fB2KqVsFA34hfa5YNSBFN"]],-551],[2,true,["_locked"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,15,["_level"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,33554432,["_layer"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[2,false,["_active"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]]],[1,["_prefab","root"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]],-552],[2,true,["_active"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]]],[1,["_prefab","root"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]],-553],[2,false,["_active"],[0,["48gYUavIlEYJ6hsANdKeLz"]]],[1,["_prefab","root"],[0,["48gYUavIlEYJ6hsANdKeLz"]],-554],[2,false,["_active"],[0,["3fhcJtThdOGYNclAn/Mt3A"]]],[1,["_prefab","root"],[0,["3fhcJtThdOGYNclAn/Mt3A"]],-555],[1,["_prefab","root"],[0,["dedf+aCxZF77OsFDi/56cm"]],-556],[1,["_prefab","root"],[0,["e7gBmpnClIS6TpcmeFDzo0"]],-557],[1,["_prefab","root"],[0,["ceNHw/FUVMUI9bK/S/Qhc+"]],-558],[2,false,["_active"],[0,["17u/aYQXxBtKWzwD0FZw6x"]]],[1,["_prefab","root"],[0,["17u/aYQXxBtKWzwD0FZw6x"]],-559]]],88]],[25,[11,"4bx2KLlcRC1L/+yriAjeZU",-571,[12,"e8iejSF2tHxLwaw5WTJ7Mk",2,[[14,[null],[0,["4bx2KLlcRC1L/+yriAjeZU"]]]],[[2,"Card15",["_name"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[6,["_lpos"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[1,180,-210,0]],[6,["_lrot"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],[3,0,0,0,1]],[1,["_prefab","root"],[0,["4bx2KLlcRC1L/+yriAjeZU"]],-561],[1,["_prefab","root"],[0,["8fB2KqVsFA34hfa5YNSBFN"]],-562],[2,true,["_locked"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,16,["_level"],[0,["5dZVcLb/ZPSaizo68i/Qud"]]],[2,33554432,["_layer"],[0,["4bx2KLlcRC1L/+yriAjeZU"]]],[2,false,["_active"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]]],[1,["_prefab","root"],[0,["ae1+2QlBdBv5/UP0Kni8SS"]],-563],[2,true,["_active"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]]],[1,["_prefab","root"],[0,["82Pw5FYKZJIr0nT+7wZDoD"]],-564],[2,false,["_active"],[0,["48gYUavIlEYJ6hsANdKeLz"]]],[1,["_prefab","root"],[0,["48gYUavIlEYJ6hsANdKeLz"]],-565],[2,false,["_active"],[0,["3fhcJtThdOGYNclAn/Mt3A"]]],[1,["_prefab","root"],[0,["3fhcJtThdOGYNclAn/Mt3A"]],-566],[1,["_prefab","root"],[0,["dedf+aCxZF77OsFDi/56cm"]],-567],[1,["_prefab","root"],[0,["e7gBmpnClIS6TpcmeFDzo0"]],-568],[1,["_prefab","root"],[0,["ceNHw/FUVMUI9bK/S/Qhc+"]],-569],[2,false,["_active"],[0,["17u/aYQXxBtKWzwD0FZw6x"]]],[1,["_prefab","root"],[0,["17u/aYQXxBtKWzwD0FZw6x"]],-570]]],89]],[97,"Card",33554432,[-576,-577,-578,-579,-580,-581,-582,-583,-584],[[[54,-572,[4,"cc1bMkEH9PJbue0PEG4zEA"]],-573,[102,12,32.295999999999964,100,-574],[78,-575,[[9,"b94f1KxG3pL+oc2v4/C0XXe","onShowMenuClicked",1]]]],4,1,4,4],[1,-397.70400000000006,-170,0]],[0,["3c4Emiz61Nm6ODbDxrzmkA","4bx2KLlcRC1L/+yriAjeZU"]],[0,["d6xjbtOXxA5alX9x9d9eex","4bx2KLlcRC1L/+yriAjeZU"]],[0,["44c9aM4kdGapJ4wnNw0Ivr","4bx2KLlcRC1L/+yriAjeZU"]],[0,["f6FsL6VTNHlYvuRvWEg/JT","4bx2KLlcRC1L/+yriAjeZU"]],[0,["96GtoVFeFJnaBR5asUFypE","4bx2KLlcRC1L/+yriAjeZU"]],[0,["6dwFI5k3dJZ5wystvCT/By","4bx2KLlcRC1L/+yriAjeZU"]],[0,["a1FKfeDZJB9IaxO5IWrqsS","4bx2KLlcRC1L/+yriAjeZU"]],[0,["dcfXL6Nr1MQoHSe1cXBV0G","4bx2KLlcRC1L/+yriAjeZU"]],[0,["70aaMr1VdGrL6RduYvbHeY","4bx2KLlcRC1L/+yriAjeZU"]],[0,["d6wKd9mWpBjYJs1ES2ekhT","4bx2KLlcRC1L/+yriAjeZU"]],[0,["c5EpSL/21HHbfTDe1MxE79","4bx2KLlcRC1L/+yriAjeZU"]],[0,["61TrRFN0dCtbFDajsDiHVw","4bx2KLlcRC1L/+yriAjeZU"]],[0,["07JLlQNkVAEq0tQxSuPv2z","4bx2KLlcRC1L/+yriAjeZU"]],[0,["20Gsq33o1PHbeOnfMxLKjI","4bx2KLlcRC1L/+yriAjeZU"]],[0,["e8iejSF2tHxLwaw5WTJ7Mk","4bx2KLlcRC1L/+yriAjeZU"]],[21,1,[11,"26LvC5hbxAuJZ9Jl2SB/IV",-641,[108,"cdNOYl3LRPhapW8a8hi/Iy",null,[[116,[0,["068WXOAs1HrIDx+RBQ6XoV"]],[-640]]],[[41,["lightmapSettings"],-585,[7]],[41,["lightmapSettings"],-586,[7]],[6,["position"],[0,["fd517lz3tOuqVWGd5300X6"]],[1,-1.341,0.805,-2.555]],[34,["lightmapSettings"],[0,["a5Viy6l3VLDpf6gY5yZF+v"]],[7]],[8,0,["_shadowCastingMode"],-587],[41,["lightmapSettings"],-588,[7]],[41,["lightmapSettings"],-589,[7]],[41,["lightmapSettings"],-590,[7]],[41,["lightmapSettings"],-591,[7]],[41,["lightmapSettings"],-592,[7]],[41,["lightmapSettings"],-593,[7]],[41,["lightmapSettings"],-594,[7]],[1,["_prefab","root"],[0,["26LvC5hbxAuJZ9Jl2SB/IV"]],-595],[6,["_lpos"],[0,["26LvC5hbxAuJZ9Jl2SB/IV"]],[1,0,-1.744,-1.95]],[6,["_lrot"],[0,["26LvC5hbxAuJZ9Jl2SB/IV"]],[3,0,0,0,1]],[13,["_euler"],-596,[1,0,0,0]],[13,["_lscale"],-597,[1,1,1,1]],[3,["_prefab","root"],-599,-598],[13,["_lscale"],-600,[1,2,2,2]],[3,["_prefab","root"],-602,-601],[13,["_lscale"],-603,[1,2,2,2]],[3,["_prefab","root"],-605,-604],[13,["_lscale"],-606,[1,2,2,2]],[3,["_prefab","root"],-608,-607],[13,["_lscale"],-609,[1,2,2,2]],[3,["_prefab","root"],-611,-610],[13,["_lscale"],-612,[1,2,2,2]],[3,["_prefab","root"],-614,-613],[13,["_lscale"],-615,[1,2,2,2]],[3,["_prefab","root"],-617,-616],[13,["_lscale"],-618,[1,2,2,2]],[3,["_prefab","root"],-620,-619],[13,["_lscale"],-621,[1,2,2,2]],[8,0,["_shadowReceivingMode"],-622],[8,0,["_shadowCastingMode"],-623],[8,0,["_shadowReceivingMode"],-624],[8,0,["_shadowReceivingMode"],-625],[8,0,["_shadowCastingMode"],-626],[8,0,["_shadowCastingMode"],-627],[8,0,["_shadowCastingMode"],-628],[8,0,["_shadowCastingMode"],-629],[8,0,["_shadowCastingMode"],-630],[8,0,["_shadowCastingMode"],-631],[8,0,["_shadowCastingMode"],-632],[8,0,["_shadowReceivingMode"],-633],[8,0,["_shadowReceivingMode"],-634],[8,0,["_shadowReceivingMode"],-635],[8,0,["_shadowReceivingMode"],-636],[8,0,["_shadowReceivingMode"],-637],[8,0,["_shadowReceivingMode"],-638],[8,0,["_shadowReceivingMode"],-639]]],0]],[89,"Canvas",33554432,"bfcXCSjT1DnIdtd77ZIuSv",[-646,-647,-648,-649,18,2,-650],[[10,-642,[4,"0dngp/9gNO34wUQjZfN/CX"],[5,960,640]],[117,-644,[4,"3f2oTdCepERZdpmIfLsrhd"],-643],[55,45,-645,[4,"e8a+bU/8dPDbbJguUzLdoF"]]],[1,480,320,0]],[26,"ball-0",1,[[28,"Sphere<ModelComponent>",1,-651,[4,"492SVdw3ZPdre+amT+eLU6"],[10],[27,true,true],11],[29,-652,12],[30,-653],[119,-654],[31,-655,[[9,"b94f1KxG3pL+oc2v4/C0XXe","onBallDroped",1]],[[9,"b94f1KxG3pL+oc2v4/C0XXe","onBallSleeping",1]]]],[1,0.08,0.08,0.08]],[21,1,[11,"82KF56FIRaHbGBpMUksA/v",-677,[109,"ebVguMScJAaLQFkH/cuD/y",null,[[22,[0,["dfn3nYpfBdc5ZR008f/Iuq"]],[[82,5,6],[81,2]]],[22,[0,["aevtN1k6pYuoB+2b37w97j"]],[[81,2],[82,7,8]]]],[[2,"desk",["_name"],[0,["82KF56FIRaHbGBpMUksA/v"]]],[6,["_lpos"],[0,["82KF56FIRaHbGBpMUksA/v"]],[1,0,0,0]],[6,["_lrot"],[0,["82KF56FIRaHbGBpMUksA/v"]],[3,0,0,0,1]],[1,["_prefab","root"],[0,["82KF56FIRaHbGBpMUksA/v"]],-656],[6,["_lscale"],[0,["82KF56FIRaHbGBpMUksA/v"]],[1,100,100,100]],[6,["_euler"],[0,["82KF56FIRaHbGBpMUksA/v"]],[1,0,0,0]],[2,true,["_active"],[0,["dfn3nYpfBdc5ZR008f/Iuq"]]],[3,["_prefab","root"],-658,-657],[2,true,["_active"],[0,["aevtN1k6pYuoB+2b37w97j"]]],[3,["_prefab","root"],-660,-659],[3,["_prefab","root"],-662,-661],[13,["_lrot"],-663,[3,0,0,0,1]],[13,["_euler"],-664,[1,0,0,0]],[13,["_lrot"],-665,[3,0,0,0,1]],[13,["_euler"],-666,[1,0,0,0]],[13,["_lrot"],-667,[3,0,0,0,1]],[13,["_euler"],-668,[1,0,0,0]],[13,["_lscale"],-669,[1,1,1,1]],[13,["_lscale"],-670,[1,1,1,1]],[13,["_lscale"],-671,[1,1,1,1]],[112,["_materials","0"],[0,["aepFlFN6BcgLlpGrFS2TZB"]],9],[8,true,["lightmapSettings","_receiveShadow"],-672],[8,1,["_shadowReceivingMode"],-673],[8,true,["lightmapSettings","_receiveShadow"],-674],[8,false,["lightmapSettings","_castShadow"],-675],[8,0,["_shadowCastingMode"],-676]]],4]],[26,"ball-1",1,[[28,"Sphere<ModelComponent>",1,-678,[4,"492SVdw3ZPdre+amT+eLU6"],[13],[27,true,true],14],[29,-679,15],[30,-680],[31,-681,[[9,"b94f1KxG3pL+oc2v4/C0XXe","onBallDroped",1]],[[9,"b94f1KxG3pL+oc2v4/C0XXe","onBallSleeping",1]]]],[1,0.08,0.08,0.08]],[26,"ball-2",1,[[28,"Sphere<ModelComponent>",1,-682,[4,"492SVdw3ZPdre+amT+eLU6"],[16],[27,true,true],17],[29,-683,18],[30,-684],[31,-685,[[9,"b94f1KxG3pL+oc2v4/C0XXe","onBallDroped",1]],[[9,"b94f1KxG3pL+oc2v4/C0XXe","onBallSleeping",1]]]],[1,0.08,0.08,0.08]],[26,"ball-3",1,[[28,"Sphere<ModelComponent>",1,-686,[4,"492SVdw3ZPdre+amT+eLU6"],[19],[27,true,true],20],[29,-687,21],[30,-688],[31,-689,[[9,"b94f1KxG3pL+oc2v4/C0XXe","onBallDroped",1]],[[9,"b94f1KxG3pL+oc2v4/C0XXe","onBallSleeping",1]]]],[1,0.08,0.08,0.08]],[26,"ball-4",1,[[28,"Sphere<ModelComponent>",1,-690,[4,"492SVdw3ZPdre+amT+eLU6"],[22],[27,true,true],23],[29,-691,24],[30,-692],[31,-693,[[9,"b94f1KxG3pL+oc2v4/C0XXe","onBallDroped",1]],[[9,"b94f1KxG3pL+oc2v4/C0XXe","onBallSleeping",1]]]],[1,0.08,0.08,0.08]],[26,"ball-5",1,[[28,"Sphere<ModelComponent>",1,-694,[4,"492SVdw3ZPdre+amT+eLU6"],[25],[27,true,true],26],[29,-695,27],[30,-696],[31,-697,[[9,"b94f1KxG3pL+oc2v4/C0XXe","onBallDroped",1]],[[9,"b94f1KxG3pL+oc2v4/C0XXe","onBallSleeping",1]]]],[1,0.08,0.08,0.08]],[26,"ball-6",1,[[28,"Sphere<ModelComponent>",1,-698,[4,"492SVdw3ZPdre+amT+eLU6"],[28],[27,true,true],29],[29,-699,30],[30,-700],[31,-701,[[9,"b94f1KxG3pL+oc2v4/C0XXe","onBallDroped",1]],[[9,"b94f1KxG3pL+oc2v4/C0XXe","onBallSleeping",1]]]],[1,0.08,0.08,0.08]],[26,"ball-7",1,[[28,"Sphere<ModelComponent>",1,-702,[4,"492SVdw3ZPdre+amT+eLU6"],[31],[27,true,true],32],[29,-703,33],[30,-704],[31,-705,[[9,"b94f1KxG3pL+oc2v4/C0XXe","onBallDroped",1]],[[9,"b94f1KxG3pL+oc2v4/C0XXe","onBallSleeping",1]]]],[1,0.08,0.08,0.08]],[26,"ball-8",1,[[28,"Sphere<ModelComponent>",1,-706,[4,"492SVdw3ZPdre+amT+eLU6"],[34],[27,true,true],35],[29,-707,36],[30,-708],[31,-709,[[9,"b94f1KxG3pL+oc2v4/C0XXe","onBallDroped",1]],[[9,"b94f1KxG3pL+oc2v4/C0XXe","onBallSleeping",1]]]],[1,0.08,0.08,0.08]],[26,"ball-9",1,[[28,"Sphere<ModelComponent>",1,-710,[4,"492SVdw3ZPdre+amT+eLU6"],[37],[27,true,true],38],[29,-711,39],[30,-712],[31,-713,[[9,"b94f1KxG3pL+oc2v4/C0XXe","onBallDroped",1]],[[9,"b94f1KxG3pL+oc2v4/C0XXe","onBallSleeping",1]]]],[1,0.08,0.08,0.08]],[26,"ball-10",1,[[28,"Sphere<ModelComponent>",1,-714,[4,"492SVdw3ZPdre+amT+eLU6"],[40],[27,true,true],41],[29,-715,42],[30,-716],[31,-717,[[9,"b94f1KxG3pL+oc2v4/C0XXe","onBallDroped",1]],[[9,"b94f1KxG3pL+oc2v4/C0XXe","onBallSleeping",1]]]],[1,0.08,0.08,0.08]],[26,"ball-11",1,[[28,"Sphere<ModelComponent>",1,-718,[4,"492SVdw3ZPdre+amT+eLU6"],[43],[27,true,true],44],[29,-719,45],[30,-720],[31,-721,[[9,"b94f1KxG3pL+oc2v4/C0XXe","onBallDroped",1]],[[9,"b94f1KxG3pL+oc2v4/C0XXe","onBallSleeping",1]]]],[1,0.08,0.08,0.08]],[26,"ball-12",1,[[28,"Sphere<ModelComponent>",1,-722,[4,"492SVdw3ZPdre+amT+eLU6"],[46],[27,true,true],47],[29,-723,48],[30,-724],[31,-725,[[9,"b94f1KxG3pL+oc2v4/C0XXe","onBallDroped",1]],[[9,"b94f1KxG3pL+oc2v4/C0XXe","onBallSleeping",1]]]],[1,0.08,0.08,0.08]],[26,"ball-13",1,[[28,"Sphere<ModelComponent>",1,-726,[4,"492SVdw3ZPdre+amT+eLU6"],[49],[27,true,true],50],[29,-727,51],[30,-728],[31,-729,[[9,"b94f1KxG3pL+oc2v4/C0XXe","onBallDroped",1]],[[9,"b94f1KxG3pL+oc2v4/C0XXe","onBallSleeping",1]]]],[1,0.08,0.08,0.08]],[26,"ball-14",1,[[28,"Sphere<ModelComponent>",1,-730,[4,"492SVdw3ZPdre+amT+eLU6"],[52],[27,true,true],53],[29,-731,54],[30,-732],[31,-733,[[9,"b94f1KxG3pL+oc2v4/C0XXe","onBallDroped",1]],[[9,"b94f1KxG3pL+oc2v4/C0XXe","onBallSleeping",1]]]],[1,0.08,0.08,0.08]],[26,"ball-15",1,[[28,"Sphere<ModelComponent>",1,-734,[4,"492SVdw3ZPdre+amT+eLU6"],[55],[27,true,true],56],[29,-735,57],[30,-736],[31,-737,[[9,"b94f1KxG3pL+oc2v4/C0XXe","onBallDroped",1]],[[9,"b94f1KxG3pL+oc2v4/C0XXe","onBallSleeping",1]]]],[1,0.08,0.08,0.08]],[90,"GuideLine",1,[-739,-740,-741,-742],[[120,-738,36,[38,39,40,41,42,43,44,45,46,47,48,49,50,51,52]]]],[121,1],[74,"DeskEventLayer",33554432,35,[[10,-743,[4,"15MbuX4VNHPLpqzglWCixn"],[5,960,640]],[46,45,100,100,-744,[4,"2ac45cT6BHwqitY1b17iCp"]],[78,-745,[[9,"b94f1KxG3pL+oc2v4/C0XXe","onClicked",1]]]]],[21,35,[11,"a7SF/JI0ZJc6sVsZK13Ggt",-758,[65,"4bbD+/7rxJbZfcX5nGMHJm",[[8,"GanController",["_name"],-746],[13,["_lpos"],-747,[1,398.035,180,0]],[13,["_lrot"],-748,[3,0,0,0,1]],[1,["scene3D"],[0,["bf35sPrMVGk4YON/6DdSo8"]],54],[8,true,["_active"],-749],[3,["_prefab","root"],-751,-750],[1,["_prefab","root"],[0,["cfAnaKeadKX6vv6kYPjn6h"]],-752],[3,["onClickListeners","0","target"],-753,1],[8,"b94f1KxG3pL+oc2v4/C0XXe",["onClickListeners","0","_componentId"],-754],[8,"onAdjustHitPointButtonClicked",["onClickListeners","0","handler"],-755],[8,36,["_alignFlags"],-756],[8,100,["_bottom"],-757],[6,["_contentSize"],[0,["e46VsT6gdKyb5oga0gRWdM"]],[5,100,800]]]],72]],[0,["a7SF/JI0ZJc6sVsZK13Ggt"]],[0,["71g0nLrLpMhJ0RxJkOaKCl"]],[0,["dfn3nYpfBdc5ZR008f/Iuq"]],[0,["aevtN1k6pYuoB+2b37w97j"]],[0,["80ajeX8uhZMoFat4R3FDZ2"]],[21,35,[11,"9buk+ykyBPVIxOFR6QFQu/",-765,[65,"edoIgbpORMBplBtUWHoavB",[[8,"HitPointController",["_name"],-759],[13,["_lpos"],-760,[1,0,0,0]],[13,["_lrot"],-761,[3,0,0,0,1]],[1,["scene3D"],[0,["43Nw9gjf1J/6VdWVQ2SKtm"]],54],[3,["onClickListeners","0","target"],-762,1],[8,"b94f1KxG3pL+oc2v4/C0XXe",["onClickListeners","0","_componentId"],-763],[8,"onCloseAdjustHitPointButtonClicked",["onClickListeners","0","handler"],-764]]],73]],[21,35,[11,"fe5yLQ9CJEjoh+6wWgxGiw",-774,[65,"e1hm/+2E1GX6n2mvjI5V3D",[[8,"ResultLayer",["_name"],-766],[13,["_lpos"],-767,[1,0,0,0]],[13,["_lrot"],-768,[3,0,0,0,1]],[3,["onClickListeners","0","target"],-770,-769],[3,["onClickListeners","1","target"],-771,1],[8,"b94f1KxG3pL+oc2v4/C0XXe",["onClickListeners","1","_componentId"],-772],[8,"onResultConfirmed",["onClickListeners","1","handler"],-773]]],90]],[0,["71/GKkX+ROEqF6ZnyxU74Q"]],[53,"levelText",33554432,18,[[10,-775,[4,"4bf4SjaRxP4KcluNxRvaJw"],[5,22.25,50.4]],[63,"<color=#ffffff>4</color>",-776,[4,"b5LFduq8VJWo/DE4BRFmBn"]],[55,16,-777,[4,"89rmsQdPVIV7wnLx9kzr5y"]]],[1,0,16.647,0]],[122,"main",[1,35],[100,[[67,["menuLayer"],54,2,[0,["b06T1tCMxM/KtL8Bta7456"]]],[67,["resultLayer"],54,63,[0,["d1KhmWFFRNFozNvFN5G8gq"]]],[67,["adjustHitPointBall"],54,62,[0,["04CmHVH11JmoC2hNpofNXH"]]]]],[123,[124],[125,true,1,0.0035,true,0.1,50,10,[4,3271557120]],[126,true,99],[127]]],[75,"Main Camera",1,[[128,14,1820327937,-778],[130,false,-779]],[1,0.949,6.123,14.839],[3,-0.07236081996736557,0.03501809641207027,0.0025421739408711254,0.9967603433167774],[1,-8.304321541008004,4.024165472580301,9.93923337957349e-17]],[0,["e3XMjUJKFLH41z39JaWzyB"]],[0,["e4If/bQrJCsb9D9JopZa2h"]],[0,["d7Vkz0NV5Mn4RUce28JVTp"]],[0,["3eVATgLQJKDbqOvE33W2uc"]],[0,["2akU/MgO5Ovo6QcS0c/I7e"]],[0,["54xaKIQbtPLK5r21VY0qmM"]],[0,["23UFBqszxJ/6Otof04QwYT"]],[0,["c7PE6gNTdDw45ytwlOEWR3"]],[21,1,[11,"e5Peksu5tL9peMeABb8/JC",-784,[110,"7e4SH9jydKyaQjXZtS5AiQ",null,[[34,["lightmapSettings"],[0,["a6J1jU/r1BPKNIcVMEREit"]],[7]],[2,1,["_shadowReceivingMode"],[0,["a6J1jU/r1BPKNIcVMEREit"]]],[34,["lightmapSettings"],[0,["28WH2cvhNDFbN3it+8Q+XK"]],[7]],[2,1,["_shadowReceivingMode"],[0,["28WH2cvhNDFbN3it+8Q+XK"]]],[34,["lightmapSettings"],[0,["87exLhmM1P35jx6GLN7j5f"]],[7]],[2,1,["_shadowReceivingMode"],[0,["87exLhmM1P35jx6GLN7j5f"]]],[34,["lightmapSettings"],[0,["dduLonFhNK+q908BUlLM7f"]],[7]],[2,1,["_shadowCastingMode"],[0,["dduLonFhNK+q908BUlLM7f"]]],[2,1,["_shadowReceivingMode"],[0,["dduLonFhNK+q908BUlLM7f"]]],[34,["lightmapSettings"],[0,["af0f1GeGlKf5MvKMEuH8MJ"]],[7]],[2,1,["_shadowReceivingMode"],[0,["af0f1GeGlKf5MvKMEuH8MJ"]]],[34,["lightmapSettings"],[0,["e9BPt5G81CloUmA5IJNHIQ"]],[7]],[2,1,["_shadowReceivingMode"],[0,["e9BPt5G81CloUmA5IJNHIQ"]]],[34,["lightmapSettings"],[0,["7dt8ZZ5EBNDIxOgpt1XbGu"]],[7]],[2,1,["_shadowReceivingMode"],[0,["7dt8ZZ5EBNDIxOgpt1XbGu"]]],[34,["lightmapSettings"],[0,["c4Nekl9YtKUKupS0ASX7It"]],[7]],[2,1,["_shadowReceivingMode"],[0,["c4Nekl9YtKUKupS0ASX7It"]]],[34,["lightmapSettings"],[0,["b9cuhcVRxPvZTPHcAyE7eS"]],[7]],[2,1,["_shadowReceivingMode"],[0,["b9cuhcVRxPvZTPHcAyE7eS"]]],[34,["lightmapSettings"],[0,["f3T3OFBBJBYrGbPSQ+k7GJ"]],[7]],[2,1,["_shadowReceivingMode"],[0,["f3T3OFBBJBYrGbPSQ+k7GJ"]]],[34,["lightmapSettings"],[0,["d0A5LfhGhAfrDnBGJ3JzOe"]],[7]],[2,1,["_shadowReceivingMode"],[0,["d0A5LfhGhAfrDnBGJ3JzOe"]]],[34,["lightmapSettings"],[0,["161SEdWiFO/abXxUI8RkYk"]],[7]],[2,1,["_shadowReceivingMode"],[0,["161SEdWiFO/abXxUI8RkYk"]]],[1,["_prefab","root"],[0,["e5Peksu5tL9peMeABb8/JC"]],-780],[13,["_lpos"],-781,[1,0,-1.744,-1.95]],[13,["_lscale"],-782,[1,1,1,1]],[8,false,["_active"],-783]]],3]],[0,["e5Peksu5tL9peMeABb8/JC"]],[0,["19XVIfzb5UbZplLB+sJx9v"]],[59,"line-0",false,53,[-785,-786]],[59,"line-1",false,53,[-787,-788]],[59,"line-2",false,53,[-789,-790]],[0,["665E4hELtDg5uQBnEbLqSa"]],[0,["9buk+ykyBPVIxOFR6QFQu/"]],[0,["9evybn6z5Cvrlg3/H+Tl14"]],[0,["fe5yLQ9CJEjoh+6wWgxGiw"]],[74,"bgNormal",33554432,18,[[10,-791,[4,"f7NISe7HdAD68SLfhnddy8"],[5,85,104]],[15,-792,[4,"e71ctEmpxFC4KlSYRZNz/a"],91]]],[91,"bgLocked",false,33554432,18,[[10,-793,[4,"f7NISe7HdAD68SLfhnddy8"],[5,85,104]],[15,-794,[4,"e71ctEmpxFC4KlSYRZNz/a"],92]]],[53,"star0",33554432,18,[[10,-795,[4,"f7NISe7HdAD68SLfhnddy8"],[5,19,17]],[15,-796,[4,"e71ctEmpxFC4KlSYRZNz/a"],93]],[1,-23.621,-27.746,0]],[53,"star1",33554432,18,[[10,-797,[4,"f7NISe7HdAD68SLfhnddy8"],[5,19,17]],[15,-798,[4,"e71ctEmpxFC4KlSYRZNz/a"],94]],[1,1.28,-27.746,0]],[60,"star2",false,33554432,18,[[10,-799,[4,"f7NISe7HdAD68SLfhnddy8"],[5,19,17]],[15,-800,[4,"e71ctEmpxFC4KlSYRZNz/a"],95]],[1,25.895,-27.746,0]],[60,"star0Gray",false,33554432,18,[[10,-801,[4,"f7NISe7HdAD68SLfhnddy8"],[5,19,17]],[15,-802,[4,"e71ctEmpxFC4KlSYRZNz/a"],96]],[1,-23.621,-27.746,0]],[60,"star1Gray",false,33554432,18,[[10,-803,[4,"f7NISe7HdAD68SLfhnddy8"],[5,19,17]],[15,-804,[4,"e71ctEmpxFC4KlSYRZNz/a"],97]],[1,1.28,-27.746,0]],[53,"star2Gray",33554432,18,[[10,-805,[4,"f7NISe7HdAD68SLfhnddy8"],[5,19,17]],[15,-806,[4,"e71ctEmpxFC4KlSYRZNz/a"],98]],[1,25.895,-27.746,0]],[75,"Main Light",1,[[131,125000,-807,[132,true]]],[1,-1.647,4.284,4.363],[3,-0.4330127018922193,-0.4330127018922193,-0.24999999999999994,0.7500000000000001],[1,-60,-60,-7.951386703658792e-16]],[92,"stone2",false,[[118,0,-808,[1],[7],2]],[1,-1.342,0.615,5.502],[1,0.111417099833488,0.111417099833488,0.111417099833488],[1,0.000009334667642611398,0,0]],[0,["ddvMFij+ZIL5lu+/NQX8Nf"]],[0,["a5Viy6l3VLDpf6gY5yZF+v"]],[0,["26LvC5hbxAuJZ9Jl2SB/IV"]],[0,["1evO3wfhhGVomhJPkvbiM/"]],[0,["91DpAWXZ9CFJ+Wk1gnOU27"]],[0,["03YnQPZo5Nc7TYZfZ1EVIK"]],[0,["aehmnp6BdEt5duOREy07Ic"]],[0,["1dXVprqA1AkpKbrdcroE4U"]],[0,["c2n9MRvPxJRbv1PP2mhkZO"]],[0,["e7VpTFkQ1Ev40vpNxYe7EG"]],[0,["a1wQefYUNInYWhsOmPzInv"]],[0,["24cpP43h9a/IsUPkP+IZl3"]],[49,"guideline-model-true",79,[[48,"Cylinder<ModelComponent>",-809,[4,"b8R46AvAVAcJdQNHs3AvR2"],[58],[7],59]],[1,-0.5,0,0],[3,0.5,0.5,-0.4999999999999999,0.5000000000000001],[1,0.005,0.5,0.005],[1,90,90,0]],[49,"guideline-model-false",79,[[48,"Cylinder<ModelComponent>",-810,[4,"b8R46AvAVAcJdQNHs3AvR2"],[60],[7],61]],[1,-0.5,0,0],[3,0.5,0.5,-0.4999999999999999,0.5000000000000001],[1,0.005,0.5,0.005],[1,90,90,0]],[49,"guideline-model-true",80,[[48,"Cylinder<ModelComponent>",-811,[4,"b8R46AvAVAcJdQNHs3AvR2"],[62],[7],63]],[1,-0.5,0,0],[3,0.5,0.5,-0.4999999999999999,0.5000000000000001],[1,0.005,0.5,0.005],[1,90,90,0]],[49,"guideline-model-false",80,[[48,"Cylinder<ModelComponent>",-812,[4,"b8R46AvAVAcJdQNHs3AvR2"],[64],[7],65]],[1,-0.5,0,0],[3,0.5,0.5,-0.4999999999999999,0.5000000000000001],[1,0.005,0.5,0.005],[1,90,90,0]],[49,"guideline-model-true",81,[[48,"Cylinder<ModelComponent>",-813,[4,"b8R46AvAVAcJdQNHs3AvR2"],[66],[7],67]],[1,-0.5,0,0],[3,0.5,0.5,-0.4999999999999999,0.5000000000000001],[1,0.005,0.5,0.005],[1,90,90,0]],[49,"guideline-model-false",81,[[48,"Cylinder<ModelComponent>",-814,[4,"b8R46AvAVAcJdQNHs3AvR2"],[68],[7],69]],[1,-0.5,0,0],[3,0.5,0.5,-0.4999999999999999,0.5000000000000001],[1,0.005,0.5,0.005],[1,90,90,0]],[93,"ball",false,53,[[48,"Sphere<ModelComponent>",-815,[4,"492SVdw3ZPdre+amT+eLU6"],[70],[7],71]],[1,0,0.04,0],[1,0.08,0.08,0.08]],[62,18,[4,"5dZVcLb/ZPSaizo68i/Qud"]],[98,"Camera",35,[-816],[1,0,0,1000]],[129,0,1073741824,360.7578947368421,2000,6,41943040,116,[4,4278190080]],[0,["4aDCs87xBF2JZLcaIVpnFw"]]],0,[0,-1,54,0,-1,94,0,-2,67,0,-3,34,0,-4,76,0,-5,37,0,-6,36,0,-7,38,0,-8,39,0,-9,40,0,-10,41,0,-11,42,0,-12,43,0,-13,44,0,-14,45,0,-15,46,0,-16,47,0,-17,48,0,-18,49,0,-19,50,0,-20,51,0,-21,52,0,-22,53,0,1,58,0,1,58,0,1,58,0,1,58,0,0,2,0,1,58,0,0,3,0,1,19,0,0,2,0,1,19,0,0,3,0,1,19,0,0,3,0,1,19,0,0,3,0,1,19,0,0,3,0,1,19,0,0,3,0,1,19,0,0,3,0,1,19,0,0,3,0,1,19,0,0,3,0,1,19,0,0,3,0,1,19,0,0,3,0,1,19,0,0,4,0,1,20,0,0,2,0,1,20,0,0,4,0,1,20,0,0,4,0,1,20,0,0,4,0,1,20,0,0,4,0,1,20,0,0,4,0,1,20,0,0,4,0,1,20,0,0,4,0,1,20,0,0,4,0,1,20,0,0,4,0,1,20,0,0,4,0,1,20,0,0,5,0,1,21,0,0,2,0,1,21,0,0,5,0,1,21,0,0,5,0,1,21,0,0,5,0,1,21,0,0,5,0,1,21,0,0,5,0,1,21,0,0,5,0,1,21,0,0,5,0,1,21,0,0,5,0,1,21,0,0,5,0,1,21,0,0,5,0,1,21,0,0,6,0,1,22,0,0,2,0,1,22,0,0,6,0,1,22,0,0,6,0,1,22,0,0,6,0,1,22,0,0,6,0,1,22,0,0,6,0,1,22,0,0,6,0,1,22,0,0,6,0,1,22,0,0,6,0,1,22,0,0,6,0,1,22,0,0,6,0,1,22,0,0,7,0,1,23,0,0,2,0,1,23,0,0,7,0,1,23,0,0,7,0,1,23,0,0,7,0,1,23,0,0,7,0,1,23,0,0,7,0,1,23,0,0,7,0,1,23,0,0,7,0,1,23,0,0,7,0,1,23,0,0,7,0,1,23,0,0,7,0,1,23,0,0,8,0,1,24,0,0,2,0,1,24,0,0,8,0,1,24,0,0,8,0,1,24,0,0,8,0,1,24,0,0,8,0,1,24,0,0,8,0,1,24,0,0,8,0,1,24,0,0,8,0,1,24,0,0,8,0,1,24,0,0,8,0,1,24,0,0,8,0,1,24,0,0,9,0,1,25,0,0,2,0,1,25,0,0,9,0,1,25,0,0,9,0,1,25,0,0,9,0,1,25,0,0,9,0,1,25,0,0,9,0,1,25,0,0,9,0,1,25,0,0,9,0,1,25,0,0,9,0,1,25,0,0,9,0,1,25,0,0,9,0,1,25,0,0,10,0,1,26,0,0,2,0,1,26,0,0,10,0,1,26,0,0,10,0,1,26,0,0,10,0,1,26,0,0,10,0,1,26,0,0,10,0,1,26,0,0,10,0,1,26,0,0,10,0,1,26,0,0,10,0,1,26,0,0,10,0,1,26,0,0,10,0,1,26,0,0,11,0,1,27,0,0,2,0,1,27,0,0,11,0,1,27,0,0,11,0,1,27,0,0,11,0,1,27,0,0,11,0,1,27,0,0,11,0,1,27,0,0,11,0,1,27,0,0,11,0,1,27,0,0,11,0,1,27,0,0,11,0,1,27,0,0,11,0,1,27,0,0,12,0,1,28,0,0,2,0,1,28,0,0,12,0,1,28,0,0,12,0,1,28,0,0,12,0,1,28,0,0,12,0,1,28,0,0,12,0,1,28,0,0,12,0,1,28,0,0,12,0,1,28,0,0,12,0,1,28,0,0,12,0,1,28,0,0,12,0,1,28,0,0,13,0,1,29,0,0,2,0,1,29,0,0,13,0,1,29,0,0,13,0,1,29,0,0,13,0,1,29,0,0,13,0,1,29,0,0,13,0,1,29,0,0,13,0,1,29,0,0,13,0,1,29,0,0,13,0,1,29,0,0,13,0,1,29,0,0,13,0,1,29,0,0,14,0,1,30,0,0,2,0,1,30,0,0,14,0,1,30,0,0,14,0,1,30,0,0,14,0,1,30,0,0,14,0,1,30,0,0,14,0,1,30,0,0,14,0,1,30,0,0,14,0,1,30,0,0,14,0,1,30,0,0,14,0,1,30,0,0,14,0,1,30,0,0,15,0,1,31,0,0,2,0,1,31,0,0,15,0,1,31,0,0,15,0,1,31,0,0,15,0,1,31,0,0,15,0,1,31,0,0,15,0,1,31,0,0,15,0,1,31,0,0,15,0,1,31,0,0,15,0,1,31,0,0,15,0,1,31,0,0,15,0,1,31,0,0,16,0,1,32,0,0,2,0,1,32,0,0,16,0,1,32,0,0,16,0,1,32,0,0,16,0,1,32,0,0,16,0,1,32,0,0,16,0,1,32,0,0,16,0,1,32,0,0,16,0,1,32,0,0,16,0,1,32,0,0,16,0,1,32,0,0,16,0,1,32,0,0,17,0,1,33,0,0,2,0,1,33,0,0,17,0,1,33,0,0,17,0,1,33,0,0,17,0,1,33,0,0,17,0,1,33,0,0,17,0,1,33,0,0,17,0,1,33,0,0,17,0,1,33,0,0,17,0,1,33,0,0,17,0,1,33,0,0,17,0,1,33,0,0,2,0,0,3,0,0,4,0,0,5,0,0,6,0,0,7,0,0,8,0,0,9,0,0,10,0,0,11,0,0,12,0,0,13,0,0,14,0,0,15,0,0,16,0,0,17,0,5,2,0,0,3,0,0,3,0,0,3,0,0,3,0,0,3,0,0,3,0,0,3,0,0,3,0,0,3,0,0,3,0,5,3,0,0,4,0,0,4,0,0,4,0,0,4,0,0,4,0,0,4,0,0,4,0,0,4,0,0,4,0,0,4,0,5,4,0,0,5,0,0,5,0,0,5,0,0,5,0,0,5,0,0,5,0,0,5,0,0,5,0,0,5,0,0,5,0,5,5,0,0,6,0,0,6,0,0,6,0,0,6,0,0,6,0,0,6,0,0,6,0,0,6,0,0,6,0,0,6,0,5,6,0,0,7,0,0,7,0,0,7,0,0,7,0,0,7,0,0,7,0,0,7,0,0,7,0,0,7,0,0,7,0,5,7,0,0,8,0,0,8,0,0,8,0,0,8,0,0,8,0,0,8,0,0,8,0,0,8,0,0,8,0,0,8,0,5,8,0,0,9,0,0,9,0,0,9,0,0,9,0,0,9,0,0,9,0,0,9,0,0,9,0,0,9,0,0,9,0,5,9,0,0,10,0,0,10,0,0,10,0,0,10,0,0,10,0,0,10,0,0,10,0,0,10,0,0,10,0,0,10,0,5,10,0,0,11,0,0,11,0,0,11,0,0,11,0,0,11,0,0,11,0,0,11,0,0,11,0,0,11,0,0,11,0,5,11,0,0,12,0,0,12,0,0,12,0,0,12,0,0,12,0,0,12,0,0,12,0,0,12,0,0,12,0,0,12,0,5,12,0,0,13,0,0,13,0,0,13,0,0,13,0,0,13,0,0,13,0,0,13,0,0,13,0,0,13,0,0,13,0,5,13,0,0,14,0,0,14,0,0,14,0,0,14,0,0,14,0,0,14,0,0,14,0,0,14,0,0,14,0,0,14,0,5,14,0,0,15,0,0,15,0,0,15,0,0,15,0,0,15,0,0,15,0,0,15,0,0,15,0,0,15,0,0,15,0,5,15,0,0,16,0,0,16,0,0,16,0,0,16,0,0,16,0,0,16,0,0,16,0,0,16,0,0,16,0,0,16,0,5,16,0,0,17,0,0,17,0,0,17,0,0,17,0,0,17,0,0,17,0,0,17,0,0,17,0,0,17,0,0,17,0,5,17,0,2,18,0,-2,115,0,2,18,0,2,18,0,-1,86,0,-2,87,0,-3,65,0,-4,88,0,-5,89,0,-6,90,0,-7,91,0,-8,92,0,-9,93,0,1,96,0,1,68,0,1,97,0,1,69,0,1,70,0,1,71,0,1,72,0,1,73,0,1,74,0,1,75,0,0,34,0,1,98,0,1,98,0,0,34,0,1,99,0,1,99,0,0,34,0,1,100,0,1,100,0,0,34,0,1,101,0,1,101,0,0,34,0,1,102,0,1,102,0,0,34,0,1,103,0,1,103,0,0,34,0,1,104,0,1,104,0,0,34,0,1,105,0,1,105,0,0,34,0,1,106,0,1,106,0,1,96,0,1,68,0,1,68,0,1,97,0,1,69,0,1,70,0,1,71,0,1,72,0,1,73,0,1,74,0,1,75,0,1,69,0,1,70,0,1,71,0,1,72,0,1,73,0,1,74,0,1,75,0,-1,95,0,5,34,0,2,35,0,16,117,0,2,35,0,2,35,0,-1,116,0,-2,55,0,-3,56,0,-4,62,0,-7,63,0,2,36,0,2,36,0,2,36,0,2,36,0,2,36,0,0,37,0,0,37,0,1,59,0,0,37,0,1,60,0,0,37,0,1,61,0,1,61,0,1,61,0,1,59,0,1,59,0,1,60,0,1,60,0,1,60,0,1,59,0,1,61,0,1,78,0,1,107,0,1,107,0,1,78,0,1,78,0,5,37,0,2,38,0,2,38,0,2,38,0,2,38,0,2,39,0,2,39,0,2,39,0,2,39,0,2,40,0,2,40,0,2,40,0,2,40,0,2,41,0,2,41,0,2,41,0,2,41,0,2,42,0,2,42,0,2,42,0,2,42,0,2,43,0,2,43,0,2,43,0,2,43,0,2,44,0,2,44,0,2,44,0,2,44,0,2,45,0,2,45,0,2,45,0,2,45,0,2,46,0,2,46,0,2,46,0,2,46,0,2,47,0,2,47,0,2,47,0,2,47,0,2,48,0,2,48,0,2,48,0,2,48,0,2,49,0,2,49,0,2,49,0,2,49,0,2,50,0,2,50,0,2,50,0,2,50,0,2,51,0,2,51,0,2,51,0,2,51,0,2,52,0,2,52,0,2,52,0,2,52,0,2,53,0,-1,79,0,-2,80,0,-3,81,0,-4,114,0,2,55,0,2,55,0,2,55,0,1,57,0,1,57,0,1,57,0,1,57,0,0,56,0,1,57,0,0,56,0,1,82,0,1,82,0,1,82,0,1,118,0,1,118,0,5,56,0,1,83,0,1,83,0,1,83,0,1,84,0,1,84,0,1,84,0,5,62,0,1,85,0,1,85,0,1,85,0,0,63,0,1,64,0,1,64,0,1,64,0,1,64,0,5,63,0,2,65,0,2,65,0,2,65,0,2,67,0,2,67,0,0,76,0,1,77,0,1,77,0,1,77,0,5,76,0,-1,108,0,-2,109,0,-1,110,0,-2,111,0,-1,112,0,-2,113,0,2,86,0,2,86,0,2,87,0,2,87,0,2,88,0,2,88,0,2,89,0,2,89,0,2,90,0,2,90,0,2,91,0,2,91,0,2,92,0,2,92,0,2,93,0,2,93,0,2,94,0,2,95,0,2,108,0,2,109,0,2,110,0,2,111,0,2,112,0,2,113,0,2,114,0,-1,117,0,17,66,1,8,66,2,8,35,18,8,35,35,8,66,54,18,62,54,19,56,54,20,55,54,21,115,816],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[4,-1,3,4,4,10,3,10,3,0,-1,3,10,-1,3,10,-1,3,10,-1,3,10,-1,3,10,-1,3,10,-1,3,10,-1,3,10,-1,3,10,-1,3,10,-1,3,10,-1,3,10,-1,3,10,-1,3,10,-1,3,10,-1,3,10,-1,3,-1,3,-1,3,-1,3,-1,3,-1,3,-1,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,6,6,6,6,6,6,6,6,22],[45,21,22,46,47,23,24,23,25,48,49,3,4,50,3,4,51,3,4,52,3,4,53,3,4,54,3,4,55,3,4,56,3,4,57,3,4,58,3,4,59,3,4,60,3,4,61,3,4,62,3,4,63,3,4,64,3,4,17,12,18,12,17,12,18,12,17,12,18,12,65,3,66,67,68,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,69,14,15,8,8,8,9,9,9,70]],[[[20,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{}],[{"USE_POSITION_SCALING":true},{"USE_BASE_COLOR_MAP":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{},{}],[[{},[{"baseStep":0.9,"baseFeather":0.3,"shadeStep":0.6,"shadeFeather":0.2},"tilingOffset",8,[2,2,1,0,0],"mainColor",8,[4,4284769380],"shadeColor1",8,[4,4283453520],"shadeColor2",8,[4,1661602314],"specular",8,[4,1275068415],"emissive",8,[4,0],"mainTexture",6,0],{},{}],0,11,0,0]]],0,0,[0,0],[9,7],[71,2]],[[[20,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{}],[{"USE_POSITION_SCALING":true},{"USE_BASE_COLOR_MAP":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{},{}],[[{},[{"baseStep":0.9,"baseFeather":0.3,"shadeStep":0.6,"shadeFeather":0.2},"tilingOffset",8,[2,2,1,0,0],"mainColor",8,[4,4284769380],"shadeColor1",8,[4,4283453520],"shadeColor2",8,[4,1661602314],"specular",8,[4,1275068415],"emissive",8,[4,0],"mainTexture",6,0],{},{}],0,11,0,0]]],0,0,[0,0],[9,7],[72,2]],[[[68,"1",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{}],[{},{},{}],[[[{},"mainColor",8,[4,16777215]],{},{}],11,0,0]]],0,0,[0],[7],[10]],[[{"name":"failed","rect":{"x":162,"y":176,"width":1760,"height":1536},"offset":{"x":0,"y":98},"originalSize":{"width":2084,"height":2084},"rotated":false,"capInsets":[0,0,0,0],"texture":"949fd3a3-2354-4061-85fe-610367c95f91@6c48a","packable":true}],[1],0,[0],[13],[73]],[[[20,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{}],[{"USE_POSITION_SCALING":true},{"USE_BASE_COLOR_MAP":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{},{}],[[{},[{"baseStep":0.9,"baseFeather":0.3,"shadeStep":0.6,"shadeFeather":0.2},"tilingOffset",8,[2,2,1,0,0],"mainColor",8,[4,4284769380],"shadeColor1",8,[4,4283453520],"shadeColor2",8,[4,1661602314],"specular",8,[4,1275068415],"emissive",8,[4,0],"mainTexture",6,0],{},{}],0,11,0,0]]],0,0,[0,0],[9,7],[74,2]],[[[20,[{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}},{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}},{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}},{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}}],[{"USE_OUTLINE_PASS":true},{"USE_BASE_COLOR_MAP":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{"USE_BASE_COLOR_MAP":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{"USE_BASE_COLOR_MAP":true}],[[{},[{},"specular",8,[4,16777215],"mainTexture",6,0],{},{}],0,11,0,0]]],0,0,[0,0],[9,7],[75,2]],[[[20,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{}],[{"USE_POSITION_SCALING":true},{"USE_BASE_COLOR_MAP":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{},{}],[[{},[{"baseStep":0.9,"baseFeather":0.3,"shadeStep":0.6,"shadeFeather":0.2},"tilingOffset",8,[2,2,1,0,0],"mainColor",8,[4,4284769380],"shadeColor1",8,[4,4283453520],"shadeColor2",8,[4,1661602314],"specular",8,[4,1275068415],"emissive",8,[4,0],"mainTexture",6,0],{},{}],0,11,0,0]]],0,0,[0,0],[9,7],[76,2]],[[[57,"builtin-unlit",[{"hash":1017648509,"name":"builtin-unlit|unlit-vs:vert|unlit-fs:frag","glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 6) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 7) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 8) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      layout(location = 7) in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 5) uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\n  layout(location = 8) in vec4 a_matWorld0;\n  layout(location = 9) in vec4 a_matWorld1;\n  layout(location = 10) in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    layout(location = 11) in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n  layout(set = 2, binding = 0) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(set = 2, binding = 0) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nlayout(location = 0) out float v_fog_factor;\n#if USE_VERTEX_COLOR\n  layout(location = 13) in lowp vec4 a_color;\n  layout(location = 1) out lowp vec4 v_color;\n#endif\n#if USE_TEXTURE\n  layout(location = 2) out vec2 v_uv;\n  layout(set = 1, binding = 0) uniform TexCoords {\n    vec4 tilingOffset;\n  };\n#endif\nvec4 vert () {\n  vec4 position;\n      position = vec4(a_position, 1.0);\n    #if CC_USE_MORPH\n      applyMorph(position);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(position);\n    #endif\n  mat4 matWorld;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    #else\n      matWorld = cc_matWorld;\n    #endif\n  #if USE_TEXTURE\n    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n    #if CC_USE_FOG == 0\n      v_fog_factor = LinearFog(matWorld * position);\n    #elif CC_USE_FOG == 1\n      v_fog_factor = ExpFog(matWorld * position);\n    #elif CC_USE_FOG == 2\n      v_fog_factor = ExpSquaredFog(matWorld * position);\n    #elif CC_USE_FOG == 3\n      v_fog_factor = LayeredFog(matWorld * position);\n    #else\n      v_fog_factor = 1.0;\n    #endif\n  return cc_matProj * (cc_matView * matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nlayout(location = 0) in float v_fog_factor;\n#if USE_ALPHA_TEST\n#endif\n#if USE_TEXTURE\n  layout(location = 2) in vec2 v_uv;\n  layout(set = 1, binding = 2) uniform sampler2D mainTexture;\n#endif\nlayout(set = 1, binding = 1) uniform Constant {\n  vec4 mainColor;\n  vec4 colorScaleAndCutoff;\n};\n#if USE_VERTEX_COLOR\n  layout(location = 1) in lowp vec4 v_color;\n#endif\nvec4 frag () {\n  vec4 o = mainColor;\n  o.rgb *= colorScaleAndCutoff.xyz;\n  #if USE_VERTEX_COLOR\n    o *= v_color;\n  #endif\n  #if USE_TEXTURE\n    o *= texture(mainTexture, v_uv);\n  #endif\n  #if USE_ALPHA_TEST\n    if (o.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  o = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, o.rgb, v_fog_factor), o.a);\n  return CCFragOutput(o);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n  layout(std140) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nout float v_fog_factor;\n#if USE_VERTEX_COLOR\n  in lowp vec4 a_color;\n  out lowp vec4 v_color;\n#endif\n#if USE_TEXTURE\n  out vec2 v_uv;\n  layout(std140) uniform TexCoords {\n    vec4 tilingOffset;\n  };\n#endif\nvec4 vert () {\n  vec4 position;\n      position = vec4(a_position, 1.0);\n    #if CC_USE_MORPH\n      applyMorph(position);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(position);\n    #endif\n  mat4 matWorld;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    #else\n      matWorld = cc_matWorld;\n    #endif\n  #if USE_TEXTURE\n    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n    #if CC_USE_FOG == 0\n      v_fog_factor = LinearFog(matWorld * position);\n    #elif CC_USE_FOG == 1\n      v_fog_factor = ExpFog(matWorld * position);\n    #elif CC_USE_FOG == 2\n      v_fog_factor = ExpSquaredFog(matWorld * position);\n    #elif CC_USE_FOG == 3\n      v_fog_factor = LayeredFog(matWorld * position);\n    #else\n      v_fog_factor = 1.0;\n    #endif\n  return cc_matProj * (cc_matView * matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nin float v_fog_factor;\n#if USE_ALPHA_TEST\n#endif\n#if USE_TEXTURE\n  in vec2 v_uv;\n  uniform sampler2D mainTexture;\n#endif\nlayout(std140) uniform Constant {\n  vec4 mainColor;\n  vec4 colorScaleAndCutoff;\n};\n#if USE_VERTEX_COLOR\n  in lowp vec4 v_color;\n#endif\nvec4 frag () {\n  vec4 o = mainColor;\n  o.rgb *= colorScaleAndCutoff.xyz;\n  #if USE_VERTEX_COLOR\n    o *= v_color;\n  #endif\n  #if USE_TEXTURE\n    o *= texture(mainTexture, v_uv);\n  #endif\n  #if USE_ALPHA_TEST\n    if (o.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  o = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, o.rgb, v_fog_factor), o.a);\n  return CCFragOutput(o);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      attribute highp vec4 a_jointAnimInfo;\n    #endif\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n#if USE_INSTANCING\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n  uniform highp mat4 cc_matWorlds[10];\n#else\n  uniform highp mat4 cc_matWorld;\n#endif\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvarying float v_fog_factor;\n#if USE_VERTEX_COLOR\n  attribute lowp vec4 a_color;\n  varying lowp vec4 v_color;\n#endif\n#if USE_TEXTURE\n  varying vec2 v_uv;\n      uniform vec4 tilingOffset;\n#endif\nvec4 vert () {\n  vec4 position;\n      position = vec4(a_position, 1.0);\n    #if CC_USE_MORPH\n      applyMorph(position);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(position);\n    #endif\n  mat4 matWorld;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    #else\n      matWorld = cc_matWorld;\n    #endif\n  #if USE_TEXTURE\n    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n    #if CC_USE_FOG == 0\n      v_fog_factor = LinearFog(matWorld * position);\n    #elif CC_USE_FOG == 1\n      v_fog_factor = ExpFog(matWorld * position);\n    #elif CC_USE_FOG == 2\n      v_fog_factor = ExpSquaredFog(matWorld * position);\n    #elif CC_USE_FOG == 3\n      v_fog_factor = LayeredFog(matWorld * position);\n    #else\n      v_fog_factor = 1.0;\n    #endif\n  return cc_matProj * (cc_matView * matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nuniform mediump vec4 cc_exposure;\n  uniform mediump vec4 cc_fogColor;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvarying float v_fog_factor;\n#if USE_ALPHA_TEST\n#endif\n#if USE_TEXTURE\n  varying vec2 v_uv;\n  uniform sampler2D mainTexture;\n#endif\n   uniform vec4 mainColor;\n   uniform vec4 colorScaleAndCutoff;\n#if USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\nvec4 frag () {\n  vec4 o = mainColor;\n  o.rgb *= colorScaleAndCutoff.xyz;\n  #if USE_VERTEX_COLOR\n    o *= v_color;\n  #endif\n  #if USE_TEXTURE\n    o *= texture2D(mainTexture, v_uv);\n  #endif\n  #if USE_ALPHA_TEST\n    if (o.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  o = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, o.rgb, v_fog_factor), o.a);\n  return CCFragOutput(o);\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":195,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":39}},"defines":[{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["CC_USE_SKINNING"]},{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"USE_LIGHTMAP","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_USE_FOG","type":"number","defines":[],"range":[0,4]},{"name":"CC_FORWARD_ADD","type":"boolean","defines":[]},{"name":"USE_VERTEX_COLOR","type":"boolean","defines":[]},{"name":"USE_TEXTURE","type":"boolean","defines":[]},{"name":"SAMPLE_FROM_RT","type":"boolean","defines":["USE_TEXTURE"]},{"name":"CC_USE_HDR","type":"boolean","defines":[]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"ALPHA_TEST_CHANNEL","type":"string","defines":["USE_ALPHA_TEST"],"options":["a","r","g","b"]}],"blocks":[{"name":"TexCoords","stageFlags":1,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1}],"defines":["USE_TEXTURE"]},{"name":"Constant","stageFlags":16,"binding":1,"members":[{"name":"mainColor","type":16,"count":1},{"name":"colorScaleAndCutoff","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_TEXTURE"]}],"attributes":[{"name":"a_position","type":15,"count":1,"stageFlags":1,"format":32,"location":0,"defines":[]},{"name":"a_normal","type":15,"count":1,"stageFlags":1,"format":32,"location":1,"defines":[]},{"name":"a_texCoord","type":14,"count":1,"stageFlags":1,"format":21,"location":2,"defines":[]},{"name":"a_tangent","type":16,"count":1,"stageFlags":1,"format":44,"location":3,"defines":[]},{"name":"a_vertexId","type":13,"count":1,"stageFlags":1,"format":11,"location":6,"defines":["CC_USE_MORPH"]},{"name":"a_joints","type":"u32vec4","count":1,"stageFlags":1,"location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","type":16,"count":1,"stageFlags":1,"format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":7,"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION","USE_INSTANCING"]},{"name":"a_matWorld0","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","USE_LIGHTMAP"]},{"name":"a_dyn_batch_id","type":13,"count":1,"stageFlags":1,"format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_color","type":16,"count":1,"stageFlags":1,"format":44,"location":13,"defines":["USE_VERTEX_COLOR"]}],"varyings":[{"name":"v_fog_factor","type":13,"count":1,"stageFlags":1,"location":0,"defines":[]},{"name":"v_color","type":16,"count":1,"stageFlags":1,"location":1,"defines":["USE_VERTEX_COLOR"]},{"name":"v_uv","type":14,"count":1,"stageFlags":1,"location":2,"defines":["USE_TEXTURE"]}]}],[{"name":"opaque","passes":[{"program":"builtin-unlit|unlit-vs:vert|unlit-fs:frag","properties":{"mainTexture":{"value":"grey","type":28},"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"type":"color"}},"colorScale":{"type":15,"value":[1,1,1],"handleInfo":["colorScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["colorScaleAndCutoff",3,13]},"color":{"type":16,"editor":{"visible":false},"handleInfo":["mainColor",0,16]},"colorScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]}},"migrations":{"properties":{"mainColor":{"formerlySerializedAs":"color"}}}}]},{"name":"transparent","passes":[{"program":"builtin-unlit|unlit-vs:vert|unlit-fs:frag","blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"type":"color"}},"colorScale":{"type":15,"value":[1,1,1],"handleInfo":["colorScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["colorScaleAndCutoff",3,13]},"color":{"type":16,"editor":{"visible":false},"handleInfo":["mainColor",0,16]},"colorScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]}},"migrations":{"properties":{"mainColor":{"formerlySerializedAs":"color"}}}}]},{"name":"add","passes":[{"program":"builtin-unlit|unlit-vs:vert|unlit-fs:frag","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":1,"blendSrcAlpha":2,"blendDstAlpha":1}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"type":"color"}},"colorScale":{"type":15,"value":[1,1,1],"handleInfo":["colorScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["colorScaleAndCutoff",3,13]},"color":{"type":16,"editor":{"visible":false},"handleInfo":["mainColor",0,16]},"colorScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]}},"migrations":{"properties":{"mainColor":{"formerlySerializedAs":"color"}}}}]},{"name":"alpha-blend","passes":[{"program":"builtin-unlit|unlit-vs:vert|unlit-fs:frag","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendSrcAlpha":2,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"type":"color"}},"colorScale":{"type":15,"value":[1,1,1],"handleInfo":["colorScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["colorScaleAndCutoff",3,13]},"color":{"type":16,"editor":{"visible":false},"handleInfo":["mainColor",0,16]},"colorScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]}},"migrations":{"properties":{"mainColor":{"formerlySerializedAs":"color"}}}}]}]]],0,0,[],[],[]],[[[57,"builtin-toon",[{"hash":3976454846,"name":"builtin-toon|outline-vs:vert|outline-fs:frag","glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 6) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 7) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 8) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      layout(location = 7) in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 5) uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\n  layout(location = 8) in vec4 a_matWorld0;\n  layout(location = 9) in vec4 a_matWorld1;\n  layout(location = 10) in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    layout(location = 11) in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n  layout(set = 2, binding = 0) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(set = 2, binding = 0) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(location = 0) out vec2 v_uv;\nlayout(set = 1, binding = 0) uniform OutlineVert {\n  vec4 outlineParams;\n};\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    #else\n      matWorld = cc_matWorld;\n    #endif\n  float width = outlineParams.x * 0.001;\n  #if USE_POSITION_SCALING\n    vec3 dir = normalize(In.position.xyz);\n    float flip = dot(dir, normalize(In.normal)) < 0.0 ? -1.0 : 1.0;\n    In.position.xyz += flip * dir * width * 2.0;\n    vec4 pos = cc_matProj * (cc_matView * matWorld) * In.position;\n  #else\n    In.position.xyz += normalize(In.normal) * width;\n    vec4 pos = cc_matProj * (cc_matView * matWorld) * In.position;\n  #endif\n  pos.z -= outlineParams.y * 0.002;\n  v_uv = a_texCoord;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nlayout(location = 0) in vec2 v_uv;\nlayout(set = 1, binding = 1) uniform OutlineFrag {\n  vec4 baseColor;\n};\n#if USE_BASE_COLOR_MAP\n  layout(set = 1, binding = 2) uniform sampler2D baseColorMap;\n#endif\nvec4 frag () {\n  vec4 color = baseColor * cc_mainLitColor;\n  #if USE_BASE_COLOR_MAP\n    vec4 texColor = texture(baseColorMap, v_uv);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    color *= texColor;\n  #endif\n  return CCFragOutput(vec4(color.rgb, 1.0));\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n  layout(std140) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nout vec2 v_uv;\nlayout(std140) uniform OutlineVert {\n  vec4 outlineParams;\n};\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    #else\n      matWorld = cc_matWorld;\n    #endif\n  float width = outlineParams.x * 0.001;\n  #if USE_POSITION_SCALING\n    vec3 dir = normalize(In.position.xyz);\n    float flip = dot(dir, normalize(In.normal)) < 0.0 ? -1.0 : 1.0;\n    In.position.xyz += flip * dir * width * 2.0;\n    vec4 pos = cc_matProj * (cc_matView * matWorld) * In.position;\n  #else\n    In.position.xyz += normalize(In.normal) * width;\n    vec4 pos = cc_matProj * (cc_matView * matWorld) * In.position;\n  #endif\n  pos.z -= outlineParams.y * 0.002;\n  v_uv = a_texCoord;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nin vec2 v_uv;\nlayout(std140) uniform OutlineFrag {\n  vec4 baseColor;\n};\n#if USE_BASE_COLOR_MAP\n  uniform sampler2D baseColorMap;\n#endif\nvec4 frag () {\n  vec4 color = baseColor * cc_mainLitColor;\n  #if USE_BASE_COLOR_MAP\n    vec4 texColor = texture(baseColorMap, v_uv);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    color *= texColor;\n  #endif\n  return CCFragOutput(vec4(color.rgb, 1.0));\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      attribute highp vec4 a_jointAnimInfo;\n    #endif\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n#if USE_INSTANCING\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n  uniform highp mat4 cc_matWorlds[10];\n#else\n  uniform highp mat4 cc_matWorld;\n#endif\nvarying vec2 v_uv;\n   uniform vec4 outlineParams;\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    #else\n      matWorld = cc_matWorld;\n    #endif\n  float width = outlineParams.x * 0.001;\n  #if USE_POSITION_SCALING\n    vec3 dir = normalize(In.position.xyz);\n    float flip = dot(dir, normalize(In.normal)) < 0.0 ? -1.0 : 1.0;\n    In.position.xyz += flip * dir * width * 2.0;\n    vec4 pos = cc_matProj * (cc_matView * matWorld) * In.position;\n  #else\n    In.position.xyz += normalize(In.normal) * width;\n    vec4 pos = cc_matProj * (cc_matView * matWorld) * In.position;\n  #endif\n  pos.z -= outlineParams.y * 0.002;\n  v_uv = a_texCoord;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nuniform mediump vec4 cc_exposure;\n  uniform mediump vec4 cc_mainLitColor;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvarying vec2 v_uv;\n   uniform vec4 baseColor;\n#if USE_BASE_COLOR_MAP\n  uniform sampler2D baseColorMap;\n#endif\nvec4 frag () {\n  vec4 color = baseColor * cc_mainLitColor;\n  #if USE_BASE_COLOR_MAP\n    vec4 texColor = texture2D(baseColorMap, v_uv);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    color *= texColor;\n  #endif\n  return CCFragOutput(vec4(color.rgb, 1.0));\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":195,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":38}},"defines":[{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["CC_USE_SKINNING"]},{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"USE_LIGHTMAP","type":"boolean","defines":["USE_INSTANCING"]},{"name":"USE_POSITION_SCALING","type":"boolean","defines":[]},{"name":"CC_USE_HDR","type":"boolean","defines":[]},{"name":"USE_BASE_COLOR_MAP","type":"boolean","defines":[]}],"blocks":[{"name":"OutlineVert","stageFlags":1,"binding":0,"members":[{"name":"outlineParams","type":16,"count":1}],"defines":[]},{"name":"OutlineFrag","stageFlags":16,"binding":1,"members":[{"name":"baseColor","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"baseColorMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_BASE_COLOR_MAP"]}],"attributes":[{"name":"a_position","type":15,"count":1,"stageFlags":1,"format":32,"location":0,"defines":[]},{"name":"a_normal","type":15,"count":1,"stageFlags":1,"format":32,"location":1,"defines":[]},{"name":"a_texCoord","type":14,"count":1,"stageFlags":1,"format":21,"location":2,"defines":[]},{"name":"a_tangent","type":16,"count":1,"stageFlags":1,"format":44,"location":3,"defines":[]},{"name":"a_vertexId","type":13,"count":1,"stageFlags":1,"format":11,"location":6,"defines":["CC_USE_MORPH"]},{"name":"a_joints","type":"u32vec4","count":1,"stageFlags":1,"location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","type":16,"count":1,"stageFlags":1,"format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":7,"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION","USE_INSTANCING"]},{"name":"a_matWorld0","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","USE_LIGHTMAP"]},{"name":"a_dyn_batch_id","type":13,"count":1,"stageFlags":1,"format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]}],"varyings":[{"name":"v_uv","type":14,"count":1,"stageFlags":1,"location":0,"defines":[]}]},{"hash":295467465,"name":"builtin-toon|toon-vs:vert|toon-fs:frag","glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 6) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 7) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 8) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      layout(location = 7) in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 5) uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\n  layout(location = 8) in vec4 a_matWorld0;\n  layout(location = 9) in vec4 a_matWorld1;\n  layout(location = 10) in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    layout(location = 11) in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n  layout(set = 2, binding = 0) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(set = 2, binding = 0) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 baseColor;\n  vec4 colorScaleAndCutoff;\n  vec4 shadeColor1;\n  vec4 shadeColor2;\n  vec4 specular;\n  vec4 shadeParams;\n  vec4 emissive;\n  vec4 emissiveScaleAndStrenth;\n};\nlayout(location = 0) out highp vec4 v_shadowPos;\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform sampler2D cc_spotLightingMap;\n#endif\nlayout(location = 1) out vec3 v_position;\nlayout(location = 2) out vec2 v_uv;\nlayout(location = 3) out vec3 v_normal;\n#if USE_NORMAL_MAP\n  layout(location = 4) out vec3 v_tangent;\n  layout(location = 5) out vec3 v_bitangent;\n#endif\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  v_normal = (matWorldIT * vec4(In.normal, 0.0)).xyz;\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_shadowPos = cc_matLightViewProj * pos;\n  return cc_matProj * (cc_matView * matWorld) * In.position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nstruct ToonSurface {\n  vec4 baseColor;\n  vec4 specular;\n  vec3 position;\n  vec3 normal;\n  vec3 shade1;\n  vec3 shade2;\n  vec3 emissive;\n  float baseStep;\n  float baseFeather;\n  float shadeStep;\n  float shadeFeather;\n};\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n  # define LIGHTS_PER_PASS 1\n  #else\n  # define LIGHTS_PER_PASS 10\n  #endif\n  layout(set = 2, binding = 1) uniform CCForwardLight {\n    highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n    vec4 cc_lightColor[LIGHTS_PER_PASS];\n    vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n    vec4 cc_lightDir[LIGHTS_PER_PASS];\n  };\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  vec4 CCToonShading (ToonSurface s) {\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    vec3 N = normalize(s.normal);\n    float specularWeight = 1.0 - pow(s.specular.a, 5.0);\n    vec3 finalColor = vec3(0.0);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      vec3 SLU = cc_lightPos[i].xyz - s.position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = 0.5 * dot(N, SL) + 0.5;\n      float SNH = 0.5 * dot(N, SH) + 0.5;\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = litRadiusSqr / max(litRadiusSqr , distSqr);\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 diffuse = mix(s.shade1, s.shade2,\n        clamp(1.0 + (s.shadeStep - s.shadeFeather - SNL) / s.shadeFeather, 0.0, 1.0));\n      diffuse = mix(s.baseColor.rgb, diffuse,\n        clamp(1.0 + (s.baseStep - s.baseFeather - SNL) / s.baseFeather, 0.0, 1.0));\n      float specularMask = step(specularWeight, SNH);\n      vec3 specular = s.specular.rgb * specularMask;\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      finalColor += SNL * cc_lightColor[i].rgb * cc_lightColor[i].a * illum * att * s.baseStep * (diffuse + specular);\n    }\n    return vec4(finalColor, 0.0);\n  }\n#else\n  #if CC_RECEIVE_SHADOW\n    layout(location = 0) in highp vec4 v_shadowPos;\n    layout(set = 0, binding = 2) uniform CCShadow {\n      highp mat4 cc_matLightPlaneProj;\n      highp mat4 cc_matLightView;\n      highp mat4 cc_matLightViewProj;\n      lowp  vec4 cc_shadowNFLSInfo;\n      lowp  vec4 cc_shadowWHPBInfo;\n      lowp  vec4 cc_shadowLPNNInfo;\n      lowp  vec4 cc_shadowColor;\n    };\n    #if CC_RECEIVE_SHADOW\n      layout(set = 0, binding = 3) uniform sampler2D cc_shadowMap;\n      layout(set = 0, binding = 5) uniform sampler2D cc_spotLightingMap;\n      float CCGetShadowFactorX1 (vec4 shadowPos) {\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n            clipPos.y < 0.0 || clipPos.y > 1.0 ||\n            clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n        float shadow = 0.0;\n        float closestDepth = 0.0;\n        clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n        if (cc_shadowLPNNInfo.y > 0.000001) {\n          closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n        } else {\n          closestDepth = texture(cc_shadowMap, clipPos.xy).x;\n        }\n        shadow = step(closestDepth, clipPos.z- cc_shadowWHPBInfo.w);\n        return shadow;\n      }\n      float CCGetShadowFactorX5 (vec4 shadowPos) {\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n            clipPos.y < 0.0 || clipPos.y > 1.0 ||\n            clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n        float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n        float offsety = 1.0 / cc_shadowWHPBInfo.y;\n        float shadow = 0.0;\n        clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n        if (cc_shadowLPNNInfo.y > 0.000001) {\n          float closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n        } else {\n          float closestDepth = texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n        }\n        return shadow / 5.0;\n      }\n      float CCGetShadowFactorX9 (vec4 shadowPos) {\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n            clipPos.y < 0.0 || clipPos.y > 1.0 ||\n            clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n        float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n        float offsety = 1.0 / cc_shadowWHPBInfo.y;\n        float shadow = 0.0;\n        float closestDepth = 0.0;\n        clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n        if (cc_shadowLPNNInfo.y > 0.000001) {\n          for (int i = -1; i <= 1; i++) {\n              for (int j = -1; j <= 1; j++) {\n                float closestDepth = dot(texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n                shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n              }\n          }\n        } else {\n          for (int i = -1; i <= 1; i++) {\n              for (int j = -1; j <= 1; j++) {\n                float closestDepth = texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\n                shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n              }\n          }\n        }\n        return shadow / 9.0;\n      }\n      float CCGetShadowFactorX25 (vec4 shadowPos) {\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n            clipPos.y < 0.0 || clipPos.y > 1.0 ||\n            clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n        float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n        float offsety = 1.0 / cc_shadowWHPBInfo.y;\n        float shadow = 0.0;\n        clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n        if (cc_shadowLPNNInfo.y > 0.000001) {\n          for (int i = -2; i <= 2; i++) {\n            for (int j = -2; j <= 2; j++) {\n              float closestDepth = dot(texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n              shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n            }\n          }\n        } else {\n          for (int i = -2; i <= 2; i++) {\n            for (int j = -2; j <= 2; j++) {\n              float closestDepth = texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\n              shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n            }\n          }\n        }\n        return shadow / 25.0;\n      }\n    #endif\n  #endif\n  vec4 CCToonShading (ToonSurface s) {\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    vec3 N = normalize(s.normal);\n    vec3 L = normalize(-cc_mainLitDir.xyz);\n    float NL = 0.5 * dot(N, L) + 0.5;\n    float NH = 0.5 * dot(normalize(V + L), N) + 0.5;\n    vec3 lightColor = cc_mainLitColor.rgb * cc_mainLitColor.w * s.baseStep;\n    vec3 diffuse = mix(s.shade1, s.shade2,\n      clamp(1.0 + (s.shadeStep - s.shadeFeather - NL) / s.shadeFeather, 0.0, 1.0));\n    diffuse = mix(s.baseColor.rgb, diffuse,\n      clamp(1.0 + (s.baseStep - s.baseFeather - NL) / s.baseFeather, 0.0, 1.0));\n    float specularWeight = 1.0 - pow(s.specular.a, 5.0);\n    float specularMask = step(specularWeight, NH);\n    vec3 specular = s.specular.rgb * specularMask;\n    vec3 finalColor = lightColor * (diffuse + specular);\n    #if CC_USE_HDR\n      s.emissive *= cc_exposure.w;\n    #endif\n    finalColor += s.emissive;\n    #if CC_RECEIVE_SHADOW\n              {\n                float pcf = cc_shadowWHPBInfo.z + 0.001;\n                float shadowAttenuation = 0.0;\n                float cosAngle = clamp(1.0 - dot(N, cc_mainLitDir.xyz), 0.0, 1.0);\n                vec3 projWorldPos = v_shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\n                vec4 pos = vec4(projWorldPos.xyz, v_shadowPos.w);\n                if (pcf > 3.0) shadowAttenuation = CCGetShadowFactorX25(pos);\n                else if (pcf > 2.0) shadowAttenuation = CCGetShadowFactorX9(pos);\n                else if (pcf > 1.0) shadowAttenuation = CCGetShadowFactorX5(pos);\n                else shadowAttenuation = CCGetShadowFactorX1(pos);\n                vec3 shadowColor = cc_shadowColor.rgb * cc_shadowColor.a + finalColor.rgb * (1.0 - cc_shadowColor.a);\n                if (cc_shadowNFLSInfo.w > 0.000001) {\n                  finalColor.rgb = shadowColor.rgb * shadowAttenuation + finalColor.rgb * (1.0 - shadowAttenuation);\n                } else {\n                  finalColor.rgb = shadowColor.rgb * shadowAttenuation * NL + finalColor.rgb * (1.0 - shadowAttenuation * NL);\n                }\n              }\n    #endif\n    return vec4(finalColor, s.baseColor.a);\n  }\n#endif\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 baseColor;\n  vec4 colorScaleAndCutoff;\n  vec4 shadeColor1;\n  vec4 shadeColor2;\n  vec4 specular;\n  vec4 shadeParams;\n  vec4 emissive;\n  vec4 emissiveScaleAndStrenth;\n};\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = sqrt(ACESToneMap(color.rgb));\n  #endif\n  return color;\n}\nlayout(location = 1) in vec3 v_position;\nlayout(location = 2) in vec2 v_uv;\n#if USE_BASE_COLOR_MAP\n  layout(set = 1, binding = 1) uniform sampler2D baseColorMap;\n#endif\nlayout(location = 3) in vec3 v_normal;\n#if USE_NORMAL_MAP\n  layout(location = 4) in vec3 v_tangent;\n  layout(location = 5) in vec3 v_bitangent;\n  layout(set = 1, binding = 2) uniform sampler2D normalMap;\n#endif\n#if USE_1ST_SHADE_MAP\n  layout(set = 1, binding = 3) uniform sampler2D shadeMap1;\n#endif\n#if USE_2ND_SHADE_MAP\n  layout(set = 1, binding = 4) uniform sampler2D shadeMap2;\n#endif\n#if USE_SPECULAR_MAP\n  layout(set = 1, binding = 5) uniform sampler2D specularMap;\n#endif\n#if USE_EMISSIVE_MAP\n  layout(set = 1, binding = 6) uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out ToonSurface s) {\n  s.shade2 = shadeColor2.rgb * colorScaleAndCutoff.rgb;\n  #if USE_2ND_SHADE_MAP\n    s.shade2 *= SRGBToLinear(texture(shadeMap2, v_uv).rgb);\n  #endif\n  s.shade1 = shadeColor1.rgb * colorScaleAndCutoff.rgb;\n  #if USE_1ST_SHADE_MAP\n    s.shade1 *= SRGBToLinear(texture(shadeMap1, v_uv).rgb);\n    #if SHADE_MAP_1_AS_SHADE_MAP_2\n      s.shade2 *= s.shade1.rgb;\n    #endif\n  #endif\n  vec4 baseColor = baseColor;\n  #if USE_BASE_COLOR_MAP\n    vec4 baseColorMap = texture(baseColorMap, v_uv);\n    baseColorMap.rgb = SRGBToLinear(baseColorMap.rgb);\n    baseColor *= baseColorMap;\n    #if BASE_COLOR_MAP_AS_SHADE_MAP_1\n      s.shade1 *= baseColorMap.rgb;\n    #endif\n    #if BASE_COLOR_MAP_AS_SHADE_MAP_2\n      s.shade2 *= baseColorMap.rgb;\n    #endif\n  #endif\n  s.baseColor = baseColor;\n  s.baseColor.rgb *= colorScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.baseColor.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, v_uv).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * emissiveScaleAndStrenth.w) * normalize(v_tangent) +\n      (nmmp.y * emissiveScaleAndStrenth.w) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  s.position = v_position;\n  s.specular = specular;\n  #if USE_SPECULAR_MAP\n    s.specular.rgb *= SRGBToLinear(texture(specularMap, v_uv).rgb);\n  #endif\n  s.emissive = emissive.rgb * emissiveScaleAndStrenth.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture(emissiveMap, v_uv).rgb);\n  #endif\n  s.baseStep = shadeParams.x;\n  s.baseFeather = shadeParams.y;\n  s.shadeStep = shadeParams.z;\n  s.shadeFeather = shadeParams.w;\n}\nvec4 frag () {\n  ToonSurface s; surf(s);\n  vec4 color = CCToonShading(s);\n  return CCFragOutput(color);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n  layout(std140) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 baseColor;\n  vec4 colorScaleAndCutoff;\n  vec4 shadeColor1;\n  vec4 shadeColor2;\n  vec4 specular;\n  vec4 shadeParams;\n  vec4 emissive;\n  vec4 emissiveScaleAndStrenth;\n};\nout highp vec4 v_shadowPos;\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\n#if CC_RECEIVE_SHADOW\n  uniform sampler2D cc_shadowMap;\n  uniform sampler2D cc_spotLightingMap;\n#endif\nout vec3 v_position;\nout vec2 v_uv;\nout vec3 v_normal;\n#if USE_NORMAL_MAP\n  out vec3 v_tangent;\n  out vec3 v_bitangent;\n#endif\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  v_normal = (matWorldIT * vec4(In.normal, 0.0)).xyz;\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_shadowPos = cc_matLightViewProj * pos;\n  return cc_matProj * (cc_matView * matWorld) * In.position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nstruct ToonSurface {\n  vec4 baseColor;\n  vec4 specular;\n  vec3 position;\n  vec3 normal;\n  vec3 shade1;\n  vec3 shade2;\n  vec3 emissive;\n  float baseStep;\n  float baseFeather;\n  float shadeStep;\n  float shadeFeather;\n};\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n  # define LIGHTS_PER_PASS 1\n  #else\n  # define LIGHTS_PER_PASS 10\n  #endif\n  layout(std140) uniform CCForwardLight {\n    highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n    vec4 cc_lightColor[LIGHTS_PER_PASS];\n    vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n    vec4 cc_lightDir[LIGHTS_PER_PASS];\n  };\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  vec4 CCToonShading (ToonSurface s) {\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    vec3 N = normalize(s.normal);\n    float specularWeight = 1.0 - pow(s.specular.a, 5.0);\n    vec3 finalColor = vec3(0.0);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      vec3 SLU = cc_lightPos[i].xyz - s.position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = 0.5 * dot(N, SL) + 0.5;\n      float SNH = 0.5 * dot(N, SH) + 0.5;\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = litRadiusSqr / max(litRadiusSqr , distSqr);\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 diffuse = mix(s.shade1, s.shade2,\n        clamp(1.0 + (s.shadeStep - s.shadeFeather - SNL) / s.shadeFeather, 0.0, 1.0));\n      diffuse = mix(s.baseColor.rgb, diffuse,\n        clamp(1.0 + (s.baseStep - s.baseFeather - SNL) / s.baseFeather, 0.0, 1.0));\n      float specularMask = step(specularWeight, SNH);\n      vec3 specular = s.specular.rgb * specularMask;\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      finalColor += SNL * cc_lightColor[i].rgb * cc_lightColor[i].a * illum * att * s.baseStep * (diffuse + specular);\n    }\n    return vec4(finalColor, 0.0);\n  }\n#else\n  #if CC_RECEIVE_SHADOW\n    in highp vec4 v_shadowPos;\n    layout(std140) uniform CCShadow {\n      highp mat4 cc_matLightPlaneProj;\n      highp mat4 cc_matLightView;\n      highp mat4 cc_matLightViewProj;\n      lowp  vec4 cc_shadowNFLSInfo;\n      lowp  vec4 cc_shadowWHPBInfo;\n      lowp  vec4 cc_shadowLPNNInfo;\n      lowp  vec4 cc_shadowColor;\n    };\n    #if CC_RECEIVE_SHADOW\n      uniform sampler2D cc_shadowMap;\n      uniform sampler2D cc_spotLightingMap;\n      float CCGetShadowFactorX1 (vec4 shadowPos) {\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n            clipPos.y < 0.0 || clipPos.y > 1.0 ||\n            clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n        float shadow = 0.0;\n        float closestDepth = 0.0;\n        clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n        if (cc_shadowLPNNInfo.y > 0.000001) {\n          closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n        } else {\n          closestDepth = texture(cc_shadowMap, clipPos.xy).x;\n        }\n        shadow = step(closestDepth, clipPos.z- cc_shadowWHPBInfo.w);\n        return shadow;\n      }\n      float CCGetShadowFactorX5 (vec4 shadowPos) {\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n            clipPos.y < 0.0 || clipPos.y > 1.0 ||\n            clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n        float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n        float offsety = 1.0 / cc_shadowWHPBInfo.y;\n        float shadow = 0.0;\n        clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n        if (cc_shadowLPNNInfo.y > 0.000001) {\n          float closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n        } else {\n          float closestDepth = texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n        }\n        return shadow / 5.0;\n      }\n      float CCGetShadowFactorX9 (vec4 shadowPos) {\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n            clipPos.y < 0.0 || clipPos.y > 1.0 ||\n            clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n        float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n        float offsety = 1.0 / cc_shadowWHPBInfo.y;\n        float shadow = 0.0;\n        float closestDepth = 0.0;\n        clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n        if (cc_shadowLPNNInfo.y > 0.000001) {\n          for (int i = -1; i <= 1; i++) {\n              for (int j = -1; j <= 1; j++) {\n                float closestDepth = dot(texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n                shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n              }\n          }\n        } else {\n          for (int i = -1; i <= 1; i++) {\n              for (int j = -1; j <= 1; j++) {\n                float closestDepth = texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\n                shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n              }\n          }\n        }\n        return shadow / 9.0;\n      }\n      float CCGetShadowFactorX25 (vec4 shadowPos) {\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n            clipPos.y < 0.0 || clipPos.y > 1.0 ||\n            clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n        float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n        float offsety = 1.0 / cc_shadowWHPBInfo.y;\n        float shadow = 0.0;\n        clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n        if (cc_shadowLPNNInfo.y > 0.000001) {\n          for (int i = -2; i <= 2; i++) {\n            for (int j = -2; j <= 2; j++) {\n              float closestDepth = dot(texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n              shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n            }\n          }\n        } else {\n          for (int i = -2; i <= 2; i++) {\n            for (int j = -2; j <= 2; j++) {\n              float closestDepth = texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\n              shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n            }\n          }\n        }\n        return shadow / 25.0;\n      }\n    #endif\n  #endif\n  vec4 CCToonShading (ToonSurface s) {\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    vec3 N = normalize(s.normal);\n    vec3 L = normalize(-cc_mainLitDir.xyz);\n    float NL = 0.5 * dot(N, L) + 0.5;\n    float NH = 0.5 * dot(normalize(V + L), N) + 0.5;\n    vec3 lightColor = cc_mainLitColor.rgb * cc_mainLitColor.w * s.baseStep;\n    vec3 diffuse = mix(s.shade1, s.shade2,\n      clamp(1.0 + (s.shadeStep - s.shadeFeather - NL) / s.shadeFeather, 0.0, 1.0));\n    diffuse = mix(s.baseColor.rgb, diffuse,\n      clamp(1.0 + (s.baseStep - s.baseFeather - NL) / s.baseFeather, 0.0, 1.0));\n    float specularWeight = 1.0 - pow(s.specular.a, 5.0);\n    float specularMask = step(specularWeight, NH);\n    vec3 specular = s.specular.rgb * specularMask;\n    vec3 finalColor = lightColor * (diffuse + specular);\n    #if CC_USE_HDR\n      s.emissive *= cc_exposure.w;\n    #endif\n    finalColor += s.emissive;\n    #if CC_RECEIVE_SHADOW\n              {\n                float pcf = cc_shadowWHPBInfo.z + 0.001;\n                float shadowAttenuation = 0.0;\n                float cosAngle = clamp(1.0 - dot(N, cc_mainLitDir.xyz), 0.0, 1.0);\n                vec3 projWorldPos = v_shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\n                vec4 pos = vec4(projWorldPos.xyz, v_shadowPos.w);\n                if (pcf > 3.0) shadowAttenuation = CCGetShadowFactorX25(pos);\n                else if (pcf > 2.0) shadowAttenuation = CCGetShadowFactorX9(pos);\n                else if (pcf > 1.0) shadowAttenuation = CCGetShadowFactorX5(pos);\n                else shadowAttenuation = CCGetShadowFactorX1(pos);\n                vec3 shadowColor = cc_shadowColor.rgb * cc_shadowColor.a + finalColor.rgb * (1.0 - cc_shadowColor.a);\n                if (cc_shadowNFLSInfo.w > 0.000001) {\n                  finalColor.rgb = shadowColor.rgb * shadowAttenuation + finalColor.rgb * (1.0 - shadowAttenuation);\n                } else {\n                  finalColor.rgb = shadowColor.rgb * shadowAttenuation * NL + finalColor.rgb * (1.0 - shadowAttenuation * NL);\n                }\n              }\n    #endif\n    return vec4(finalColor, s.baseColor.a);\n  }\n#endif\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 baseColor;\n  vec4 colorScaleAndCutoff;\n  vec4 shadeColor1;\n  vec4 shadeColor2;\n  vec4 specular;\n  vec4 shadeParams;\n  vec4 emissive;\n  vec4 emissiveScaleAndStrenth;\n};\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = sqrt(ACESToneMap(color.rgb));\n  #endif\n  return color;\n}\nin vec3 v_position;\nin vec2 v_uv;\n#if USE_BASE_COLOR_MAP\n  uniform sampler2D baseColorMap;\n#endif\nin vec3 v_normal;\n#if USE_NORMAL_MAP\n  in vec3 v_tangent;\n  in vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_1ST_SHADE_MAP\n  uniform sampler2D shadeMap1;\n#endif\n#if USE_2ND_SHADE_MAP\n  uniform sampler2D shadeMap2;\n#endif\n#if USE_SPECULAR_MAP\n  uniform sampler2D specularMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out ToonSurface s) {\n  s.shade2 = shadeColor2.rgb * colorScaleAndCutoff.rgb;\n  #if USE_2ND_SHADE_MAP\n    s.shade2 *= SRGBToLinear(texture(shadeMap2, v_uv).rgb);\n  #endif\n  s.shade1 = shadeColor1.rgb * colorScaleAndCutoff.rgb;\n  #if USE_1ST_SHADE_MAP\n    s.shade1 *= SRGBToLinear(texture(shadeMap1, v_uv).rgb);\n    #if SHADE_MAP_1_AS_SHADE_MAP_2\n      s.shade2 *= s.shade1.rgb;\n    #endif\n  #endif\n  vec4 baseColor = baseColor;\n  #if USE_BASE_COLOR_MAP\n    vec4 baseColorMap = texture(baseColorMap, v_uv);\n    baseColorMap.rgb = SRGBToLinear(baseColorMap.rgb);\n    baseColor *= baseColorMap;\n    #if BASE_COLOR_MAP_AS_SHADE_MAP_1\n      s.shade1 *= baseColorMap.rgb;\n    #endif\n    #if BASE_COLOR_MAP_AS_SHADE_MAP_2\n      s.shade2 *= baseColorMap.rgb;\n    #endif\n  #endif\n  s.baseColor = baseColor;\n  s.baseColor.rgb *= colorScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.baseColor.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, v_uv).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * emissiveScaleAndStrenth.w) * normalize(v_tangent) +\n      (nmmp.y * emissiveScaleAndStrenth.w) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  s.position = v_position;\n  s.specular = specular;\n  #if USE_SPECULAR_MAP\n    s.specular.rgb *= SRGBToLinear(texture(specularMap, v_uv).rgb);\n  #endif\n  s.emissive = emissive.rgb * emissiveScaleAndStrenth.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture(emissiveMap, v_uv).rgb);\n  #endif\n  s.baseStep = shadeParams.x;\n  s.baseFeather = shadeParams.y;\n  s.shadeStep = shadeParams.z;\n  s.shadeFeather = shadeParams.w;\n}\nvec4 frag () {\n  ToonSurface s; surf(s);\n  vec4 color = CCToonShading(s);\n  return CCFragOutput(color);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      attribute highp vec4 a_jointAnimInfo;\n    #endif\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n#if USE_INSTANCING\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n  uniform highp mat4 cc_matWorlds[10];\n#else\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n#endif\n      uniform vec4 tilingOffset;\nvarying highp vec4 v_shadowPos;\nuniform highp mat4 cc_matLightViewProj;\n#if CC_RECEIVE_SHADOW\n  uniform sampler2D cc_shadowMap;\n  uniform sampler2D cc_spotLightingMap;\n#endif\nvarying vec3 v_position;\nvarying vec2 v_uv;\nvarying vec3 v_normal;\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n#endif\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  v_normal = (matWorldIT * vec4(In.normal, 0.0)).xyz;\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_shadowPos = cc_matLightViewProj * pos;\n  return cc_matProj * (cc_matView * matWorld) * In.position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nuniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_exposure;\n  uniform mediump vec4 cc_mainLitDir;\n  uniform mediump vec4 cc_mainLitColor;\nstruct ToonSurface {\n  vec4 baseColor;\n  vec4 specular;\n  vec3 position;\n  vec3 normal;\n  vec3 shade1;\n  vec3 shade2;\n  vec3 emissive;\n  float baseStep;\n  float baseFeather;\n  float shadeStep;\n  float shadeFeather;\n};\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n  # define LIGHTS_PER_PASS 1\n  #else\n  # define LIGHTS_PER_PASS 10\n  #endif\n  uniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightColor[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  vec4 CCToonShading (ToonSurface s) {\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    vec3 N = normalize(s.normal);\n    float specularWeight = 1.0 - pow(s.specular.a, 5.0);\n    vec3 finalColor = vec3(0.0);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      vec3 SLU = cc_lightPos[i].xyz - s.position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = 0.5 * dot(N, SL) + 0.5;\n      float SNH = 0.5 * dot(N, SH) + 0.5;\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = litRadiusSqr / max(litRadiusSqr , distSqr);\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 diffuse = mix(s.shade1, s.shade2,\n        clamp(1.0 + (s.shadeStep - s.shadeFeather - SNL) / s.shadeFeather, 0.0, 1.0));\n      diffuse = mix(s.baseColor.rgb, diffuse,\n        clamp(1.0 + (s.baseStep - s.baseFeather - SNL) / s.baseFeather, 0.0, 1.0));\n      float specularMask = step(specularWeight, SNH);\n      vec3 specular = s.specular.rgb * specularMask;\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      finalColor += SNL * cc_lightColor[i].rgb * cc_lightColor[i].a * illum * att * s.baseStep * (diffuse + specular);\n    }\n    return vec4(finalColor, 0.0);\n  }\n#else\n  #if CC_RECEIVE_SHADOW\n    varying highp vec4 v_shadowPos;\n    uniform lowp vec4 cc_shadowNFLSInfo;\n  uniform lowp vec4 cc_shadowWHPBInfo;\n  uniform lowp vec4 cc_shadowLPNNInfo;\n  uniform lowp vec4 cc_shadowColor;\n    #if CC_RECEIVE_SHADOW\n      uniform sampler2D cc_shadowMap;\n      uniform sampler2D cc_spotLightingMap;\n      float CCGetShadowFactorX1 (vec4 shadowPos) {\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n            clipPos.y < 0.0 || clipPos.y > 1.0 ||\n            clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n        float shadow = 0.0;\n        float closestDepth = 0.0;\n        clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n        if (cc_shadowLPNNInfo.y > 0.000001) {\n          closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n        } else {\n          closestDepth = texture2D(cc_shadowMap, clipPos.xy).x;\n        }\n        shadow = step(closestDepth, clipPos.z- cc_shadowWHPBInfo.w);\n        return shadow;\n      }\n      float CCGetShadowFactorX5 (vec4 shadowPos) {\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n            clipPos.y < 0.0 || clipPos.y > 1.0 ||\n            clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n        float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n        float offsety = 1.0 / cc_shadowWHPBInfo.y;\n        float shadow = 0.0;\n        clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n        if (cc_shadowLPNNInfo.y > 0.000001) {\n          float closestDepth = dot(texture2D(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = dot(texture2D(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = dot(texture2D(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = dot(texture2D(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n        } else {\n          float closestDepth = texture2D(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = texture2D(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = texture2D(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = texture2D(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n        }\n        return shadow / 5.0;\n      }\n      float CCGetShadowFactorX9 (vec4 shadowPos) {\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n            clipPos.y < 0.0 || clipPos.y > 1.0 ||\n            clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n        float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n        float offsety = 1.0 / cc_shadowWHPBInfo.y;\n        float shadow = 0.0;\n        float closestDepth = 0.0;\n        clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n        if (cc_shadowLPNNInfo.y > 0.000001) {\n          for (int i = -1; i <= 1; i++) {\n              for (int j = -1; j <= 1; j++) {\n                float closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n                shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n              }\n          }\n        } else {\n          for (int i = -1; i <= 1; i++) {\n              for (int j = -1; j <= 1; j++) {\n                float closestDepth = texture2D(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\n                shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n              }\n          }\n        }\n        return shadow / 9.0;\n      }\n      float CCGetShadowFactorX25 (vec4 shadowPos) {\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n            clipPos.y < 0.0 || clipPos.y > 1.0 ||\n            clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n        float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n        float offsety = 1.0 / cc_shadowWHPBInfo.y;\n        float shadow = 0.0;\n        clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n        if (cc_shadowLPNNInfo.y > 0.000001) {\n          for (int i = -2; i <= 2; i++) {\n            for (int j = -2; j <= 2; j++) {\n              float closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n              shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n            }\n          }\n        } else {\n          for (int i = -2; i <= 2; i++) {\n            for (int j = -2; j <= 2; j++) {\n              float closestDepth = texture2D(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\n              shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n            }\n          }\n        }\n        return shadow / 25.0;\n      }\n    #endif\n  #endif\n  vec4 CCToonShading (ToonSurface s) {\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    vec3 N = normalize(s.normal);\n    vec3 L = normalize(-cc_mainLitDir.xyz);\n    float NL = 0.5 * dot(N, L) + 0.5;\n    float NH = 0.5 * dot(normalize(V + L), N) + 0.5;\n    vec3 lightColor = cc_mainLitColor.rgb * cc_mainLitColor.w * s.baseStep;\n    vec3 diffuse = mix(s.shade1, s.shade2,\n      clamp(1.0 + (s.shadeStep - s.shadeFeather - NL) / s.shadeFeather, 0.0, 1.0));\n    diffuse = mix(s.baseColor.rgb, diffuse,\n      clamp(1.0 + (s.baseStep - s.baseFeather - NL) / s.baseFeather, 0.0, 1.0));\n    float specularWeight = 1.0 - pow(s.specular.a, 5.0);\n    float specularMask = step(specularWeight, NH);\n    vec3 specular = s.specular.rgb * specularMask;\n    vec3 finalColor = lightColor * (diffuse + specular);\n    #if CC_USE_HDR\n      s.emissive *= cc_exposure.w;\n    #endif\n    finalColor += s.emissive;\n    #if CC_RECEIVE_SHADOW\n              {\n                float pcf = cc_shadowWHPBInfo.z + 0.001;\n                float shadowAttenuation = 0.0;\n                float cosAngle = clamp(1.0 - dot(N, cc_mainLitDir.xyz), 0.0, 1.0);\n                vec3 projWorldPos = v_shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\n                vec4 pos = vec4(projWorldPos.xyz, v_shadowPos.w);\n                if (pcf > 3.0) shadowAttenuation = CCGetShadowFactorX25(pos);\n                else if (pcf > 2.0) shadowAttenuation = CCGetShadowFactorX9(pos);\n                else if (pcf > 1.0) shadowAttenuation = CCGetShadowFactorX5(pos);\n                else shadowAttenuation = CCGetShadowFactorX1(pos);\n                vec3 shadowColor = cc_shadowColor.rgb * cc_shadowColor.a + finalColor.rgb * (1.0 - cc_shadowColor.a);\n                if (cc_shadowNFLSInfo.w > 0.000001) {\n                  finalColor.rgb = shadowColor.rgb * shadowAttenuation + finalColor.rgb * (1.0 - shadowAttenuation);\n                } else {\n                  finalColor.rgb = shadowColor.rgb * shadowAttenuation * NL + finalColor.rgb * (1.0 - shadowAttenuation * NL);\n                }\n              }\n    #endif\n    return vec4(finalColor, s.baseColor.a);\n  }\n#endif\n    uniform vec4 baseColor;\n    uniform vec4 colorScaleAndCutoff;\n    uniform vec4 shadeColor1;\n    uniform vec4 shadeColor2;\n    uniform vec4 specular;\n    uniform vec4 shadeParams;\n    uniform vec4 emissive;\n    uniform vec4 emissiveScaleAndStrenth;\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = sqrt(ACESToneMap(color.rgb));\n  #endif\n  return color;\n}\nvarying vec3 v_position;\nvarying vec2 v_uv;\n#if USE_BASE_COLOR_MAP\n  uniform sampler2D baseColorMap;\n#endif\nvarying vec3 v_normal;\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_1ST_SHADE_MAP\n  uniform sampler2D shadeMap1;\n#endif\n#if USE_2ND_SHADE_MAP\n  uniform sampler2D shadeMap2;\n#endif\n#if USE_SPECULAR_MAP\n  uniform sampler2D specularMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out ToonSurface s) {\n  s.shade2 = shadeColor2.rgb * colorScaleAndCutoff.rgb;\n  #if USE_2ND_SHADE_MAP\n    s.shade2 *= SRGBToLinear(texture2D(shadeMap2, v_uv).rgb);\n  #endif\n  s.shade1 = shadeColor1.rgb * colorScaleAndCutoff.rgb;\n  #if USE_1ST_SHADE_MAP\n    s.shade1 *= SRGBToLinear(texture2D(shadeMap1, v_uv).rgb);\n    #if SHADE_MAP_1_AS_SHADE_MAP_2\n      s.shade2 *= s.shade1.rgb;\n    #endif\n  #endif\n  vec4 baseColor = baseColor;\n  #if USE_BASE_COLOR_MAP\n    vec4 baseColorMap = texture2D(baseColorMap, v_uv);\n    baseColorMap.rgb = SRGBToLinear(baseColorMap.rgb);\n    baseColor *= baseColorMap;\n    #if BASE_COLOR_MAP_AS_SHADE_MAP_1\n      s.shade1 *= baseColorMap.rgb;\n    #endif\n    #if BASE_COLOR_MAP_AS_SHADE_MAP_2\n      s.shade2 *= baseColorMap.rgb;\n    #endif\n  #endif\n  s.baseColor = baseColor;\n  s.baseColor.rgb *= colorScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.baseColor.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture2D(normalMap, v_uv).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * emissiveScaleAndStrenth.w) * normalize(v_tangent) +\n      (nmmp.y * emissiveScaleAndStrenth.w) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  s.position = v_position;\n  s.specular = specular;\n  #if USE_SPECULAR_MAP\n    s.specular.rgb *= SRGBToLinear(texture2D(specularMap, v_uv).rgb);\n  #endif\n  s.emissive = emissive.rgb * emissiveScaleAndStrenth.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture2D(emissiveMap, v_uv).rgb);\n  #endif\n  s.baseStep = shadeParams.x;\n  s.baseFeather = shadeParams.y;\n  s.shadeStep = shadeParams.z;\n  s.shadeFeather = shadeParams.w;\n}\nvec4 frag () {\n  ToonSurface s; surf(s);\n  vec4 color = CCToonShading(s);\n  return CCFragOutput(color);\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotLightingMap","defines":["CC_RECEIVE_SHADOW"]}]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":219,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":62}},"defines":[{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["CC_USE_SKINNING"]},{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"USE_LIGHTMAP","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":[]},{"name":"USE_NORMAL_MAP","type":"boolean","defines":[]},{"name":"CC_FORWARD_ADD","type":"boolean","defines":[]},{"name":"CC_PIPELINE_TYPE","type":"number","defines":["CC_FORWARD_ADD"],"range":[0,1]},{"name":"CC_USE_HDR","type":"boolean","defines":[]},{"name":"USE_BASE_COLOR_MAP","type":"boolean","defines":[]},{"name":"USE_1ST_SHADE_MAP","type":"boolean","defines":[]},{"name":"USE_2ND_SHADE_MAP","type":"boolean","defines":[]},{"name":"USE_SPECULAR_MAP","type":"boolean","defines":[]},{"name":"USE_EMISSIVE_MAP","type":"boolean","defines":[]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"ALPHA_TEST_CHANNEL","type":"string","defines":["USE_ALPHA_TEST"],"options":["a","r","g","b"]},{"name":"SHADE_MAP_1_AS_SHADE_MAP_2","type":"boolean","defines":["USE_1ST_SHADE_MAP"]},{"name":"BASE_COLOR_MAP_AS_SHADE_MAP_1","type":"boolean","defines":["USE_BASE_COLOR_MAP"]},{"name":"BASE_COLOR_MAP_AS_SHADE_MAP_2","type":"boolean","defines":["USE_BASE_COLOR_MAP"]}],"blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"baseColor","type":16,"count":1},{"name":"colorScaleAndCutoff","type":16,"count":1},{"name":"shadeColor1","type":16,"count":1},{"name":"shadeColor2","type":16,"count":1},{"name":"specular","type":16,"count":1},{"name":"shadeParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleAndStrenth","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"baseColorMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_BASE_COLOR_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_NORMAL_MAP"]},{"name":"shadeMap1","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_1ST_SHADE_MAP"]},{"name":"shadeMap2","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_2ND_SHADE_MAP"]},{"name":"specularMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_SPECULAR_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_EMISSIVE_MAP"]}],"attributes":[{"name":"a_position","type":15,"count":1,"stageFlags":1,"format":32,"location":0,"defines":[]},{"name":"a_normal","type":15,"count":1,"stageFlags":1,"format":32,"location":1,"defines":[]},{"name":"a_texCoord","type":14,"count":1,"stageFlags":1,"format":21,"location":2,"defines":[]},{"name":"a_tangent","type":16,"count":1,"stageFlags":1,"format":44,"location":3,"defines":[]},{"name":"a_vertexId","type":13,"count":1,"stageFlags":1,"format":11,"location":6,"defines":["CC_USE_MORPH"]},{"name":"a_joints","type":"u32vec4","count":1,"stageFlags":1,"location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","type":16,"count":1,"stageFlags":1,"format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":7,"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION","USE_INSTANCING"]},{"name":"a_matWorld0","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","USE_LIGHTMAP"]},{"name":"a_dyn_batch_id","type":13,"count":1,"stageFlags":1,"format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]}],"varyings":[{"name":"v_shadowPos","type":16,"count":1,"stageFlags":1,"location":0,"defines":[]},{"name":"v_position","type":15,"count":1,"stageFlags":1,"location":1,"defines":[]},{"name":"v_uv","type":14,"count":1,"stageFlags":1,"location":2,"defines":[]},{"name":"v_normal","type":15,"count":1,"stageFlags":1,"location":3,"defines":[]},{"name":"v_tangent","type":15,"count":1,"stageFlags":1,"location":4,"defines":["USE_NORMAL_MAP"]},{"name":"v_bitangent","type":15,"count":1,"stageFlags":1,"location":5,"defines":["USE_NORMAL_MAP"]}]},{"hash":1991198131,"name":"builtin-toon|shadow-caster-vs:vert|shadow-caster-fs:frag","glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 6) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 7) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 8) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      layout(location = 7) in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 5) uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if USE_INSTANCING\n  layout(location = 8) in vec4 a_matWorld0;\n  layout(location = 9) in vec4 a_matWorld1;\n  layout(location = 10) in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    layout(location = 11) in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n  layout(set = 2, binding = 0) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(set = 2, binding = 0) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 baseColor;\n  vec4 colorScaleAndCutoff;\n  vec4 shadeColor1;\n  vec4 shadeColor2;\n  vec4 specular;\n  vec4 shadeParams;\n  vec4 emissive;\n  vec4 emissiveScaleAndStrenth;\n};\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\nlayout(location = 0) out vec2 v_uv;\nlayout(location = 1) out vec2 v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  vec4 worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  v_clip_depth = clipPos.zw;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 baseColor;\n  vec4 colorScaleAndCutoff;\n  vec4 shadeColor1;\n  vec4 shadeColor2;\n  vec4 specular;\n  vec4 shadeParams;\n  vec4 emissive;\n  vec4 emissiveScaleAndStrenth;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\n  ret = fract(ret);\n  ret -= ret.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n  return ret;\n}\nlayout(location = 0) in vec2 v_uv;\nlayout(location = 1) in vec2 v_clip_depth;\n#if USE_BASE_COLOR_MAP\n  layout(set = 1, binding = 1) uniform sampler2D baseColorMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = baseColor;\n  #if USE_BASE_COLOR_MAP\n    baseColor *= texture(baseColorMap, v_uv);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  return packDepthToRGBA(v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if USE_INSTANCING\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n  layout(std140) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 baseColor;\n  vec4 colorScaleAndCutoff;\n  vec4 shadeColor1;\n  vec4 shadeColor2;\n  vec4 specular;\n  vec4 shadeParams;\n  vec4 emissive;\n  vec4 emissiveScaleAndStrenth;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\nout vec2 v_uv;\nout vec2 v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  vec4 worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  v_clip_depth = clipPos.zw;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 baseColor;\n  vec4 colorScaleAndCutoff;\n  vec4 shadeColor1;\n  vec4 shadeColor2;\n  vec4 specular;\n  vec4 shadeParams;\n  vec4 emissive;\n  vec4 emissiveScaleAndStrenth;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\n  ret = fract(ret);\n  ret -= ret.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n  return ret;\n}\nin vec2 v_uv;\nin vec2 v_clip_depth;\n#if USE_BASE_COLOR_MAP\n  uniform sampler2D baseColorMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = baseColor;\n  #if USE_BASE_COLOR_MAP\n    baseColor *= texture(baseColorMap, v_uv);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  return packDepthToRGBA(v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      attribute highp vec4 a_jointAnimInfo;\n    #endif\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if USE_INSTANCING\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n  uniform highp mat4 cc_matWorlds[10];\n#else\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n#endif\n      uniform vec4 tilingOffset;\nuniform highp mat4 cc_matLightViewProj;\nvarying vec2 v_uv;\nvarying vec2 v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  vec4 worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  v_clip_depth = clipPos.zw;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\n   uniform vec4 baseColor;\n   uniform vec4 colorScaleAndCutoff;\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\n  ret = fract(ret);\n  ret -= ret.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n  return ret;\n}\nvarying vec2 v_uv;\nvarying vec2 v_clip_depth;\n#if USE_BASE_COLOR_MAP\n  uniform sampler2D baseColorMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = baseColor;\n  #if USE_BASE_COLOR_MAP\n    baseColor *= texture2D(baseColorMap, v_uv);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  return packDepthToRGBA(v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5);\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCShadow","defines":[]}],"samplerTextures":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":182,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":9}},"defines":[{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["CC_USE_SKINNING"]},{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"USE_LIGHTMAP","type":"boolean","defines":["USE_INSTANCING"]},{"name":"USE_BASE_COLOR_MAP","type":"boolean","defines":[]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"ALPHA_TEST_CHANNEL","type":"string","defines":["USE_ALPHA_TEST"],"options":["a","r","g","b"]}],"blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"baseColor","type":16,"count":1},{"name":"colorScaleAndCutoff","type":16,"count":1},{"name":"shadeColor1","type":16,"count":1},{"name":"shadeColor2","type":16,"count":1},{"name":"specular","type":16,"count":1},{"name":"shadeParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleAndStrenth","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"baseColorMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_BASE_COLOR_MAP"]}],"attributes":[{"name":"a_position","type":15,"count":1,"stageFlags":1,"format":32,"location":0,"defines":[]},{"name":"a_normal","type":15,"count":1,"stageFlags":1,"format":32,"location":1,"defines":[]},{"name":"a_texCoord","type":14,"count":1,"stageFlags":1,"format":21,"location":2,"defines":[]},{"name":"a_tangent","type":16,"count":1,"stageFlags":1,"format":44,"location":3,"defines":[]},{"name":"a_vertexId","type":13,"count":1,"stageFlags":1,"format":11,"location":6,"defines":["CC_USE_MORPH"]},{"name":"a_joints","type":"u32vec4","count":1,"stageFlags":1,"location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","type":16,"count":1,"stageFlags":1,"format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":7,"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION","USE_INSTANCING"]},{"name":"a_matWorld0","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","USE_LIGHTMAP"]},{"name":"a_dyn_batch_id","type":13,"count":1,"stageFlags":1,"format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]}],"varyings":[{"name":"v_uv","type":14,"count":1,"stageFlags":1,"location":0,"defines":[]},{"name":"v_clip_depth","type":14,"count":1,"stageFlags":1,"location":1,"defines":[]}]}],[{"passes":[{"program":"builtin-toon|outline-vs:vert|outline-fs:frag","switch":"USE_OUTLINE_PASS","rasterizerState":{"cullMode":1},"properties":{"lineWidth":{"type":13,"value":[10],"handleInfo":["outlineParams",0,13]},"depthBias":{"type":13,"value":[0],"handleInfo":["outlineParams",1,13]},"baseColor":{"type":16,"editor":{"type":"color"}},"baseColorMap":{"value":"grey","type":28},"outlineParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[10,0,0,0]}}},{"program":"builtin-toon|toon-vs:vert|toon-fs:frag","properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[0.6,0.6,0.6,1],"editor":{"displayName":"BaseColor","type":"color"},"handleInfo":["baseColor",0,16]},"colorScale":{"type":15,"value":[1,1,1],"handleInfo":["colorScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["colorScaleAndCutoff",3,13]},"shadeColor1":{"type":16,"value":[0.4,0.4,0.4,1],"editor":{"type":"color"}},"shadeColor2":{"type":16,"value":[0.2,0.2,0.2,1],"editor":{"type":"color"}},"specular":{"type":16,"value":[1,1,1,0.3],"editor":{"type":"color"}},"baseStep":{"type":13,"value":[0.8],"handleInfo":["shadeParams",0,13]},"baseFeather":{"type":13,"value":[0.001],"handleInfo":["shadeParams",1,13]},"shadeStep":{"type":13,"value":[0.5],"handleInfo":["shadeParams",2,13]},"shadeFeather":{"type":13,"value":[0.001],"handleInfo":["shadeParams",3,13]},"emissive":{"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleAndStrenth",0,15]},"normalStrenth":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP"},"handleInfo":["emissiveScaleAndStrenth",3,13]},"normalMap":{"value":"normal","type":28},"mainTexture":{"value":"white","type":28,"editor":{"displayName":"BaseColorMap"},"handleInfo":["baseColorMap",0,28]},"shadeMap1":{"value":"white","type":28},"shadeMap2":{"value":"white","type":28},"specularMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"baseColor":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[0.6,0.6,0.6,1]},"colorScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"shadeParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[0.8,0.001,0.5,0.001]},"emissiveScaleAndStrenth":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"baseColorMap":{"type":28,"value":"white","editor":{"visible":false,"deprecated":true}}}},{"phase":"forward-add","propertyIndex":1,"program":"builtin-toon|toon-vs:vert|toon-fs:frag","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[0.6,0.6,0.6,1],"editor":{"displayName":"BaseColor","type":"color"},"handleInfo":["baseColor",0,16]},"colorScale":{"type":15,"value":[1,1,1],"handleInfo":["colorScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["colorScaleAndCutoff",3,13]},"shadeColor1":{"type":16,"value":[0.4,0.4,0.4,1],"editor":{"type":"color"}},"shadeColor2":{"type":16,"value":[0.2,0.2,0.2,1],"editor":{"type":"color"}},"specular":{"type":16,"value":[1,1,1,0.3],"editor":{"type":"color"}},"baseStep":{"type":13,"value":[0.8],"handleInfo":["shadeParams",0,13]},"baseFeather":{"type":13,"value":[0.001],"handleInfo":["shadeParams",1,13]},"shadeStep":{"type":13,"value":[0.5],"handleInfo":["shadeParams",2,13]},"shadeFeather":{"type":13,"value":[0.001],"handleInfo":["shadeParams",3,13]},"emissive":{"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleAndStrenth",0,15]},"normalStrenth":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP"},"handleInfo":["emissiveScaleAndStrenth",3,13]},"normalMap":{"value":"normal","type":28},"mainTexture":{"value":"white","type":28,"editor":{"displayName":"BaseColorMap"},"handleInfo":["baseColorMap",0,28]},"shadeMap1":{"value":"white","type":28},"shadeMap2":{"value":"white","type":28},"specularMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"baseColor":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[0.6,0.6,0.6,1]},"colorScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"shadeParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[0.8,0.001,0.5,0.001]},"emissiveScaleAndStrenth":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"baseColorMap":{"type":28,"value":"white","editor":{"visible":false,"deprecated":true}}}},{"phase":"shadow-caster","propertyIndex":1,"program":"builtin-toon|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[0.6,0.6,0.6,1],"editor":{"displayName":"BaseColor","type":"color"},"handleInfo":["baseColor",0,16]},"colorScale":{"type":15,"value":[1,1,1],"handleInfo":["colorScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["colorScaleAndCutoff",3,13]},"shadeColor1":{"type":16,"value":[0.4,0.4,0.4,1],"editor":{"type":"color"}},"shadeColor2":{"type":16,"value":[0.2,0.2,0.2,1],"editor":{"type":"color"}},"specular":{"type":16,"value":[1,1,1,0.3],"editor":{"type":"color"}},"baseStep":{"type":13,"value":[0.8],"handleInfo":["shadeParams",0,13]},"baseFeather":{"type":13,"value":[0.001],"handleInfo":["shadeParams",1,13]},"shadeStep":{"type":13,"value":[0.5],"handleInfo":["shadeParams",2,13]},"shadeFeather":{"type":13,"value":[0.001],"handleInfo":["shadeParams",3,13]},"emissive":{"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleAndStrenth",0,15]},"normalStrenth":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP"},"handleInfo":["emissiveScaleAndStrenth",3,13]},"mainTexture":{"value":"white","type":28,"editor":{"displayName":"BaseColorMap"},"handleInfo":["baseColorMap",0,28]},"baseColor":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[0.6,0.6,0.6,1]},"colorScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"shadeParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[0.8,0.001,0.5,0.001]},"emissiveScaleAndStrenth":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"baseColorMap":{"type":28,"value":"white","editor":{"visible":false,"deprecated":true}}}}]}]]],0,0,[],[],[]],[[[133,"Skin-0",753820634,["RootNode/Bone004/Bone005/Bone006","RootNode/Bone004/Bone005","RootNode/Bone004","RootNode/Bone001/Bone002/Bone003","RootNode/Bone001/Bone002","RootNode/Bone001"],[[[7,0.0004333891556598246,0.10229005664587021,0.21936364471912384,0,-0.0009294628980569541,-0.21936167776584625,0.10229097306728363,0,0.24203883111476898,-0.0010255376109853387,2.406476085070608e-8,0,-0.08006425946950912,0.028319520875811577,-0.005389618221670389,1],[7,0.0006473671528510749,0.10228893905878067,0.21936364471912384,0,-0.001388339907862246,-0.21935929358005524,0.10229097306728363,0,0.24203617870807648,-0.0015318524092435837,2.4064471304541257e-8,0,-0.04029082506895065,0.0284869447350502,-0.005389610305428505,1],[7,-0.0006353461649268866,0.10228794068098068,0.21936413645744324,0,0.0013624817365780473,-0.21935993432998657,0.10228990018367767,0,0.2420363426208496,0.0015033365925773978,1.664581716909197e-8,0,-0.0001784319174475968,0.02797948755323887,-0.0053894720040261745,1],[7,0.0004333891556598246,0.10229005664587021,0.21936364471912384,0,-0.0009294628980569541,-0.21936167776584625,0.10229097306728363,0,0.24203883111476898,-0.0010255376109853387,2.406476085070608e-8,0,-0.08025984466075897,-0.017842883244156837,0.01121316384524107,1],[7,0.0006473671528510749,0.10228893905878067,0.21936364471912384,0,-0.001388339907862246,-0.21935929358005524,0.10229097306728363,0,0.24203617870807648,-0.0015318524092435837,2.4064471304541257e-8,0,-0.040582988411188126,-0.017674952745437622,0.011213171295821667,1],[7,-0.0006353461649268866,0.10228794068098068,0.21936413645744324,0,0.0013624817365780473,-0.21935993432998657,0.10228990018367767,0,0.2420363426208496,0.0015033365925773978,1.664581716909197e-8,0,0.00010828844096977264,-0.01818251982331276,0.011213085614144802,1]],8,8,8,8,8,8]]],0,0,[],[],[]],[[[134,"Take 001",".bin",30,2,true,3.3333332538604736,1114036689,[[19,8000,81,6,81]],[[[{},"modifiers",12,[[-1,"rotation"],1,0],"data",11,[{"keys":0},"values",4,[135,324,38,81]]],[{},"modifiers",12,[[-2,"position"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[19,1296,3,22,1]]],[{},"modifiers",12,[[-3,"scale"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[19,1308,3,22,1]]],[{},"modifiers",12,[[-4,"rotation"],1,0],"data",11,[{"keys":0},"values",4,[19,1320,324,38,81]]],[{},"modifiers",12,[[-5,"position"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[19,2616,3,22,1]]],[{},"modifiers",12,[[-6,"scale"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[19,2628,3,22,1]]],[{},"modifiers",12,[[-7,"rotation"],1,0],"data",11,[{"keys":0},"values",4,[19,2640,324,38,81]]],[{},"modifiers",12,[[-8,"position"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[19,3936,3,22,1]]],[{},"modifiers",12,[[-9,"scale"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[19,3948,3,22,1]]],[{},"modifiers",12,[[-10,"rotation"],1,0],"data",11,[{"keys":0},"values",4,[19,3960,324,38,81]]],[{},"modifiers",12,[[-11,"position"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[19,5256,3,22,1]]],[{},"modifiers",12,[[-12,"scale"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[19,5268,3,22,1]]],[{},"modifiers",12,[[-13,"rotation"],1,0],"data",11,[{"keys":0},"values",4,[19,5280,324,38,81]]],[{},"modifiers",12,[[-14,"position"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[19,6576,3,22,1]]],[{},"modifiers",12,[[-15,"scale"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[19,6588,3,22,1]]],[{},"modifiers",12,[[-16,"rotation"],1,0],"data",11,[{"keys":0},"values",4,[19,6600,324,38,81]]],[{},"modifiers",12,[[-17,"position"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[19,7896,3,22,1]]],[{},"modifiers",12,[[-18,"scale"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[19,7908,3,22,1]]],[{},"modifiers",12,[[-19,"position"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[19,7920,3,22,1]]],[{},"modifiers",12,[[-20,"scale"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[19,7932,3,22,1]]],[{},"modifiers",12,[[-21,"rotation"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[19,7944,4,38,1]]],[{},"modifiers",12,[[-22,"position"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[19,7960,3,22,1]]],[{},"modifiers",12,[[-23,"scale"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[19,7972,3,22,1]]],[{},"modifiers",12,[[-24,"rotation"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[19,7984,4,38,1]]]],11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11]],[44,"RootNode/Bone001"],[44,"RootNode/Bone001/Bone002"],[44,"RootNode/Bone001/Bone002/Bone003"],[44,"RootNode/Bone004"],[44,"RootNode/Bone004/Bone005"],[44,"RootNode/Bone004/Bone005/Bone006"],[44,"RootNode"],[44,"RootNode/grass"]],0,[0,-1,1,0,-1,1,0,-1,1,0,-1,2,0,-1,2,0,-1,2,0,-1,3,0,-1,3,0,-1,3,0,-1,4,0,-1,4,0,-1,4,0,-1,5,0,-1,5,0,-1,5,0,-1,6,0,-1,6,0,-1,6,0,-1,7,0,-1,7,0,-1,7,0,-1,8,0,-1,8,0,-1,8,24],[],[],[]],[[[23,".bin",8542,3275415776,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":8080,"length":462,"count":231,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":8080,"count":101,"stride":80},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}],"jointMaps":[[0,1,2,3,4,5]]},"minPosition",8,[1,-0.23816974461078644,-0.3651643395423889,-0.02080436609685421],"maxPosition",8,[1,0.2359408587217331,0.26479941606521606,0.6728445887565613]]]],0,0,[],[],[]],[[[20,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{}],[{"USE_POSITION_SCALING":true},{"USE_BASE_COLOR_MAP":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{},{}],[[{},[{"baseStep":0.9,"baseFeather":0.3,"shadeStep":0.6,"shadeFeather":0.2},"tilingOffset",8,[2,2,1,0,0],"mainColor",8,[4,4284769380],"shadeColor1",8,[4,4283453520],"shadeColor2",8,[4,1661602314],"specular",8,[4,1275068415],"emissive",8,[4,0],"mainTexture",6,0],{},{}],0,11,0,0]]],0,0,[0,0],[9,7],[77,2]],[[[20,[{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}}],[{"USE_TEXTURE":true}],[[[{"alphaThreshold":0},"mainTexture",6,0]],11]]],0,0,[0,0],[9,7],[78,13]],[[[45,"GanController"],[94,"GanController",false,33554432,[-4,-5],[[10,-2,[4,"e46VsT6gdKyb5oga0gRWdM"],[5,100,1100]],[103,34,31.964999999999975,-3,[4,"4aDCs87xBF2JZLcaIVpnFw"]]],[5,"a7SF/JI0ZJc6sVsZK13Ggt",-1,0],[1,398.035,0,0]],[61,"LiController",33554432,1,[-8,-9],[[10,-6,[4,"34i+tTAOtB6Zwf7F7KpSNv"],[5,72,532]],[136,-7,[4,"bf35sPrMVGk4YON/6DdSo8"]]],[5,"2a5q95WulOHq1TsFCq7zJO",1,0],[1,-0.002999999999957481,0,0]],[61,"PointButton",33554432,1,[-12,-13],[[54,-10,[4,"d5g2JUmIBMVai3uwb4D3++"]],[47,-11,[4,"665E4hELtDg5uQBnEbLqSa"],[[50]]]],[5,"3a7H0jyRxC6rDXTh4HPhDj",1,0],[1,0,-349.626,0]],[39,"li-bg",33554432,2,[[10,-14,[4,"f7NISe7HdAD68SLfhnddy8"],[5,72,532]],[56,0,-15,[4,"e71ctEmpxFC4KlSYRZNz/a"],0],[104,-16,[4,"e64gMJJN5Aebg8hPGG4wNs"]]],[5,"cfAnaKeadKX6vv6kYPjn6h",1,0]],[61,"li-mask",33554432,2,[-19],[[76,-17,[4,"58bb3IZodFRYbWNkrETtvk"],[5,72,0],[0,0,1]],[137,-18,[4,"cdafk9KRxNuL7O9kWIRXCL"]]],[5,"4faMcw6CVI5ZCAo2HSuzBX",1,0],[1,-36,266,0]],[39,"li",33554432,5,[[76,-20,[4,"f7NISe7HdAD68SLfhnddy8"],[5,72,532],[0,0,1]],[56,0,-21,[4,"e71ctEmpxFC4KlSYRZNz/a"],1]],[5,"ac3cul0FBAH46pVm2u7rG8",1,0]],[39,"ball",33554432,3,[[10,-22,[4,"f7NISe7HdAD68SLfhnddy8"],[5,80,80]],[56,0,-23,[4,"e71ctEmpxFC4KlSYRZNz/a"],2]],[5,"bctCPI0NpHCZAuivGv50To",1,0]],[73,"redpoint",33554432,3,[[10,-24,[4,"f7NISe7HdAD68SLfhnddy8"],[5,20,20]],[15,-25,[4,"e71ctEmpxFC4KlSYRZNz/a"],3]],[5,"64wGFFyedMXZ+BJnwNkWB8",1,0],[1,0.5,0.5,1]]],0,[0,5,1,0,2,1,0,2,1,0,-1,2,0,-2,3,0,2,2,0,2,2,0,-1,4,0,-2,5,0,2,3,0,2,3,0,-1,7,0,-2,8,0,2,4,0,2,4,0,2,4,0,2,5,0,2,5,0,-1,6,0,2,6,0,2,6,0,2,7,0,2,7,0,2,8,0,2,8,0,14,1,25],[0,0,0,0],[6,6,6,6],[79,80,20,19]],[[[20,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{}],[{"USE_POSITION_SCALING":true},{"USE_BASE_COLOR_MAP":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{},{}],[[{},[{"baseStep":0.9,"baseFeather":0.3,"shadeStep":0.6,"shadeFeather":0.2},"tilingOffset",8,[2,2,1,0,0],"mainColor",8,[4,4284769380],"shadeColor1",8,[4,4283453520],"shadeColor2",8,[4,1661602314],"specular",8,[4,1275068415],"emissive",8,[4,0],"mainTexture",6,0],{},{}],0,11,0,0]]],0,0,[0,0],[9,7],[81,2]],[[[45,"islands"],[58,"islands",[-2],[5,"26LvC5hbxAuJZ9Jl2SB/IV",-1,0]],[33,"RootNode",1,[-3,-4,-5,-6,-7,-8,-9,-10,-11,-12],[5,"068WXOAs1HrIDx+RBQ6XoV",1,0]],[24,"plane01",2,[[66,-13,[4,"ddvMFij+ZIL5lu+/NQX8Nf"],[0],[7],1]],[5,"70dgNwYARPfbvgVcNs+gIQ",1,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,4.25968408584595,4.25968408584595,2.35247683525085],[1,-90.00000000000003,0,0]],[95,"stone1",2,[[43,1,-14,[4,"e3XMjUJKFLH41z39JaWzyB"],[2],[7],3]],[5,"fd517lz3tOuqVWGd5300X6",1,0],[1,-1.68451106548309,0.804959058761597,-2.55509376525879],[1,0.111417099833488,0.111417099833488,0.111417099833488],[1,0.000009334667642611398,0,0]],[42,"tree1",2,[[66,-15,[4,"a5Viy6l3VLDpf6gY5yZF+v"],[4],[7],5]],[5,"1evO3wfhhGVomhJPkvbiM/",1,0],[1,2.69967889785767,0.392187118530273,-3.67192149162292],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-90.00000000000003,0,0]],[42,"tree1(__autogen 3)",2,[[43,1,-16,[4,"e4If/bQrJCsb9D9JopZa2h"],[6],[7],7]],[5,"91DpAWXZ9CFJ+Wk1gnOU27",1,0],[1,4.34285020828247,0.273025780916214,-4.5796275138855],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-90.00000000000003,0,0]],[42,"tree1(__autogen 4)",2,[[43,1,-17,[4,"d7Vkz0NV5Mn4RUce28JVTp"],[8],[7],9]],[5,"03YnQPZo5Nc7TYZfZ1EVIK",1,0],[1,-2.78155946731567,0.366120487451553,-5.44366216659546],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-90.00000000000003,0,0]],[42,"tree1(__autogen 5)",2,[[43,1,-18,[4,"3eVATgLQJKDbqOvE33W2uc"],[10],[7],11]],[5,"aehmnp6BdEt5duOREy07Ic",1,0],[1,-3.78196001052856,0.328564822673798,-3.62895131111145],[3,-0.7071067811865447,-6.18172403853676e-8,-6.18172403853676e-8,0.7071067811865447],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-89.99999999999999,-0.000010017912624975451,0]],[42,"tree1(__autogen 6)",2,[[43,1,-19,[4,"2akU/MgO5Ovo6QcS0c/I7e"],[12],[7],13]],[5,"1dXVprqA1AkpKbrdcroE4U",1,0],[1,-6.02857780456543,0.0573978498578072,-3.32550001144409],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-90.00000000000003,0,0]],[42,"tree1(__autogen 7)",2,[[43,1,-20,[4,"54xaKIQbtPLK5r21VY0qmM"],[14],[7],15]],[5,"c2n9MRvPxJRbv1PP2mhkZO",1,0],[1,-0.547172009944916,0.595235526561737,-3.40697646141052],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-90.00000000000003,0,0]],[42,"tree1(__autogen 8)",2,[[43,1,-21,[4,"23UFBqszxJ/6Otof04QwYT"],[16],[7],17]],[5,"e7VpTFkQ1Ev40vpNxYe7EG",1,0],[1,-6.58904409408569,0.117208734154701,-1.02060234546661],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-90.00000000000003,0,0]],[42,"tree1(__autogen 9)",2,[[43,1,-22,[4,"c7PE6gNTdDw45ytwlOEWR3"],[18],[7],19]],[5,"a1wQefYUNInYWhsOmPzInv",1,0],[1,5.92053079605103,0.1805190294981,-2.71322011947632],[3,-0.7071067811865447,-6.18172403853676e-8,-6.18172403853676e-8,0.7071067811865447],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-89.99999999999999,-0.000010017912624975451,0]]],0,[0,5,1,0,-1,2,0,-1,3,0,-2,4,0,-3,5,0,-4,6,0,-5,7,0,-6,8,0,-7,9,0,-8,10,0,-9,11,0,-10,12,0,2,3,0,2,4,0,2,5,0,2,6,0,2,7,0,2,8,0,2,9,0,2,10,0,2,11,0,2,12,0,14,1,22],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[-1,3,-1,3,-1,3,-1,3,-1,3,-1,3,-1,3,-1,3,-1,3,-1,3],[82,83,21,22,11,84,11,85,11,86,11,87,11,88,11,89,11,90,11,91]],[[[20,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"mainColor",8,[4,1158489343]]],11]]],0,0,[0],[7],[13]],[[{"name":"bg","rect":{"x":0,"y":0,"width":1,"height":1},"offset":{"x":0,"y":0},"originalSize":{"width":1,"height":1},"rotated":false,"capInsets":[0,0,0,0],"texture":"d44eb5d6-1234-421d-909a-663d47061eb5@6c48a","packable":true}],[1],0,[0],[13],[92]],[[[20,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{}],[{"USE_POSITION_SCALING":true},{"USE_BASE_COLOR_MAP":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{},{}],[[{},[{"baseStep":0.9,"baseFeather":0.3,"shadeStep":0.6,"shadeFeather":0.2},"tilingOffset",8,[2,2,1,0,0],"mainColor",8,[4,4284769380],"shadeColor1",8,[4,4283453520],"shadeColor2",8,[4,1661602314],"specular",8,[4,1275068415],"emissive",8,[4,0],"mainTexture",6,0],{},{}],0,11,0,0]]],0,0,[0,0],[9,7],[93,2]],[[{"name":"redpoint","rect":{"x":0,"y":0,"width":20,"height":20},"offset":{"x":0,"y":0},"originalSize":{"width":20,"height":20},"rotated":false,"capInsets":[0,0,0,0],"texture":"f8b9b132-020e-4fc2-b06e-bb0c79cf5e68@6c48a","packable":true}],[1],0,[0],[13],[94]],[[[51,"Material #137",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0,0.19243018329143524,0]]],11]]],0,0,[0],[7],[10]],[[[51,"Material #162",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0,0,0]]],11]]],0,0,[0],[7],[10]],[[[23,".bin",3411312,3510671079,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":380736,"length":88152,"count":22038,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":610536,"length":45240,"count":11310,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[2],"indexView":{"offset":875808,"length":78336,"count":19584,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[3],"indexView":{"offset":1350432,"length":120144,"count":30036,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[4],"indexView":{"offset":2918928,"length":492384,"count":123096,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":380736,"count":7932,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":468888,"length":141648,"count":2951,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":655776,"length":220032,"count":4584,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":954144,"length":396288,"count":8256,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":1470576,"length":1448352,"count":30174,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.014705942943692207,-0.008589384146034718,-0.008324740454554558],"maxPosition",8,[1,0.014691447839140892,0.0006197333568707108,0.008252227678894997]]]],0,0,[],[],[]],[[[51,"Material #136",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0,0,0]]],11]]],0,0,[0],[7],[10]],[[[51,"Material #161",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.22908353805541992,0,0]]],11]]],0,0,[0],[7],[10]],[[[83,"Material #135",[{"metallic":0.4000000059604645,"roughness":0.30151134729385376}],[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}]]],0,0,[0],[7],[10]],[[[23,".bin",69336,3677276551,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":61584,"length":7752,"count":1938,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":61584,"count":1283,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.01361889485269785,-0.006102928426116705,-0.007663379888981581],"maxPosition",8,[1,0.013600582256913185,0.012708475813269615,0.00762323010712862]]]],0,0,[],[],[]],[[[23,".bin",5424,2231751673,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":4560,"length":864,"count":216,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":4560,"count":95,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.013148099184036255,-1.38848410546899e-9,-0.006730927154421806],"maxPosition",8,[1,0.013134442269802094,0,0.0066865431144833565]]]],0,0,[],[],[]],[[[84],[58,"desk",[-2,-3,-4],[5,"82KF56FIRaHbGBpMUksA/v",-1,0]],[24,"desk",1,[[66,-5,[4,"19XVIfzb5UbZplLB+sJx9v"],[0,1,2,3,4],[7],5]],[5,"80ajeX8uhZMoFat4R3FDZ2",1,0],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[24,"desk-collison-plane",1,[[80,[null],-6,[4,"24cpP43h9a/IsUPkP+IZl3"],[7],6]],[5,"dfn3nYpfBdc5ZR008f/Iuq",1,0],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[24,"desk-collison-wall",1,[[80,[null],-7,[4,"aepFlFN6BcgLlpGrFS2TZB"],[7],7]],[5,"aevtN1k6pYuoB+2b37w97j",1,0],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]]],0,[0,5,1,0,-1,2,0,-2,3,0,-3,4,0,2,2,0,2,3,0,2,4,0,14,1,7],[0,0,0,0,0,0,0,0],[-1,-2,-3,-4,-5,3,3,3],[95,96,97,98,99,100,24,25]],[[{"name":"star_gray","rect":{"x":3,"y":5,"width":19,"height":17},"offset":{"x":-1,"y":0},"originalSize":{"width":27,"height":27},"rotated":false,"capInsets":[0,0,0,0],"texture":"faad0244-e93a-4ad1-b9f7-a54fbea688db@6c48a","packable":true}],[1],0,[0],[13],[101]],[[{"name":"succ","rect":{"x":162,"y":176,"width":1760,"height":1536},"offset":{"x":0,"y":98},"originalSize":{"width":2084,"height":2084},"rotated":false,"capInsets":[0,0,0,0],"texture":"ffcb2084-b30f-4aa3-b9b9-42fac517b1f0@6c48a","packable":true}],[1],0,[0],[13],[102]]]]
